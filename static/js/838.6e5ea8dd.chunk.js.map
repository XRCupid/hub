{"version":3,"file":"static/js/838.6e5ea8dd.chunk.js","mappings":"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","sources":["webpack://hub/./src/components/EmotionAnalysis.css?6ee3","services/HumeAIService.js","components/EmotionAnalysis.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {};","// HumeAIService.js - Service to handle WebSocket connections with Hume AI API\nimport { webSocketManager } from './WebSocketManager';\n\nclass HumeAIService {\n  constructor(apiKey = null) {\n    this.apiKey =\n      apiKey ||\n      process.env.REACT_APP_HUME_API_KEY ||\n      process.env.NEXT_PUBLIC_HUME_API_KEY;\n    this.secret =\n      process.env.REACT_APP_HUME_SECRET || process.env.NEXT_PUBLIC_HUME_SECRET;\n\n    if (!this.apiKey) {\n      console.warn(\n        'No Hume API key provided. Please set environment variables or provide a key.'\n      );\n    }\n\n    this.facialSocket = null;\n    this.prosodySocket = null;\n    this.onFacialUpdate = null;\n    this.onProsodyUpdate = null;\n    this.emotionCallback = null;\n    this.unsubscribeFacial = null;\n    this.unsubscribeProsody = null;\n  }\n\n  // Compatibility method for existing code\n  onEmotionDetected(callback) {\n    this.emotionCallback = callback;\n    this.connectFacial((data) => {\n      if (data.predictions && data.predictions.length > 0) {\n        const topEmotion = data.predictions[0].emotions.sort((a, b) => b.score - a.score)[0];\n        if (this.emotionCallback) {\n          this.emotionCallback(topEmotion.name || 'neutral');\n        }\n      }\n    });\n  }\n\n  // Connect to Hume for facial expressions\n  connectFacial(onFacialUpdate) {\n    this.onFacialUpdate = onFacialUpdate;\n    \n    // Clean up any existing subscription\n    if (this.unsubscribeFacial) {\n      this.unsubscribeFacial();\n      this.unsubscribeFacial = null;\n    }\n\n    const url = `wss://api.hume.ai/v0/stream/models?apiKey=${this.apiKey}`;\n    const connectionKey = `facial:${url}`;\n    \n    // Get or create WebSocket connection\n    this.facialSocket = webSocketManager.getConnection(url, 'facial');\n    \n    // Subscribe to WebSocket events\n    this.unsubscribeFacial = webSocketManager.subscribe(connectionKey, (event) => {\n      switch (event.type) {\n        case 'open':\n          console.log('Connected to Hume AI facial expressions WebSocket');\n          break;\n          \n        case 'message':\n          try {\n            const data = JSON.parse(event.data);\n            if (this.onFacialUpdate) {\n              this.onFacialUpdate(data);\n            }\n          } catch (error) {\n            console.error('Error processing facial expression data:', error);\n          }\n          break;\n          \n        case 'error':\n          console.error('Facial WebSocket error:', event.error);\n          break;\n          \n        case 'close':\n          console.log('Facial WebSocket connection closed:', event.reason || 'Unknown reason');\n          break;\n          \n        case 'reconnect_failed':\n          console.error('Facial WebSocket reconnection failed after', event.attempts, 'attempts');\n          break;\n      }\n    });\n\n    return this.facialSocket;\n  }\n\n  // Connect to Hume for voice (prosody)\n  connectProsody(onProsodyUpdate) {\n    this.onProsodyUpdate = onProsodyUpdate;\n    \n    // Clean up any existing subscription\n    if (this.unsubscribeProsody) {\n      this.unsubscribeProsody();\n      this.unsubscribeProsody = null;\n    }\n\n    const url = `wss://api.hume.ai/v0/stream/models?apiKey=${this.apiKey}`;\n    const connectionKey = `prosody:${url}`;\n    \n    // Get or create WebSocket connection\n    this.prosodySocket = webSocketManager.getConnection(url, 'prosody');\n    \n    // Subscribe to WebSocket events\n    this.unsubscribeProsody = webSocketManager.subscribe(connectionKey, (event) => {\n      switch (event.type) {\n        case 'open':\n          console.log('Connected to Hume AI prosody WebSocket');\n          break;\n          \n        case 'message':\n          try {\n            const data = JSON.parse(event.data);\n            if (this.onProsodyUpdate) {\n              this.onProsodyUpdate(data);\n            }\n          } catch (error) {\n            console.error('Error processing prosody data:', error);\n          }\n          break;\n          \n        case 'error':\n          console.error('Prosody WebSocket error:', event.error);\n          break;\n          \n        case 'close':\n          console.log('Prosody WebSocket connection closed:', event.reason || 'Unknown reason');\n          break;\n          \n        case 'reconnect_failed':\n          console.error('Prosody WebSocket reconnection failed after', event.attempts, 'attempts');\n          break;\n      }\n    });\n\n    return this.prosodySocket;\n  }\n  \n    // Disconnect all WebSocket connections\n    disconnect() {\n      // Unsubscribe from WebSocket events\n      if (this.unsubscribeFacial) {\n        this.unsubscribeFacial();\n        this.unsubscribeFacial = null;\n      }\n      if (this.unsubscribeProsody) {\n        this.unsubscribeProsody();\n        this.unsubscribeProsody = null;\n      }\n      \n      // Close WebSocket connections\n      if (this.facialSocket) {\n        webSocketManager.closeConnection(`facial:${this.facialSocket.url}`, 1000, 'User disconnected');\n        this.facialSocket = null;\n      }\n      if (this.prosodySocket) {\n        webSocketManager.closeConnection(`prosody:${this.prosodySocket.url}`, 1000, 'User disconnected');\n        this.prosodySocket = null;\n      }\n      \n      this.onFacialUpdate = null;\n      this.onProsodyUpdate = null;\n    }\n  \n    // Send captured image data for facial expression analysis\n    sendImageForAnalysis(imageData) {\n      if (!this.facialSocket || this.facialSocket.readyState !== WebSocket.OPEN) {\n        console.error('Facial WebSocket not connected');\n        return;\n      }\n  \n      // If the string is a data URL, strip off \"data:...base64,\"\n      if (typeof imageData === 'string') {\n        let base64String = imageData;\n        if (imageData.startsWith('data:')) {\n          base64String = imageData.split(',')[1];\n        }\n        // Add actual WebSocket message sending logic here\n      }\n    }\n}\n\nexport default HumeAIService;\n","import React, { useState, useEffect, useRef } from 'react';\r\nimport HumeAIService from '../services/HumeAIService';\r\nimport './EmotionAnalysis.css';\r\nimport {\r\n  LineChart, Line, XAxis, YAxis, Tooltip, CartesianGrid, Legend, ResponsiveContainer\r\n} from 'recharts';\r\n\r\n// Emotion labels and colors mapping - Removed surprise\r\nconst emotionConfig = [\r\n  { name: 'Joy', color: '#5cb85c' },\r\n  { name: 'Interest', color: '#5bc0de' },\r\n  { name: 'Concentration', color: '#428bca' },\r\n  { name: 'Boredom', color: '#777777' },\r\n  { name: 'Confusion', color: '#ff7f0e' },\r\n  { name: 'Doubt', color: '#d9534f' },\r\n  { name: 'Sadness', color: '#5253a3' },\r\n  { name: 'Disgust', color: '#a94442' },\r\n  { name: 'Anxiety', color: '#d62728' },\r\n];\r\n\r\n// Emoji mapping for emotions\r\nconst emotionEmojis = {\r\n  Joy: '😊',\r\n  Interest: '🙂',\r\n  Concentration: '😐',\r\n  Boredom: '😒',\r\n  Confusion: '😕',\r\n  Doubt: '🤔',\r\n  Sadness: '😢',\r\n  Disgust: '😖',\r\n  Anxiety: '😨',\r\n};\r\n\r\n// Keywords associated with emotions\r\nconst emotionKeywords = {\r\n  Joy: ['happy', 'laugh', 'amazing', 'love', 'great', 'awesome', 'excited', 'fun'],\r\n  Interest: ['curious', 'tell me more', 'interesting', 'fascinating', 'cool', 'neat'],\r\n  Concentration: ['focus', 'understand', 'thinking', 'consider', 'analyze'],\r\n  Boredom: ['boring', 'bored', 'dull', 'whatever', 'meh', 'tired', 'slow'],\r\n  Confusion: ['confused', 'what?', 'don\\'t understand', 'unclear', 'complicated'],\r\n  Doubt: ['maybe', 'not sure', 'doubt', 'skeptical', 'really?', 'hmm'],\r\n  Sadness: ['sad', 'upset', 'disappointed', 'unhappy', 'miss', 'sorry'],\r\n  Disgust: ['gross', 'disgusting', 'terrible', 'awful', 'hate', 'dislike'],\r\n  Anxiety: ['worried', 'nervous', 'anxious', 'afraid', 'scared', 'stress', 'fear']\r\n};\r\n\r\nconst EmotionAnalysis = ({ localStream, remoteStream, apiKey, roomId, userId, onEmotionDataUpdate }) => {\r\n  const [facialEmotions1, setFacialEmotions1] = useState({});\r\n  const [facialEmotions2, setFacialEmotions2] = useState({});\r\n  const [voiceEmotions1, setVoiceEmotions1] = useState({});\r\n  const [voiceEmotions2, setVoiceEmotions2] = useState({});\r\n\r\n  const [emotionHistory1, setEmotionHistory1] = useState([]);\r\n  const [emotionHistory2, setEmotionHistory2] = useState([]);\r\n\r\n  const [analysisType, setAnalysisType] = useState('facial'); // 'facial' or 'voice'\r\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\r\n  const [error, setError] = useState('');\r\n\r\n  // Track conversation topics and keywords\r\n  const [conversationKeywords, setConversationKeywords] = useState({});\r\n  const [detectedTopics, setDetectedTopics] = useState([]);\r\n\r\n  // Video refs\r\n  const localVideoRef = useRef(null);\r\n  const remoteVideoRef = useRef(null);\r\n\r\n  // Off-screen canvases for capturing frames\r\n  const localCanvasRef = useRef(null);\r\n  const remoteCanvasRef = useRef(null);\r\n\r\n  // Hume AI service instance\r\n  const humeServiceRef = useRef(null);\r\n\r\n  // Intervals and audio context\r\n  const captureInterval = useRef(null);\r\n  const audioProcessorRef = useRef({ local: null, remote: null });\r\n  const audioContextRef = useRef(null);\r\n\r\n  // Tracking which source last requested an analysis (so we map responses to local/remote)\r\n  const expectedResponseSourceRef = useRef(null);\r\n\r\n  // Debounce times for capturing\r\n  const captureDebounceRef = useRef({ local: 0, remote: 0 });\r\n\r\n  // Track if each video is loaded\r\n  const [localVideoReady, setLocalVideoReady] = useState(false);\r\n  const [remoteVideoReady, setRemoteVideoReady] = useState(false);\r\n\r\n  // Store emotion data for summary\r\n  const summaryDataRef = useRef({\r\n    user1: {\r\n      emotionTrends: [],\r\n      dominantEmotions: {},\r\n      keywords: {},\r\n    },\r\n    user2: {\r\n      emotionTrends: [],\r\n      dominantEmotions: {},\r\n      keywords: {},\r\n    },\r\n    startTime: Date.now(),\r\n    topics: []\r\n  });\r\n\r\n  // Initialize Hume AI service\r\n  useEffect(() => {\r\n    if (!apiKey) {\r\n      setError('Hume AI API key is missing');\r\n      return;\r\n    }\r\n    try {\r\n      // console.log('Initializing Hume AI service with key:', apiKey);\r\n      humeServiceRef.current = new HumeAIService(apiKey);\r\n\r\n      return () => {\r\n        stopAnalysis();\r\n      };\r\n    } catch (err) {\r\n      // console.error('Error initializing Hume service:', err);\r\n      setError(`Failed to initialize Hume AI service: ${err.message}`);\r\n    }\r\n  }, [apiKey]);\r\n\r\n  // Update video elements when streams change\r\n  useEffect(() => {\r\n    if (localStream && localVideoRef.current) {\r\n      localVideoRef.current.srcObject = localStream;\r\n    }\r\n    if (remoteStream && remoteVideoRef.current) {\r\n      remoteVideoRef.current.srcObject = remoteStream;\r\n    }\r\n  }, [localStream, remoteStream]);\r\n\r\n  // Start analysis once isAnalyzing === true\r\n  useEffect(() => {\r\n    if (!isAnalyzing || !humeServiceRef.current) {\r\n      return;\r\n    }\r\n    setError('');\r\n\r\n    // Start either facial or voice\r\n    if (analysisType === 'facial') {\r\n      setupFacialAnalysis();\r\n    } else if (analysisType === 'voice') {\r\n      setupVoiceAnalysis();\r\n    }\r\n  }, [isAnalyzing, analysisType]);\r\n\r\n  // Periodically update summary data\r\n  useEffect(() => {\r\n    if (!isAnalyzing) return;\r\n\r\n    const updateSummaryInterval = setInterval(() => {\r\n      // Update summary data\r\n      const currentTime = Date.now();\r\n      const durationMinutes = (currentTime - summaryDataRef.current.startTime) / 60000;\r\n      \r\n      // Get dominant emotions\r\n      const user1Emotions = getEmotions(1);\r\n      const user2Emotions = getEmotions(2);\r\n      \r\n      // Update emotion trends\r\n      summaryDataRef.current.user1.emotionTrends.push({\r\n        timestamp: currentTime,\r\n        emotions: { ...user1Emotions }\r\n      });\r\n      \r\n      summaryDataRef.current.user2.emotionTrends.push({\r\n        timestamp: currentTime,\r\n        emotions: { ...user2Emotions }\r\n      });\r\n      \r\n      // Calculate dominant emotions\r\n      const dominantEmotion1 = getDominantEmotion(user1Emotions);\r\n      const dominantEmotion2 = getDominantEmotion(user2Emotions);\r\n      \r\n      if (dominantEmotion1) {\r\n        summaryDataRef.current.user1.dominantEmotions[dominantEmotion1] = \r\n          (summaryDataRef.current.user1.dominantEmotions[dominantEmotion1] || 0) + 1;\r\n      }\r\n      \r\n      if (dominantEmotion2) {\r\n        summaryDataRef.current.user2.dominantEmotions[dominantEmotion2] = \r\n          (summaryDataRef.current.user2.dominantEmotions[dominantEmotion2] || 0) + 1;\r\n      }\r\n      \r\n      // Notify parent component about emotion data update\r\n      if (onEmotionDataUpdate) {\r\n        onEmotionDataUpdate({\r\n          roomId,\r\n          userId,\r\n          summaryData: summaryDataRef.current,\r\n          currentEmotions: {\r\n            user1: user1Emotions,\r\n            user2: user2Emotions\r\n          }\r\n        });\r\n      }\r\n    }, 10000); // Update every 10 seconds\r\n    \r\n    return () => {\r\n      clearInterval(updateSummaryInterval);\r\n    };\r\n  }, [isAnalyzing, roomId, userId, onEmotionDataUpdate]);\r\n\r\n  // Get dominant emotion from emotion object\r\n  const getDominantEmotion = (emotions) => {\r\n    if (!emotions || Object.keys(emotions).length === 0) return null;\r\n    \r\n    let dominant = null;\r\n    let highestScore = 0;\r\n    \r\n    Object.entries(emotions).forEach(([emotion, score]) => {\r\n      if (score > highestScore && score > 0.3) { // Only count if score is significant\r\n        highestScore = score;\r\n        dominant = emotion;\r\n      }\r\n    });\r\n    \r\n    return dominant;\r\n  };\r\n\r\n  // Start / Stop Analysis\r\n  const startAnalysis = () => {\r\n    if (!localStream || !remoteStream) {\r\n      setError('Video/Audio streams not available');\r\n      return;\r\n    }\r\n    setError('');\r\n    setIsAnalyzing(true);\r\n    \r\n    // Reset summary data\r\n    summaryDataRef.current = {\r\n      user1: {\r\n        emotionTrends: [],\r\n        dominantEmotions: {},\r\n        keywords: {},\r\n      },\r\n      user2: {\r\n        emotionTrends: [],\r\n        dominantEmotions: {},\r\n        keywords: {},\r\n      },\r\n      startTime: Date.now(),\r\n      topics: []\r\n    };\r\n  };\r\n\r\n  const stopAnalysis = () => {\r\n    // console.log('Stopping analysis');\r\n    if (captureInterval.current) {\r\n      clearInterval(captureInterval.current);\r\n      captureInterval.current = null;\r\n    }\r\n    if (audioProcessorRef.current) {\r\n      try {\r\n        if (audioProcessorRef.current.local) {\r\n          audioProcessorRef.current.local.disconnect();\r\n        }\r\n        if (audioProcessorRef.current.remote) {\r\n          audioProcessorRef.current.remote.disconnect();\r\n        }\r\n      } catch (e) {\r\n        // console.log('Error disconnecting audio processor:', e);\r\n      }\r\n      audioProcessorRef.current = { local: null, remote: null };\r\n    }\r\n    if (audioContextRef.current && audioContextRef.current.state !== 'closed') {\r\n      try {\r\n        audioContextRef.current.close();\r\n      } catch (e) {\r\n        // console.log('Error closing audio context:', e);\r\n      }\r\n      audioContextRef.current = null;\r\n    }\r\n\r\n    if (humeServiceRef.current) {\r\n      humeServiceRef.current.disconnect();\r\n    }\r\n    setIsAnalyzing(false);\r\n  };\r\n\r\n  // Facial Analysis\r\n  const setupFacialAnalysis = () => {\r\n    humeServiceRef.current.connectFacial((data) => {\r\n      // console.log('Facial data received:', data);\r\n      if (data.error) {\r\n        // console.error('Error from Hume API:', data.error);\r\n        return;\r\n      }\r\n      const predictions = data.face?.predictions || [];\r\n      if (!predictions.length) {\r\n        // console.log('No valid facial predictions in data');\r\n        return;\r\n      }\r\n\r\n      // Determine whether this result is for local or remote\r\n      const source = expectedResponseSourceRef.current;\r\n      if (source) {\r\n        if (source === 'local' && predictions[0]) {\r\n          updateFacialEmotionsLocal(predictions[0].emotions);\r\n        } else if (source === 'remote' && predictions[0]) {\r\n          updateFacialEmotionsRemote(predictions[0].emotions);\r\n        }\r\n      } else {\r\n        // Fallback if we didn't set the source\r\n        if (predictions.length === 1) {\r\n          updateFacialEmotionsLocal(predictions[0].emotions);\r\n        } else if (predictions.length > 1) {\r\n          updateFacialEmotionsLocal(predictions[0].emotions);\r\n          updateFacialEmotionsRemote(predictions[1].emotions);\r\n        }\r\n      }\r\n      // Reset expected source\r\n      expectedResponseSourceRef.current = null;\r\n    });\r\n\r\n    // Delay a bit to ensure WebSocket is connected\r\n    setTimeout(() => {\r\n      // Only set up video capture if both videos are loaded\r\n      if (localVideoReady && remoteVideoReady) {\r\n        setupVideoCaptureForAnalysis();\r\n      } else {\r\n        // console.log('Videos not fully loaded yet; waiting for metadata...');\r\n      }\r\n    }, 1000);\r\n  };\r\n\r\n  const updateFacialEmotionsLocal = (emotions) => {\r\n    if (!Array.isArray(emotions)) return;\r\n    const emotionMap = {};\r\n    emotions.forEach((emo) => {\r\n      // Skip 'Surprise' emotion\r\n      if (emo.name !== 'Surprise') {\r\n        emotionMap[emo.name] = emo.score;\r\n      }\r\n    });\r\n    const timestamp = Date.now();\r\n    setFacialEmotions1(emotionMap);\r\n    setEmotionHistory1((prev) => {\r\n      const newPoint = { timestamp, emotions: emotionMap };\r\n      return [...prev, newPoint].filter((p) => timestamp - p.timestamp < 30000);\r\n    });\r\n  };\r\n\r\n  const updateFacialEmotionsRemote = (emotions) => {\r\n    if (!Array.isArray(emotions)) return;\r\n    const emotionMap = {};\r\n    emotions.forEach((emo) => {\r\n      // Skip 'Surprise' emotion\r\n      if (emo.name !== 'Surprise') {\r\n        emotionMap[emo.name] = emo.score;\r\n      }\r\n    });\r\n    const timestamp = Date.now();\r\n    setFacialEmotions2(emotionMap);\r\n    setEmotionHistory2((prev) => {\r\n      const newPoint = { timestamp, emotions: emotionMap };\r\n      return [...prev, newPoint].filter((p) => timestamp - p.timestamp < 30000);\r\n    });\r\n  };\r\n\r\n  // Voice (Prosody) Analysis\r\n  const setupVoiceAnalysis = () => {\r\n    humeServiceRef.current.connectProsody((data) => {\r\n      // console.log('Prosody data received:', data);\r\n      if (data.error) {\r\n        // console.error('Error from Hume API:', data.error);\r\n        return;\r\n      }\r\n      if (!data.prosody?.predictions?.[0]) {\r\n        // console.log('Invalid prosody data:', data);\r\n        return;\r\n      }\r\n      const source = expectedResponseSourceRef.current;\r\n      const emotions = data.prosody.predictions[0].emotions || [];\r\n      const emotionMap = {};\r\n      emotions.forEach((e) => {\r\n        // Skip 'Surprise' emotion\r\n        if (e.name !== 'Surprise') {\r\n          emotionMap[e.name] = e.score;\r\n        }\r\n      });\r\n\r\n      if (source === 'local') {\r\n        setVoiceEmotions1(emotionMap);\r\n        const timestamp = Date.now();\r\n        const newPoint = { timestamp, emotions: emotionMap };\r\n        setEmotionHistory1((prev) => {\r\n          return [...prev, newPoint].filter((p) => timestamp - p.timestamp < 30000);\r\n        });\r\n      } else if (source === 'remote') {\r\n        setVoiceEmotions2(emotionMap);\r\n        const timestamp = Date.now();\r\n        const newPoint = { timestamp, emotions: emotionMap };\r\n        setEmotionHistory2((prev) => {\r\n          return [...prev, newPoint].filter((p) => timestamp - p.timestamp < 30000);\r\n        });\r\n      }\r\n      expectedResponseSourceRef.current = null;\r\n    });\r\n\r\n    // Delay to ensure WebSocket is connected\r\n    setTimeout(() => {\r\n      setupAudioCaptureForAnalysis();\r\n    }, 1000);\r\n  };\r\n\r\n  // Setup video capture\r\n  const setupVideoCaptureForAnalysis = () => {\r\n    if (!localVideoRef.current || !remoteVideoRef.current) {\r\n      // console.warn('Video refs not available');\r\n      return;\r\n    }\r\n    if (!localCanvasRef.current) {\r\n      localCanvasRef.current = document.createElement('canvas');\r\n    }\r\n    if (!remoteCanvasRef.current) {\r\n      remoteCanvasRef.current = document.createElement('canvas');\r\n    }\r\n\r\n    // console.log('Setting up video capture intervals...');\r\n    // Clear any existing interval just in case\r\n    if (captureInterval.current) {\r\n      clearInterval(captureInterval.current);\r\n    }\r\n\r\n    // Capture frames every 3 seconds\r\n    captureInterval.current = setInterval(() => {\r\n      // Local first\r\n      captureVideoFrame(localVideoRef.current, localCanvasRef.current, 'local');\r\n      // Then remote 1.5s later\r\n      setTimeout(() => {\r\n        captureVideoFrame(remoteVideoRef.current, remoteCanvasRef.current, 'remote');\r\n      }, 1500);\r\n    }, 3000);\r\n\r\n    // (Optional) capture an immediate frame, if you want to try right away\r\n    captureVideoFrame(localVideoRef.current, localCanvasRef.current, 'local');\r\n    setTimeout(() => {\r\n      captureVideoFrame(remoteVideoRef.current, remoteCanvasRef.current, 'remote');\r\n    }, 500);\r\n  };\r\n\r\n  // Capture a video frame & send\r\n  const captureVideoFrame = (videoElement, canvasElement, source) => {\r\n    if (!videoElement || !canvasElement || !humeServiceRef.current || !isAnalyzing) {\r\n      // console.log(`Skipping frame capture for ${source} - not ready or not analyzing`);\r\n      return;\r\n    }\r\n\r\n    // Debounce so we don't spam\r\n    const now = Date.now();\r\n    if (now - captureDebounceRef.current[source] < 2000) {\r\n      // console.log(`Skipping ${source} capture - too soon`);\r\n      return;\r\n    }\r\n    captureDebounceRef.current[source] = now;\r\n\r\n    // If video is paused or ended, try to play it\r\n    if (videoElement.paused || videoElement.ended) {\r\n      try {\r\n        videoElement.play().catch((err) => {\r\n          // console.log(`Error playing ${source} video:`, err);\r\n        });\r\n      } catch (err) {\r\n        // console.log(`Unexpected error playing ${source} video:`, err);\r\n      }\r\n    }\r\n\r\n    // Delay 200ms to let video \"play\" if it was paused\r\n    setTimeout(() => {\r\n      if (videoElement.readyState !== 4 || videoElement.paused || videoElement.ended) {\r\n        // console.log(\r\n        //   `Video not ready for ${source}:`,\r\n        //   videoElement.readyState,\r\n        //   videoElement.paused,\r\n        //   videoElement.ended\r\n        // );\r\n        return;\r\n      }\r\n      const width = videoElement.videoWidth;\r\n      const height = videoElement.videoHeight;\r\n      if (!width || !height) {\r\n        // console.log(`Invalid video dimensions for ${source}: ${width}x${height}`);\r\n        return;\r\n      }\r\n\r\n      canvasElement.width = width;\r\n      canvasElement.height = height;\r\n      const ctx = canvasElement.getContext('2d');\r\n      try {\r\n        ctx.drawImage(videoElement, 0, 0, width, height);\r\n        const imageData = canvasElement.toDataURL('image/jpeg', 0.8);\r\n\r\n        expectedResponseSourceRef.current = source;\r\n        // console.log(`Sending image for ${source} analysis`);\r\n\r\n        humeServiceRef.current.sendImageForAnalysis(imageData);\r\n      } catch (error) {\r\n        // console.error(`Frame capture error for ${source}:`, error);\r\n      }\r\n    }, 200);\r\n  };\r\n\r\n  // Setup audio capture\r\n  const setupAudioCaptureForAnalysis = () => {\r\n    if (!localStream || !remoteStream || !humeServiceRef.current) {\r\n      // console.warn('Audio streams or Hume service missing');\r\n      return;\r\n    }\r\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n    audioContextRef.current = audioContext;\r\n\r\n    const localTrack = localStream.getAudioTracks()[0];\r\n    const remoteTrack = remoteStream.getAudioTracks()[0];\r\n    if (!localTrack || !remoteTrack) {\r\n      // console.warn('Missing local/remote audio track');\r\n      return;\r\n    }\r\n\r\n    const localSource = audioContext.createMediaStreamSource(new MediaStream([localTrack]));\r\n    const remoteSource = audioContext.createMediaStreamSource(new MediaStream([remoteTrack]));\r\n\r\n    const processorLocal = audioContext.createScriptProcessor(4096, 1, 1);\r\n    const processorRemote = audioContext.createScriptProcessor(4096, 1, 1);\r\n\r\n    const sampleRate = audioContext.sampleRate;\r\n    const maxBufferSize = Math.floor(sampleRate * 4.5);\r\n    let localBuffer = [];\r\n    let remoteBuffer = [];\r\n\r\n    let lastLocalAnalysisTime = 0;\r\n    let lastRemoteAnalysisTime = 0;\r\n    const minAnalysisInterval = 5000; // 5s\r\n\r\n    processorLocal.onaudioprocess = (e) => {\r\n      const channelData = e.inputBuffer.getChannelData(0);\r\n      localBuffer = localBuffer.concat(Array.from(channelData));\r\n\r\n      const now = Date.now();\r\n      if (localBuffer.length >= maxBufferSize && now - lastLocalAnalysisTime >= minAnalysisInterval) {\r\n        const trimmed = localBuffer.slice(0, maxBufferSize);\r\n        expectedResponseSourceRef.current = 'local';\r\n        humeServiceRef.current.sendAudioForAnalysis(new Float32Array(trimmed));\r\n        localBuffer = localBuffer.slice(maxBufferSize);\r\n        lastLocalAnalysisTime = now;\r\n      }\r\n    };\r\n\r\n    processorRemote.onaudioprocess = (e) => {\r\n      const channelData = e.inputBuffer.getChannelData(0);\r\n      remoteBuffer = remoteBuffer.concat(Array.from(channelData));\r\n\r\n      const now = Date.now();\r\n      if (remoteBuffer.length >= maxBufferSize && now - lastRemoteAnalysisTime >= minAnalysisInterval) {\r\n        const trimmed = remoteBuffer.slice(0, maxBufferSize);\r\n        expectedResponseSourceRef.current = 'remote';\r\n        humeServiceRef.current.sendAudioForAnalysis(new Float32Array(trimmed));\r\n        remoteBuffer = remoteBuffer.slice(maxBufferSize);\r\n        lastRemoteAnalysisTime = now;\r\n      }\r\n    };\r\n\r\n    localSource.connect(processorLocal);\r\n    processorLocal.connect(audioContext.destination);\r\n\r\n    remoteSource.connect(processorRemote);\r\n    processorRemote.connect(audioContext.destination);\r\n\r\n    audioProcessorRef.current = { local: processorLocal, remote: processorRemote };\r\n  };\r\n\r\n  // Helper to retrieve current emotions\r\n  const getEmotions = (participantNumber) => {\r\n    if (analysisType === 'facial') {\r\n      return participantNumber === 1 ? facialEmotions1 : facialEmotions2;\r\n    } else {\r\n      return participantNumber === 1 ? voiceEmotions1 : voiceEmotions2;\r\n    }\r\n  };\r\n\r\n  // Helper to retrieve emotion history\r\n  const getHistory = (participantNumber) => {\r\n    return participantNumber === 1 ? emotionHistory1 : emotionHistory2;\r\n  };\r\n\r\n  // Prepare chart data\r\n  const prepareChartData = (participantId) => {\r\n    const history = getHistory(participantId);\r\n    if (history.length < 2) {\r\n      return [];\r\n    }\r\n    // We'll pick top 3 emotions to plot\r\n    const defaultTop3 = ['Joy', 'Interest', 'Concentration'];\r\n    let topEmotions = [...defaultTop3];\r\n\r\n    // Find the real top 3 based on average\r\n    if (history.length > 0) {\r\n      const emotionScores = {};\r\n      emotionConfig.forEach((emotion) => {\r\n        const scores = history\r\n          .map((point) => point.emotions[emotion.name] || 0)\r\n          .filter((v) => v > 0);\r\n        if (scores.length > 0) {\r\n          emotionScores[emotion.name] = scores.reduce((sum, s) => sum + s, 0) / scores.length;\r\n        } else {\r\n          emotionScores[emotion.name] = 0;\r\n        }\r\n      });\r\n      topEmotions = Object.keys(emotionScores)\r\n        .sort((a, b) => emotionScores[b] - emotionScores[a])\r\n        .slice(0, 3);\r\n    }\r\n\r\n    return history.map((point) => {\r\n      const result = {\r\n        timestamp: point.timestamp,\r\n        formattedTime: new Date(point.timestamp).toLocaleTimeString([], {\r\n          hour: '2-digit',\r\n          minute: '2-digit',\r\n          second: '2-digit',\r\n        }),\r\n      };\r\n      topEmotions.forEach((emotion) => {\r\n        result[emotion] = point.emotions[emotion] ? Math.round(point.emotions[emotion] * 100) : 0;\r\n      });\r\n      return result;\r\n    });\r\n  };\r\n\r\n  // Render emotion bars\r\n  const renderEmotionBars = (participantId) => {\r\n    const emotions = getEmotions(participantId);\r\n    if (!emotions || Object.keys(emotions).length === 0) {\r\n      return (\r\n        <div className=\"emotion-bars empty\">\r\n          <p>\r\n            No emotion data yet.{' '}\r\n            {isAnalyzing ? 'Analyzing...' : 'Start analysis to see results.'}\r\n          </p>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <div className=\"emotion-bars\">\r\n        {emotionConfig.map((emotion) => {\r\n          const value = emotions[emotion.name] || 0;\r\n          return (\r\n            <div key={emotion.name} className=\"emotion-bar-container\">\r\n              <div className=\"emotion-label\">\r\n                <span className=\"emotion-emoji\">{emotionEmojis[emotion.name]}</span>\r\n                <span className=\"emotion-name\">{emotion.name}</span>\r\n              </div>\r\n              <div className=\"emotion-bar-background\">\r\n                <div\r\n                  className=\"emotion-bar\"\r\n                  style={{\r\n                    width: `${(value * 100).toFixed(1)}%`,\r\n                    backgroundColor: emotion.color,\r\n                  }}\r\n                />\r\n              </div>\r\n              <div className=\"emotion-value\">{(value * 100).toFixed(1)}%</div>\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // Render emotion trend\r\n  const renderEmotionTrend = (participantId) => {\r\n    const history = getHistory(participantId);\r\n    if (history.length < 2) {\r\n      return (\r\n        <div className=\"emotion-trend empty\">\r\n          <p>\r\n            Not enough data for trend visualization.\r\n            {!isAnalyzing ? ' Start analysis to collect data.' : ' Collecting data...'}\r\n          </p>\r\n        </div>\r\n      );\r\n    }\r\n    const chartData = prepareChartData(participantId);\r\n    if (!chartData.length) {\r\n      return null;\r\n    }\r\n    // Get top emotion keys from the first data row\r\n    const topEmotions = Object.keys(chartData[0]).filter(\r\n      (k) => k !== 'timestamp' && k !== 'formattedTime'\r\n    );\r\n\r\n    return (\r\n      <div className=\"emotion-trend\">\r\n        <h4>Emotion Trend Over Time</h4>\r\n        <ResponsiveContainer width=\"100%\" height={200}>\r\n          <LineChart data={chartData} margin={{ top: 5, right: 20, bottom: 20, left: 0 }}>\r\n            <CartesianGrid strokeDasharray=\"3 3\" stroke=\"#eee\" />\r\n            <XAxis\r\n              dataKey=\"formattedTime\"\r\n              tick={{ fontSize: 12 }}\r\n              padding={{ left: 10, right: 10 }}\r\n            />\r\n            <YAxis\r\n              domain={[0, 100]}\r\n              label={{\r\n                value: 'Emotion Intensity (%)',\r\n                angle: -90,\r\n                position: 'insideLeft',\r\n                style: { fontSize: 12 },\r\n              }}\r\n              tick={{ fontSize: 12 }}\r\n            />\r\n            <Tooltip\r\n              formatter={(value) => [`${value}%`, null]}\r\n              labelFormatter={(label) => `Time: ${label}`}\r\n              contentStyle={{\r\n                backgroundColor: 'rgba(255, 255, 255, 0.9)',\r\n                border: '1px solid #ddd',\r\n                borderRadius: '4px',\r\n                padding: '10px',\r\n              }}\r\n            />\r\n            <Legend\r\n              verticalAlign=\"top\"\r\n              height={36}\r\n              iconType=\"circle\"\r\n              iconSize={8}\r\n              wrapperStyle={{ fontSize: 12 }}\r\n            />\r\n\r\n            {topEmotions.map((emotion) => {\r\n              const config = emotionConfig.find((e) => e.name === emotion);\r\n              const color = config ? config.color : '#999';\r\n              return (\r\n                <Line\r\n                  key={emotion}\r\n                  type=\"monotone\"\r\n                  dataKey={emotion}\r\n                  stroke={color}\r\n                  strokeWidth={2}\r\n                  activeDot={{ r: 6 }}\r\n                  dot={{ r: 4 }}\r\n                  name={`${emotion} ${emotionEmojis[emotion] || ''}`}\r\n                />\r\n              );\r\n            })}\r\n          </LineChart>\r\n        </ResponsiveContainer>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // Export summary data\r\n  const getSummaryData = () => {\r\n    return summaryDataRef.current;\r\n  };\r\n\r\n  // Render\r\n  return (\r\n    <div className=\"emotion-analysis-container\">\r\n      {/* Controls */}\r\n      <div className=\"analysis-controls\">\r\n        <div className=\"analysis-type-selector\">\r\n          <label>\r\n            <input\r\n              type=\"radio\"\r\n              name=\"analysisType\"\r\n              value=\"facial\"\r\n              checked={analysisType === 'facial'}\r\n              onChange={() => setAnalysisType('facial')}\r\n              disabled={isAnalyzing}\r\n            />\r\n            Facial Expression Analysis\r\n          </label>\r\n          <label>\r\n            <input\r\n              type=\"radio\"\r\n              name=\"analysisType\"\r\n              value=\"voice\"\r\n              checked={analysisType === 'voice'}\r\n              onChange={() => setAnalysisType('voice')}\r\n              disabled={isAnalyzing}\r\n            />\r\n            Voice Expression Analysis\r\n          </label>\r\n        </div>\r\n\r\n        <div className=\"analysis-action-buttons\">\r\n          {!isAnalyzing ? (\r\n            <button\r\n              className=\"analysis-button start-button\"\r\n              onClick={startAnalysis}\r\n              disabled={!humeServiceRef.current || !localStream || !remoteStream}\r\n            >\r\n              Start {analysisType.charAt(0).toUpperCase() + analysisType.slice(1)} Analysis\r\n            </button>\r\n          ) : (\r\n            <button className=\"analysis-button stop-button\" onClick={stopAnalysis}>\r\n              Stop Analysis\r\n            </button>\r\n          )}\r\n        </div>\r\n      </div>\r\n\r\n      {error && <div className=\"analysis-error\">{error}</div>}\r\n\r\n      {/* Hidden video elements */}\r\n      <div style={{ display: 'none' }}>\r\n        <video\r\n          ref={localVideoRef}\r\n          autoPlay\r\n          muted\r\n          playsInline\r\n          onLoadedMetadata={() => {\r\n            // console.log('Local video metadata loaded');\r\n            setLocalVideoReady(true);\r\n          }}\r\n        />\r\n        <video\r\n          ref={remoteVideoRef}\r\n          autoPlay\r\n          playsInline\r\n          onLoadedMetadata={() => {\r\n            // console.log('Remote video metadata loaded');\r\n            setRemoteVideoReady(true);\r\n          }}\r\n        />\r\n      </div>\r\n\r\n      {/* Participant 1 = You */}\r\n      <div className=\"participant-emotions\">\r\n        <h3>You</h3>\r\n        {renderEmotionBars(1)}\r\n        {renderEmotionTrend(1)}\r\n      </div>\r\n\r\n      {/* Participant 2 = Remote */}\r\n      <div className=\"participant-emotions\">\r\n        <h3>Remote User</h3>\r\n        {renderEmotionBars(2)}\r\n        {renderEmotionTrend(2)}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default EmotionAnalysis;"],"names":["constructor","apiKey","arguments","length","undefined","this","process","secret","REACT_APP_HUME_SECRET","NEXT_PUBLIC_HUME_SECRET","console","warn","facialSocket","prosodySocket","onFacialUpdate","onProsodyUpdate","emotionCallback","unsubscribeFacial","unsubscribeProsody","onEmotionDetected","callback","connectFacial","data","predictions","topEmotion","emotions","sort","a","b","score","name","url","concat","connectionKey","webSocketManager","getConnection","subscribe","event","type","log","JSON","parse","error","reason","attempts","connectProsody","disconnect","closeConnection","sendImageForAnalysis","imageData","readyState","WebSocket","OPEN","base64String","startsWith","split","emotionConfig","color","emotionEmojis","Joy","Interest","Concentration","Boredom","Confusion","Doubt","Sadness","Disgust","Anxiety","_ref","localStream","remoteStream","roomId","userId","onEmotionDataUpdate","facialEmotions1","setFacialEmotions1","useState","facialEmotions2","setFacialEmotions2","voiceEmotions1","setVoiceEmotions1","voiceEmotions2","setVoiceEmotions2","emotionHistory1","setEmotionHistory1","emotionHistory2","setEmotionHistory2","analysisType","setAnalysisType","isAnalyzing","setIsAnalyzing","setError","conversationKeywords","setConversationKeywords","detectedTopics","setDetectedTopics","localVideoRef","useRef","remoteVideoRef","localCanvasRef","remoteCanvasRef","humeServiceRef","captureInterval","audioProcessorRef","local","remote","audioContextRef","expectedResponseSourceRef","captureDebounceRef","localVideoReady","setLocalVideoReady","remoteVideoReady","setRemoteVideoReady","summaryDataRef","user1","emotionTrends","dominantEmotions","keywords","user2","startTime","Date","now","topics","useEffect","current","HumeAIService","stopAnalysis","err","message","srcObject","setupFacialAnalysis","setupVoiceAnalysis","updateSummaryInterval","setInterval","currentTime","user1Emotions","getEmotions","user2Emotions","push","timestamp","_objectSpread","dominantEmotion1","getDominantEmotion","dominantEmotion2","summaryData","currentEmotions","clearInterval","Object","keys","dominant","highestScore","entries","forEach","_ref2","emotion","e","state","close","_data$face","face","source","updateFacialEmotionsLocal","updateFacialEmotionsRemote","setTimeout","setupVideoCaptureForAnalysis","Array","isArray","emotionMap","emo","prev","filter","p","_data$prosody","_data$prosody$predict","prosody","newPoint","setupAudioCaptureForAnalysis","document","createElement","captureVideoFrame","videoElement","canvasElement","paused","ended","play","catch","width","videoWidth","height","videoHeight","ctx","getContext","drawImage","toDataURL","audioContext","window","AudioContext","webkitAudioContext","localTrack","getAudioTracks","remoteTrack","localSource","createMediaStreamSource","MediaStream","remoteSource","processorLocal","createScriptProcessor","processorRemote","sampleRate","maxBufferSize","Math","floor","localBuffer","remoteBuffer","lastLocalAnalysisTime","lastRemoteAnalysisTime","onaudioprocess","channelData","inputBuffer","getChannelData","from","trimmed","slice","sendAudioForAnalysis","Float32Array","connect","destination","participantNumber","getHistory","renderEmotionBars","participantId","_jsx","className","children","map","value","_jsxs","style","toFixed","backgroundColor","renderEmotionTrend","chartData","history","topEmotions","emotionScores","scores","point","v","reduce","sum","s","result","formattedTime","toLocaleTimeString","hour","minute","second","round","prepareChartData","k","ResponsiveContainer","LineChart","margin","top","right","bottom","left","CartesianGrid","strokeDasharray","stroke","XAxis","dataKey","tick","fontSize","padding","YAxis","domain","label","angle","position","Tooltip","formatter","labelFormatter","contentStyle","border","borderRadius","Legend","verticalAlign","iconType","iconSize","wrapperStyle","config","find","Line","strokeWidth","activeDot","r","dot","checked","onChange","disabled","onClick","startAnalysis","charAt","toUpperCase","display","ref","autoPlay","muted","playsInline","onLoadedMetadata"],"sourceRoot":""}