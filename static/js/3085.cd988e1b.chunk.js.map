{"version":3,"file":"static/js/3085.cd988e1b.chunk.js","mappings":"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","sources":["components/PresenceAvatar.archived.tsx"],"sourcesContent":["// Enhanced Avatar with Physical Presence\n// Creates realistic presence through subtle movements and reactions\n\nimport React, { useRef, useMemo, useEffect, useCallback, useState } from 'react';\nimport { useGLTF, useAnimations } from '@react-three/drei';\nimport { useFrame, GroupProps } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { SkeletonUtils } from 'three-stdlib';\nimport { TrackingData } from '../types/tracking';\n\n// Define types locally since types/core might not exist\ninterface EmotionalState {\n  type: 'happy' | 'flirty' | 'confident' | 'nervous' | 'excited' | 'interested' | 'neutral';\n}\n\ninterface PartnerState {\n  engagement: number;\n  responseReady: boolean;\n  isSpeaking?: boolean;\n}\n\ninterface PresenceAvatarProps {\n  avatarUrl?: string;\n  idleAnimationUrl?: string;\n  talkAnimationUrl?: string;\n  position?: [number, number, number];\n  scale?: number;\n  emotionalState?: string;\n  partnerState?: PartnerState;\n  trackingData?: TrackingData;\n  debugMode?: boolean;\n  isUser?: boolean;\n  cameraPosition?: [number, number, number];\n  cameraTarget?: [number, number, number];\n  disableMorphTargets?: boolean; // Add a new prop to disable morph targets\n}\n\n// Preload common avatars\nuseGLTF.preload('/avatars/coach_grace.glb');\nuseGLTF.preload('/avatars/AngelChick.glb');\nuseGLTF.preload('/avatars/coach_posie.glb');\nuseGLTF.preload('/avatars/coach_rizzo.glb');\n\nconst PresenceAvatar: React.FC<PresenceAvatarProps> = ({\n  avatarUrl = '/avatars/AngelChick.glb',\n  idleAnimationUrl = '/animations/M_Standing_Idle_001.glb',\n  talkAnimationUrl = '/animations/M_Talking_Variations_001.glb',\n  position = [0, 0, 0],\n  scale = 1,\n  emotionalState = 'neutral',\n  partnerState,\n  trackingData,\n  debugMode = false,\n  isUser = false,\n  cameraPosition,\n  cameraTarget,\n  disableMorphTargets = false, // Initialize the new prop with a default value\n}) => {\n  console.log('[PresenceAvatar] Rendering, trackingData:', !!trackingData);\n  \n  const group = useRef<THREE.Group>(null);\n  const currentAction = useRef<THREE.AnimationAction | null>(null);\n  const hasLoggedMorphTargets = useRef(false);\n  const hasAppliedFix = useRef(false);\n  const lastSpeakingState = useRef(false);\n  const headBone = useRef<THREE.Bone | null>(null);\n  const neckBone = useRef<THREE.Bone | null>(null);\n  const spineBone = useRef<THREE.Bone | null>(null);\n  const smoothedRotation = useRef({ x: 0, y: 0, z: 0 });\n  const smoothedPosition = useRef({ x: 0, y: 0, z: 0 });\n  const baseHeadPosition = useRef({ x: 0, y: 0, z: 0 });\n  const defaultHeadRotation = useRef({ x: 0, y: 0, z: 0 });\n  const lastLogTime = useRef<number>(0);\n  const frameCount = useRef(0);\n  const lastTrackingState = useRef(false);\n\n  // Load avatar model - this must be called at the top level\n  const { scene } = useGLTF(avatarUrl);\n  \n  // Add loading state\n  const [isLoading, setIsLoading] = useState(true);\n  \n  // Clone the scene to avoid conflicts\n  const clonedScene = useMemo(() => {\n    console.log('[PresenceAvatar] Cloning scene for:', avatarUrl);\n    if (!scene) {\n      console.error('[PresenceAvatar] No scene loaded yet');\n      return null;\n    }\n    \n    try {\n      const cloned = SkeletonUtils.clone(scene);\n      console.log('[PresenceAvatar] Avatar cloned successfully:', {\n        originalChildren: scene.children.length,\n        clonedChildren: cloned.children.length\n      });\n      \n      // Disable frustum culling on all meshes to prevent them from being culled\n      cloned.traverse((child: THREE.Object3D) => {\n        if ((child as any).isMesh || (child as any).isSkinnedMesh) {\n          const mesh = child as THREE.Mesh | THREE.SkinnedMesh;\n          mesh.frustumCulled = false;\n          \n          // Ensure materials are visible\n          if (mesh.material) {\n            if (Array.isArray(mesh.material)) {\n              mesh.material.forEach((mat: any) => {\n                mat.visible = true;\n                mat.opacity = mat.opacity || 1;\n                mat.transparent = false;\n              });\n            } else {\n              (mesh.material as any).visible = true;\n              (mesh.material as any).opacity = (mesh.material as any).opacity || 1;\n              (mesh.material as any).transparent = false;\n            }\n          }\n          \n          console.log('[PresenceAvatar] Mesh setup:', {\n            name: child.name,\n            visible: mesh.visible,\n            frustumCulled: mesh.frustumCulled,\n            materialVisible: mesh.material ? \n              (Array.isArray(mesh.material) ? mesh.material[0].visible : (mesh.material as any).visible) : null\n          });\n        }\n      });\n      \n      // Ensure the cloned scene is at proper scale and position\n      cloned.position.set(0, 0, 0);\n      cloned.scale.set(1, 1, 1);\n      cloned.visible = true;\n      console.log('[PresenceAvatar] Reset cloned scene position, scale, and visibility');\n      \n      return cloned;\n    } catch (error) {\n      console.error('[PresenceAvatar] Error cloning scene:', error);\n      return scene; // Fallback to original scene\n    }\n  }, [scene, avatarUrl]);\n  \n  // Update loading state when scene is available\n  useEffect(() => {\n    if (clonedScene) {\n      setIsLoading(false);\n    }\n  }, [clonedScene]);\n  \n  console.log('[PresenceAvatar] Cloned scene:', !!clonedScene);\n\n  // Find head and neck bones after model loads\n  const findBones = useCallback((scene: THREE.Object3D) => {\n    const skinnedMesh = scene.getObjectByProperty('type', 'SkinnedMesh') as THREE.SkinnedMesh | undefined;\n    if (skinnedMesh?.skeleton) {\n      const bones = skinnedMesh.skeleton.bones;\n      \n      // Find head bone\n      const head = bones.find((bone: THREE.Bone) => \n        bone.name.toLowerCase().includes('head') && \n        !bone.name.toLowerCase().includes('headtop')\n      );\n      \n      // Find neck bone\n      const neck = bones.find((bone: THREE.Bone) => \n        bone.name.toLowerCase().includes('neck')\n      );\n      \n      // Find spine bones\n      const spine = bones.find((bone: THREE.Bone) => \n        bone.name.toLowerCase().includes('spine') || \n        bone.name.toLowerCase().includes('chest')\n      );\n      \n      if (head) {\n        headBone.current = head;\n        // Store the default head rotation and position\n        // Add a small forward tilt adjustment to fix the default pose\n        defaultHeadRotation.current = {\n          x: head.rotation.x - 0.1, // Slight forward tilt (negative = forward)\n          y: head.rotation.y,\n          z: head.rotation.z\n        };\n        baseHeadPosition.current = {\n          x: head.position.x,\n          y: head.position.y,\n          z: head.position.z\n        };\n        console.log('[PresenceAvatar] Found head bone:', head.name, 'default rotation:', defaultHeadRotation.current);\n      }\n      \n      if (neck) {\n        neckBone.current = neck;\n        console.log('[PresenceAvatar] Found neck bone:', neck.name);\n      }\n      \n      if (spine) {\n        spineBone.current = spine;\n        console.log('[PresenceAvatar] Found spine bone:', spine.name);\n      }\n    }\n  }, []);\n  \n  useEffect(() => {\n    if (!clonedScene) return;\n    \n    findBones(clonedScene as THREE.Object3D);\n  }, [clonedScene, findBones]);\n  \n  // Find and fix T-pose for RPM avatars\n  useEffect(() => {\n    if (!clonedScene || hasAppliedFix.current) return;\n    \n    console.log('🔧 Applying T-pose fix for PresenceAvatar');\n    console.log('Avatar URL:', avatarUrl);\n    \n    // Debug bone structure\n    let foundBones = false;\n    let boneNames: string[] = [];\n    \n    clonedScene.traverse((node: THREE.Object3D) => {\n      if ((node as THREE.SkinnedMesh).isSkinnedMesh) {\n        const skinnedMesh = node as THREE.SkinnedMesh;\n        if (skinnedMesh.skeleton) {\n          foundBones = true;\n          console.log('Found skeleton with', skinnedMesh.skeleton.bones.length, 'bones');\n          \n          // Log all bone names\n          skinnedMesh.skeleton.bones.forEach((bone, index) => {\n            boneNames.push(bone.name);\n            if (index < 20) { // Log first 20 bones\n              console.log(`Bone ${index}: ${bone.name}`);\n            }\n          });\n          \n          // Check for RPM-specific bone names\n          const isRPM = boneNames.some(name => \n            name.includes('mixamorig') || \n            name.includes('Hips') || \n            name.includes('Spine')\n          );\n          \n          console.log('Is RPM avatar?', isRPM);\n          console.log('Bone names sample:', boneNames.slice(0, 10));\n          \n          // Fix T-pose for different avatar types\n          skinnedMesh.skeleton.bones.forEach((bone) => {\n            const boneName = bone.name;\n            const boneNameLower = boneName.toLowerCase();\n            \n            // For coach_grace and similar avatars\n            if (boneNameLower.includes('upperarm_l') || boneName === 'LeftArm' || boneName === 'mixamorig:LeftArm') {\n              bone.rotation.x = 0.3;\n              bone.rotation.z = 0.8;\n              bone.updateMatrixWorld(true);\n              console.log('Fixed left arm:', boneName);\n            }\n            \n            if (boneNameLower.includes('upperarm_r') || boneName === 'RightArm' || boneName === 'mixamorig:RightArm') {\n              bone.rotation.x = 0.3;\n              bone.rotation.z = -0.8;\n              bone.updateMatrixWorld(true);\n              console.log('Fixed right arm:', boneName);\n            }\n            \n            // Fix shoulders\n            if (boneNameLower.includes('shoulder_l') || boneName === 'LeftShoulder' || boneName === 'mixamorig:LeftShoulder') {\n              bone.rotation.z = 0.1;\n              bone.updateMatrixWorld(true);\n              console.log('Fixed left shoulder:', boneName);\n            }\n            \n            if (boneNameLower.includes('shoulder_r') || boneName === 'RightShoulder' || boneName === 'mixamorig:RightShoulder') {\n              bone.rotation.z = -0.1;\n              bone.updateMatrixWorld(true);\n              console.log('Fixed right shoulder:', boneName);\n            }\n          });\n          \n          hasAppliedFix.current = true;\n          console.log('✅ T-pose fix applied');\n        }\n      }\n    });\n    \n    if (!foundBones) {\n      console.warn('⚠️ No skeleton found in avatar!');\n    }\n  }, [clonedScene, avatarUrl]);\n  \n  // Load animations separately and create a combined animations array\n  const idleGLTF = useGLTF(idleAnimationUrl);\n  const talkGLTF = useGLTF(talkAnimationUrl);\n  \n  // Combine animations and rename them for clarity\n  const animations = useMemo(() => {\n    const anims = [];\n    if (idleGLTF.animations && idleGLTF.animations.length > 0) {\n      const idleAnim = idleGLTF.animations[0].clone();\n      idleAnim.name = 'idle';\n      anims.push(idleAnim);\n    }\n    if (talkGLTF.animations && talkGLTF.animations.length > 0) {\n      const talkAnim = talkGLTF.animations[0].clone();\n      talkAnim.name = 'talk';\n      anims.push(talkAnim);\n    }\n    return anims;\n  }, [idleGLTF.animations, talkGLTF.animations]);\n  \n  // Setup animations with the cloned scene or a dummy group\n  const animationTarget = useMemo(() => {\n    return clonedScene || new THREE.Group();\n  }, [clonedScene]);\n  \n  const { actions, mixer } = useAnimations(animations, animationTarget);\n  \n  // Debug animation setup\n  useEffect(() => {\n    console.log('=== ANIMATION DEBUG ===');\n    console.log('Avatar:', avatarUrl);\n    console.log('Idle animation:', idleAnimationUrl);\n    console.log('Talk animation:', talkAnimationUrl);\n    console.log('Number of animations loaded:', animations.length);\n    console.log('Animation names:', animations.map(a => a.name));\n    console.log('Actions available:', actions ? Object.keys(actions) : 'none');\n    console.log('Mixer:', mixer ? 'created' : 'not created');\n    console.log('Group ref:', group.current ? 'exists' : 'null');\n  }, [avatarUrl, idleAnimationUrl, talkAnimationUrl, animations, actions, mixer]);\n  \n  // Initialize with idle animation\n  useEffect(() => {\n    if (!actions || !mixer || !clonedScene) return;\n    \n    // Small delay to ensure everything is loaded\n    const timer = setTimeout(() => {\n      console.log('=== PRESENCE AVATAR ANIMATION INIT ===');\n      console.log('Available actions:', Object.keys(actions));\n      \n      // Stop all current actions first\n      Object.values(actions).forEach(action => {\n        if (action) {\n          action.stop();\n        }\n      });\n      \n      const idleAction = actions['idle'];\n      if (idleAction) {\n        // Reset and start idle immediately\n        idleAction.reset();\n        idleAction.setEffectiveWeight(1);\n        idleAction.setEffectiveTimeScale(1);\n        idleAction.play();\n        currentAction.current = idleAction;\n        console.log('✅ Started idle animation immediately');\n        \n        // Force an initial update\n        mixer.update(0);\n      } else {\n        console.error('❌ No idle animation found!');\n      }\n    }, 100); // 100ms delay\n    \n    return () => {\n      clearTimeout(timer);\n      // Cleanup\n      if (currentAction.current) {\n        currentAction.current.stop();\n      }\n    };\n  }, [actions, mixer, avatarUrl, clonedScene]); // Added avatarUrl as dependency to reinit on avatar change\n  \n  // Handle speaking state changes\n  useEffect(() => {\n    if (!actions || !partnerState) return;\n    \n    const targetAction = partnerState.isSpeaking ? actions['talk'] : actions['idle'];\n    \n    if (targetAction && currentAction.current !== targetAction) {\n      // Fade between animations\n      const fadeTime = 0.5;\n      \n      if (currentAction.current) {\n        currentAction.current.fadeOut(fadeTime);\n      }\n      \n      targetAction\n        .reset()\n        .setEffectiveTimeScale(1)\n        .setEffectiveWeight(1)\n        .fadeIn(fadeTime)\n        .play();\n      \n      currentAction.current = targetAction;\n      \n      console.log(`Switched to ${partnerState.isSpeaking ? 'talk' : 'idle'} animation`);\n    }\n  }, [partnerState?.isSpeaking, actions]);\n  \n  // Update animation mixer\n  useFrame((state, delta) => {\n    frameCount.current++;\n    \n    // Detect when tracking data changes\n    const hasTrackingData = !!trackingData;\n    if (hasTrackingData !== lastTrackingState.current) {\n      console.log('[PresenceAvatar] TRACKING STATE CHANGED:', {\n        from: lastTrackingState.current,\n        to: hasTrackingData,\n        groupVisible: group.current?.visible,\n        clonedSceneVisible: clonedScene?.visible,\n        groupPosition: group.current?.position.toArray(),\n        groupScale: group.current?.scale.toArray(),\n        clonedScenePosition: clonedScene?.position.toArray(),\n        clonedSceneScale: clonedScene?.scale.toArray()\n      });\n      lastTrackingState.current = hasTrackingData;\n    }\n    \n    // Log every 60 frames (approximately once per second)\n    if (frameCount.current % 60 === 0) {\n      console.log('[PresenceAvatar] Frame update:', {\n        frame: frameCount.current,\n        hasTrackingData: !!trackingData,\n        hasClonedScene: !!clonedScene,\n        clonedSceneVisible: clonedScene?.visible,\n        groupVisible: group.current?.visible,\n        groupPosition: group.current?.position.toArray(),\n        groupScale: group.current?.scale.toArray(),\n        clonedSceneInGroup: clonedScene ? group.current?.children.includes(clonedScene) : false\n      });\n      \n      // Check if cloned scene has been removed from group\n      if (clonedScene && group.current && !group.current.children.some(child => child === clonedScene)) {\n        console.error('[PresenceAvatar] CLONED SCENE REMOVED FROM GROUP!');\n      }\n      \n      // Check for any transform issues\n      if (clonedScene) {\n        const pos = clonedScene.position.toArray();\n        const scale = clonedScene.scale.toArray();\n        const hasNaN = [...pos, ...scale].some(v => isNaN(v));\n        const hasZeroScale = scale.some(v => v === 0);\n        \n        if (hasNaN || hasZeroScale) {\n          console.error('[PresenceAvatar] INVALID TRANSFORM:', {\n            position: pos,\n            scale: scale,\n            hasNaN,\n            hasZeroScale\n          });\n        }\n      }\n    }\n    \n    if (!group.current || !clonedScene) {\n      console.warn('[PresenceAvatar] Missing group or clonedScene in useFrame');\n      return;\n    }\n    \n    // Debug log tracking data occasionally\n    if (Math.random() < 0.02) {\n      console.log('[PresenceAvatar] useFrame - tracking data check:', {\n        hasTrackingData: !!trackingData,\n        hasFacialExpressions: !!trackingData?.facialExpressions,\n        hasHeadRotation: !!(trackingData as any)?.headRotation,\n        sampleExpression: trackingData?.facialExpressions?.mouthSmile\n      });\n    }\n    \n    if (mixer) {\n      mixer.update(delta);\n      \n      // Apply head rotation with smoothing\n      const targetBone = neckBone.current || headBone.current;\n      if (targetBone) {\n        if (trackingData) {\n          const headRotation = (trackingData as any).headRotation;\n          if (headRotation) {\n            // Log head rotation occasionally\n            if (Math.random() < 0.02) {\n              console.log('[PresenceAvatar] Head rotation raw:', {\n                pitch: headRotation.pitch.toFixed(2),\n                yaw: headRotation.yaw.toFixed(2),\n                roll: headRotation.roll.toFixed(2)\n              });\n              console.log('[PresenceAvatar] Head rotation applied:', {\n                x: (headRotation.pitch * 0.15).toFixed(3),\n                y: (-headRotation.yaw * 0.12).toFixed(3),\n                z: (-headRotation.roll * 0.08).toFixed(3)\n              });\n            }\n            \n            // Apply head and neck rotation with mirroring\n            const sensitivity = {\n              pitch: 0.15,  // Reduced from 0.3 - much subtler movement\n              yaw: 0.12,    // Reduced from 0.25\n              roll: 0.08    // Reduced from 0.15\n            };\n            \n            const targetRotation = {\n              x: headRotation.pitch * sensitivity.pitch,  // No negation for pitch - positive pitch = look down\n              y: -headRotation.yaw * sensitivity.yaw,     // Negate for mirroring\n              z: -headRotation.roll * sensitivity.roll    // Negate for mirroring\n            };\n            \n            // Smooth the rotation values over time with stronger smoothing\n            smoothedRotation.current.x = THREE.MathUtils.lerp(smoothedRotation.current.x, targetRotation.x, 0.05);\n            smoothedRotation.current.y = THREE.MathUtils.lerp(smoothedRotation.current.y, targetRotation.y, 0.05);\n            smoothedRotation.current.z = THREE.MathUtils.lerp(smoothedRotation.current.z, targetRotation.z, 0.05);\n            \n            // Apply rotation only to head, not neck\n            if (headBone.current) {\n              headBone.current.rotation.x = defaultHeadRotation.current.x + smoothedRotation.current.x;\n              headBone.current.rotation.y = defaultHeadRotation.current.y + smoothedRotation.current.y;\n              headBone.current.rotation.z = defaultHeadRotation.current.z + smoothedRotation.current.z;\n            }\n            \n            // Keep neck stable - don't apply rotation to neck\n            // targetBone is neck, so we skip it\n            \n            // Add forward/backward movement based on face distance\n            // Estimate distance from face size (landmarks spread)\n            const faceData = (trackingData as any).landmarks;\n            if (faceData && faceData.length > 0 && headBone.current) {\n              // Calculate face width from outer eye corners or jaw width\n              const leftPoint = faceData[356] || faceData[234] || faceData[454]; // Left face edge\n              const rightPoint = faceData[127] || faceData[10] || faceData[234]; // Right face edge\n              \n              if (leftPoint && rightPoint) {\n                const faceWidth = Math.sqrt(\n                  Math.pow(rightPoint[0] - leftPoint[0], 2) + \n                  Math.pow(rightPoint[1] - leftPoint[1], 2)\n                );\n                \n                // Normalize face width (typical range 0.3 to 0.6)\n                // Larger face = closer to camera = move forward\n                const normalizedDistance = (faceWidth - 0.45) * 2.5; // Reduced from 5.0 to 2.5\n                const targetZ = THREE.MathUtils.clamp(normalizedDistance * 0.05, -0.03, 0.03); // Reduced range\n                \n                // Smooth the position\n                smoothedPosition.current.z = THREE.MathUtils.lerp(\n                  smoothedPosition.current.z, \n                  targetZ, \n                  0.05 // Reduced from 0.08 for smoother movement\n                );\n                \n                // Apply position offset to head\n                headBone.current.position.z = baseHeadPosition.current.z + smoothedPosition.current.z;\n                \n                // Log more frequently for debugging\n                if (Math.random() < 0.05) { // Increased from 0.01\n                  console.log('[PresenceAvatar] Head depth:', {\n                    faceWidth: faceWidth.toFixed(3),\n                    normalizedDistance: normalizedDistance.toFixed(3),\n                    targetZ: targetZ.toFixed(3),\n                    smoothedZ: smoothedPosition.current.z.toFixed(3),\n                    applied: (baseHeadPosition.current.z + smoothedPosition.current.z).toFixed(3)\n                  });\n                }\n              } else {\n                console.log('[PresenceAvatar] No face landmarks found for depth calculation');\n              }\n            }\n          } else {\n            // Reset to default position when no tracking data\n            smoothedRotation.current.x = THREE.MathUtils.lerp(smoothedRotation.current.x, 0, 0.05);\n            smoothedRotation.current.y = THREE.MathUtils.lerp(smoothedRotation.current.y, 0, 0.05);\n            smoothedRotation.current.z = THREE.MathUtils.lerp(smoothedRotation.current.z, 0, 0.05);\n            smoothedPosition.current.z = THREE.MathUtils.lerp(smoothedPosition.current.z, 0, 0.05);\n            \n            if (headBone.current) {\n              headBone.current.rotation.x = defaultHeadRotation.current.x + smoothedRotation.current.x;\n              headBone.current.rotation.y = defaultHeadRotation.current.y + smoothedRotation.current.y;\n              headBone.current.rotation.z = defaultHeadRotation.current.z + smoothedRotation.current.z;\n              headBone.current.position.z = baseHeadPosition.current.z + smoothedPosition.current.z;\n            }\n          }\n          \n          // Apply posture tracking to spine/torso\n          if (trackingData?.posture && clonedScene) {\n            const skinnedMesh = clonedScene.getObjectByProperty('type', 'SkinnedMesh') as THREE.SkinnedMesh | undefined;\n            if (skinnedMesh?.skeleton) {\n              const spineBone = skinnedMesh.skeleton.bones.find((bone: THREE.Bone) => \n                bone.name.toLowerCase().includes('spine') || \n                bone.name.toLowerCase().includes('chest')\n              );\n              \n              if (spineBone) {\n                const posture = trackingData.posture;\n                // Apply subtle torso rotation based on shoulder positions\n                if (posture.keypoints.leftShoulder && posture.keypoints.rightShoulder) {\n                  const shoulderTilt = (posture.keypoints.leftShoulder.y - posture.keypoints.rightShoulder.y) * 0.5;\n                  const clampedTilt = THREE.MathUtils.clamp(shoulderTilt, -0.2, 0.2);\n                  \n                  // Log only occasionally to avoid spam\n                  if (Math.random() < 0.02) {\n                    console.log('[PresenceAvatar] Applying posture:', {\n                      leftY: posture.keypoints.leftShoulder.y.toFixed(3),\n                      rightY: posture.keypoints.rightShoulder.y.toFixed(3),\n                      tilt: shoulderTilt.toFixed(3),\n                      clampedTilt: clampedTilt.toFixed(3)\n                    });\n                  }\n                  \n                  spineBone.rotation.z = THREE.MathUtils.lerp(\n                    spineBone.rotation.z, \n                    clampedTilt,\n                    0.05\n                  );\n                }\n              } else if (Math.random() < 0.01) {\n                console.log('[PresenceAvatar] No spine/chest bone found in skeleton');\n              }\n            }\n          }\n          \n          // Apply facial expressions here in useFrame\n          if (trackingData?.facialExpressions && clonedScene && !disableMorphTargets) {\n            // Log before morph target processing\n            const beforeVisible = clonedScene.visible;\n            const beforePosition = clonedScene.position.clone();\n            const beforeScale = clonedScene.scale.clone();\n            \n            if (Math.random() < 0.05) {\n              console.log('[PresenceAvatar] BEFORE morph targets:', {\n                visible: beforeVisible,\n                position: beforePosition.toArray(),\n                scale: beforeScale.toArray()\n              });\n            }\n            \n            // Find the skinned mesh with morph targets\n            let meshWithMorphs: THREE.SkinnedMesh | null = null;\n            \n            clonedScene.traverse((child) => {\n              if ((child as THREE.SkinnedMesh).isSkinnedMesh) {\n                const skinnedMesh = child as THREE.SkinnedMesh;\n                if ((skinnedMesh as any).morphTargetDictionary && (skinnedMesh as any).morphTargetInfluences) {\n                  meshWithMorphs = skinnedMesh;\n                }\n              }\n            });\n            \n            if (Math.random() < 0.05) {\n              console.log('[PresenceAvatar] Found mesh:', !!meshWithMorphs);\n            }\n            \n            if (meshWithMorphs) {\n              const meshAny = meshWithMorphs as any;\n              if (meshAny.morphTargetDictionary && meshAny.morphTargetInfluences) {\n                // Now TypeScript knows these properties exist\n                const morphDict = meshAny.morphTargetDictionary;\n                const morphInfluences = meshAny.morphTargetInfluences;\n                \n                // Log all available morph targets once\n                if (!hasLoggedMorphTargets.current) {\n                  console.log('=== Available Morph Targets ===');\n                  console.log('Total morph targets:', Object.keys(morphDict).length);\n                  Object.keys(morphDict).forEach((name, index) => {\n                    console.log(`  ${index}: ${name}`);\n                  });\n                  hasLoggedMorphTargets.current = true;\n                }\n                \n                // Apply expressions to morph targets\n                const expressions = trackingData.facialExpressions;\n                const activeExpressions: string[] = [];\n                \n                Object.entries(expressions).forEach(([key, value]) => {\n                  if (value > 0.01) {\n                    activeExpressions.push(`${key}:${value.toFixed(2)}`);\n                  }\n                });\n                \n                // Log expression values periodically\n                const now = Date.now();\n                if (activeExpressions.length > 0 && now - lastLogTime.current > 3000) {\n                  console.log('[PresenceAvatar] Active expressions:', {\n                    expressions: activeExpressions.join(', '),\n                    hasMesh: true,\n                    morphTargetCount: Object.keys(morphDict).length\n                  });\n                  \n                  lastLogTime.current = now;\n                }\n                \n                // Function to apply bilateral expressions\n                const applyBilateral = (leftExpName: string, rightExpName: string) => {\n                  const leftPossible = leftExpName;\n                  const rightPossible = rightExpName;\n                  \n                  if (leftPossible && rightPossible && morphDict && morphInfluences) {\n                    const leftTarget = findMorphTarget([leftPossible]);\n                    const rightTarget = findMorphTarget([rightPossible]);\n                    \n                    if (leftTarget && rightTarget) {\n                      const leftIndex = morphDict[leftTarget];\n                      const rightIndex = morphDict[rightTarget];\n                      const leftValue = morphInfluences[leftIndex] || 0;\n                      const rightValue = morphInfluences[rightIndex] || 0;\n                      const maxValue = Math.max(leftValue, rightValue);\n                      \n                      if (maxValue > 0) {\n                        morphInfluences[leftIndex] = maxValue;\n                        morphInfluences[rightIndex] = maxValue;\n                      }\n                    }\n                  }\n                };\n                \n                // Function to find a morph target from possible names\n                const findMorphTarget = (possibleNames: string[]): string | null => {\n                  if (!morphDict) return null;\n                  for (const name of possibleNames) {\n                    if (morphDict.hasOwnProperty(name)) {\n                      return name;\n                    }\n                  }\n                  return null;\n                };\n                \n                // Apply expressions to morph targets\n                const applyMorphTargets = (mesh: THREE.SkinnedMesh, expressions: any) => {\n                  // Detect if we have strong smile/frown to reduce mouth open\n                  const hasSmile = (expressions.mouthSmileLeft || 0) > 0.15 || (expressions.mouthSmileRight || 0) > 0.15;\n                  const hasFrown = (expressions.mouthFrownLeft || 0) > 0.15 || (expressions.mouthFrownRight || 0) > 0.15;\n                  const hasPucker = (expressions.mouthPucker || 0) > 0.15;\n                  \n                  // Expression name mapping to possible morph target names\n                  const expressionMorphMap: { [key: string]: string[] } = {\n                    // Eye expressions\n                    eyeBlinkLeft: ['eyeBlinkLeft', 'eyeBlink_L', 'EyeBlinkLeft', 'leftEyeClosed', 'eye_closed_L'],\n                    eyeBlinkRight: ['eyeBlinkRight', 'eyeBlink_R', 'EyeBlinkRight', 'rightEyeClosed', 'eye_closed_R'],\n                    eyeWideLeft: ['eyeWideLeft', 'eyeWide_L', 'EyeWideLeft', 'eye_wide_L'],\n                    eyeWideRight: ['eyeWideRight', 'eyeWide_R', 'EyeWideRight', 'eye_wide_R'],\n                    eyeSquintLeft: ['eyeSquintLeft', 'eyeSquint_L', 'EyeSquintLeft', 'eye_squint_L'],\n                    eyeSquintRight: ['eyeSquintRight', 'eyeSquint_R', 'EyeSquintRight', 'eye_squint_R'],\n                    \n                    // Eyebrow expressions  \n                    eyebrowRaiseLeft: ['browOuterUpLeft', 'browOuterUp_L', 'BrowOuterUpLeft', 'leftBrowUp', 'brow_up_L'],\n                    eyebrowRaiseRight: ['browOuterUpRight', 'browOuterUp_R', 'BrowOuterUpRight', 'rightBrowUp', 'brow_up_R'],\n                    eyebrowFurrow: ['browInnerUp', 'browDown', 'BrowInnerUp', 'browFurrow', 'brow_angry'],\n                    browDownLeft: ['browDownLeft', 'browDown_L', 'BrowDownLeft', 'brow_down_L'],\n                    browDownRight: ['browDownRight', 'browDown_R', 'BrowDownRight', 'brow_down_R'],\n                    browInnerUp: ['browInnerUp', 'BrowInnerUp', 'brow_inner_up'],\n                    \n                    // Mouth expressions\n                    mouthSmile: ['mouthSmileLeft', 'mouthSmile_L', 'MouthSmileLeft', 'smile', 'mouth_smile_L'],\n                    mouthSmileRight: ['mouthSmileRight', 'mouthSmile_R', 'MouthSmileRight', 'mouth_smile_R'],\n                    mouthFrown: ['mouthFrownLeft', 'mouthFrown_L', 'MouthFrownLeft', 'frown', 'mouth_frown_L'],\n                    mouthFrownRight: ['mouthFrownRight', 'mouthFrown_R', 'MouthFrownRight', 'mouth_frown_R'],\n                    mouthPucker: ['mouthPucker', 'MouthPucker', 'pucker', 'mouth_pucker'],\n                    mouthOpen: ['mouthOpen', 'jawOpen', 'MouthOpen', 'mouth_open', 'jaw_open'],\n                    mouthPress: ['mouthPress', 'MouthPress', 'mouth_press'],\n                    mouthPressLeft: ['mouthPressLeft', 'mouthPress_L', 'MouthPressLeft'],\n                    mouthPressRight: ['mouthPressRight', 'mouthPress_R', 'MouthPressRight'],\n                    mouthUpperUpLeft: ['mouthUpperUpLeft', 'mouthUpperUp_L', 'mouth_upperLip_raise_L'],\n                    mouthUpperUpRight: ['mouthUpperUpRight', 'mouthUpperUp_R', 'mouth_upperLip_raise_R'],\n                    mouthLowerDown: ['mouthLowerDown', 'MouthLowerDown', 'mouth_lowerLip_depress'],\n                    mouthStretchLeft: ['mouthStretchLeft', 'mouthStretch_L', 'mouth_stretch_L'],\n                    mouthStretchRight: ['mouthStretchRight', 'mouthStretch_R', 'mouth_stretch_R'],\n                    mouthDimpleLeft: ['mouthDimpleLeft', 'mouthDimple_L', 'mouth_dimple_L'],\n                    mouthDimpleRight: ['mouthDimpleRight', 'mouthDimple_R', 'mouth_dimple_R'],\n                    \n                    // Jaw movements\n                    jawLeft: ['jawLeft', 'JawLeft', 'jaw_left'],\n                    jawRight: ['jawRight', 'JawRight', 'jaw_right'],\n                    jawForward: ['jawForward', 'JawForward', 'jaw_forward'],\n                    \n                    // Cheek expressions\n                    cheekPuff: ['cheekPuff', 'CheekPuff', 'cheek_puff'],\n                    cheekSquintLeft: ['cheekSquintLeft', 'cheekSquint_L', 'cheek_squint_L'],\n                    cheekSquintRight: ['cheekSquintRight', 'cheekSquint_R', 'cheek_squint_R'],\n                    \n                    // Nose expressions\n                    noseSneerLeft: ['noseSneerLeft', 'noseSneer_L', 'nose_sneer_L'],\n                    noseSneerRight: ['noseSneerRight', 'noseSneer_R', 'nose_sneer_R'],\n                    \n                    // Tongue expressions\n                    tongueOut: ['tongueOut', 'TongueOut', 'tongue_out']\n                  };\n                  \n                  // Apply each expression\n                  Object.entries(expressions).forEach(([key, value]) => {\n                    if (typeof value !== 'number' || value <= 0) return;\n                    \n                    const possibleNames = expressionMorphMap[key];\n                    if (possibleNames) {\n                      const targetName = findMorphTarget(possibleNames);\n                      \n                      if (targetName && morphDict && morphInfluences) {\n                        const index = morphDict[targetName];\n                        \n                        // When we have emotional expressions, reduce mouth open significantly\n                        let mouthOpenReduction = 1.0;\n                        if (key === 'jawOpen' && (hasSmile || hasFrown || hasPucker)) {\n                          mouthOpenReduction = 0.15;\n                          console.log('[PresenceAvatar] Reducing mouth open due to emotional expression');\n                        }\n                        \n                        // Apply the expression value with mouth open reduction\n                        let targetValue = value * mouthOpenReduction;\n                        \n                        // Amplify certain expressions for better visibility\n                        const amplificationMap: { [key: string]: number } = {\n                          'mouthSmileLeft': 1.8,\n                          'mouthSmileRight': 1.8,\n                          'mouthFrownLeft': 1.5,\n                          'mouthFrownRight': 1.5,\n                          'browRaiseLeft': 2.0,\n                          'browRaiseRight': 2.0,\n                          'eyeBlinkLeft': 1.2,\n                          'eyeBlinkRight': 1.2,\n                          'cheekSquintLeft': 1.5,\n                          'cheekSquintRight': 1.5,\n                          'noseSneerLeft': 2.0,\n                          'noseSneerRight': 2.0,\n                          'mouthPucker': 1.8,\n                          'jawOpen': 1.0\n                        };\n                        \n                        const amplification = amplificationMap[key] || 1.0;\n                        const amplifiedValue = Math.min(targetValue * amplification, 1.0);\n                        \n                        morphInfluences[index] = amplifiedValue;\n                        \n                        // Log high expression values\n                        if (value > 0.3 && Math.random() < 0.05) {\n                          console.log(`[PresenceAvatar] High expression: ${key} = ${value.toFixed(3)} -> ${targetName}[${index}] = ${amplifiedValue.toFixed(3)}`);\n                        }\n                      }\n                    }\n                  });\n                  \n                  // Helper function to apply bilateral expressions\n                  const applyBilateral = (leftExpName: string, rightExpName: string) => {\n                    const leftPossible = leftExpName;\n                    const rightPossible = rightExpName;\n                    \n                    if (leftPossible && rightPossible && morphDict && morphInfluences) {\n                      const leftTarget = findMorphTarget([leftPossible]);\n                      const rightTarget = findMorphTarget([rightPossible]);\n                      \n                      if (leftTarget && rightTarget) {\n                        const leftIndex = morphDict[leftTarget];\n                        const rightIndex = morphDict[rightTarget];\n                        const leftValue = morphInfluences[leftIndex] || 0;\n                        const rightValue = morphInfluences[rightIndex] || 0;\n                        const maxValue = Math.max(leftValue, rightValue);\n                        \n                        if (maxValue > 0) {\n                          morphInfluences[leftIndex] = maxValue;\n                          morphInfluences[rightIndex] = maxValue;\n                        }\n                      }\n                    }\n                  };\n                  \n                  // Synchronize bilateral expressions\n                  applyBilateral('mouthSmileLeft', 'mouthSmileRight');\n                  applyBilateral('mouthFrownLeft', 'mouthFrownRight');\n                  applyBilateral('eyebrowRaiseLeft', 'eyebrowRaiseRight');\n                  applyBilateral('eyeBlinkLeft', 'eyeBlinkRight');\n                  applyBilateral('cheekSquintLeft', 'cheekSquintRight');\n                };\n                \n                applyMorphTargets(meshWithMorphs, expressions);\n                \n                // Log mesh visibility after applying expressions\n                if (Math.random() < 0.02) {\n                  console.log('[PresenceAvatar] After applying expressions:', {\n                    meshVisible: meshAny.visible,\n                    meshPosition: meshAny.position.toArray(),\n                    meshScale: meshAny.scale.toArray(),\n                    parentVisible: meshAny.parent?.visible,\n                    sceneVisible: clonedScene.visible\n                  });\n                }\n              }\n            }\n            \n            // Check if visibility changed after morph target processing\n            if (clonedScene.visible !== beforeVisible) {\n              console.error('[PresenceAvatar] VISIBILITY CHANGED during morph targets!', {\n                before: beforeVisible,\n                after: clonedScene.visible\n              });\n            }\n            \n            // Check if position/scale changed unexpectedly\n            const afterPosition = clonedScene.position;\n            const afterScale = clonedScene.scale;\n            if (!beforePosition.equals(afterPosition) || !beforeScale.equals(afterScale)) {\n              console.error('[PresenceAvatar] TRANSFORM CHANGED during morph targets!', {\n                positionBefore: beforePosition.toArray(),\n                positionAfter: afterPosition.toArray(),\n                scaleBefore: beforeScale.toArray(),\n                scaleAfter: afterScale.toArray()\n              });\n            }\n          }\n        }\n      }\n    }\n  });\n  \n  // Cleanup on unmount\n  useEffect(() => {\n    console.log('[PresenceAvatar] Component mounted');\n    return () => {\n      console.log('[PresenceAvatar] Component unmounting!');\n    };\n  }, []);\n\n  useEffect(() => {\n    console.log('[PresenceAvatar] Component mounted with avatarUrl:', avatarUrl);\n    console.log('[PresenceAvatar] Position:', position);\n    console.log('[PresenceAvatar] Scale:', scale);\n  }, [avatarUrl, position, scale]);\n\n  const scaleVector = new THREE.Vector3(scale, scale, scale);\n\n  useFrame(() => {\n    if (!group.current || !clonedScene) return;\n    \n    if (Math.random() < 0.01) {\n      console.log('[PresenceAvatar] === Avatar State Check ===');\n      console.log('[PresenceAvatar] Group visible:', group.current.visible);\n      console.log('[PresenceAvatar] Group position:', group.current.position.toArray());\n      console.log('[PresenceAvatar] Group scale:', group.current.scale.toArray());\n      console.log('[PresenceAvatar] Group children count:', group.current.children.length);\n      \n      console.log('[PresenceAvatar] ClonedScene visible:', clonedScene.visible);\n      console.log('[PresenceAvatar] ClonedScene position:', clonedScene.position.toArray());\n      console.log('[PresenceAvatar] ClonedScene scale:', clonedScene.scale.toArray());\n      console.log('[PresenceAvatar] ClonedScene children:', clonedScene.children.length);\n      \n      // Check all children\n      let skinnedMeshCount = 0;\n      let visibleMeshCount = 0;\n      clonedScene.traverse((child: THREE.Object3D) => {\n        if ((child as THREE.SkinnedMesh).isSkinnedMesh) {\n          skinnedMeshCount++;\n          if (child.visible) visibleMeshCount++;\n          const mesh = child as THREE.SkinnedMesh;\n          console.log('[PresenceAvatar] SkinnedMesh:', {\n            name: child.name,\n            visible: child.visible,\n            position: child.position.toArray(),\n            scale: child.scale.toArray(),\n            parentVisible: child.parent?.visible,\n            geometry: !!mesh.geometry,\n            geometryBounds: mesh.geometry?.boundingBox ? \n              [mesh.geometry.boundingBox.min.toArray(), mesh.geometry.boundingBox.max.toArray()] : null,\n            material: mesh.material ? (Array.isArray(mesh.material) ? mesh.material.length : 1) : 0,\n            materialVisible: mesh.material ? \n              (Array.isArray(mesh.material) ? (mesh.material[0] as any).visible : (mesh.material as any).visible) : null,\n            materialOpacity: mesh.material ? \n              (Array.isArray(mesh.material) ? (mesh.material[0] as any).opacity : (mesh.material as any).opacity) : null,\n            materialTransparent: mesh.material ? \n              (Array.isArray(mesh.material) ? (mesh.material[0] as any).transparent : (mesh.material as any).transparent) : null\n          });\n        }\n      });\n      \n      console.log('[PresenceAvatar] Total skinned meshes:', skinnedMeshCount, 'Visible:', visibleMeshCount);\n      console.log('[PresenceAvatar] ======================');\n    }\n    \n    const groupRef = group.current;\n    if (groupRef) {\n      console.log('[PresenceAvatar] useFrame - Avatar group and clonedScene visibility:', {\n        groupVisible: groupRef.visible,\n        groupPosition: groupRef.position.toArray(),\n        groupScale: groupRef.scale.toArray(),\n        clonedSceneVisible: clonedScene.visible,\n        clonedScenePosition: clonedScene.position.toArray(),\n        clonedSceneScale: clonedScene.scale.toArray(),\n        clonedSceneChildren: clonedScene.children.length\n      });\n      \n      // Check for NaN or invalid values\n      const groupPos = groupRef.position.toArray();\n      const groupScale = groupRef.scale.toArray();\n      const clonedPos = clonedScene.position.toArray();\n      const clonedScale = clonedScene.scale.toArray();\n      \n      const hasInvalidValues = [...groupPos, ...groupScale, ...clonedPos, ...clonedScale].some(\n        v => isNaN(v) || !isFinite(v)\n      );\n      \n      const hasZeroScale = [...groupScale, ...clonedScale].some(v => v === 0);\n      \n      if (hasInvalidValues) {\n        console.error('[PresenceAvatar] INVALID VALUES DETECTED:', {\n          groupPosition: groupPos,\n          groupScale: groupScale,\n          clonedPosition: clonedPos,\n          clonedScale: clonedScale\n        });\n      }\n      \n      if (hasZeroScale) {\n        console.error('[PresenceAvatar] ZERO SCALE DETECTED:', {\n          groupScale: groupScale,\n          clonedScale: clonedScale\n        });\n      }\n    }\n  });\n\n  // Show loading indicator while scene is loading\n  if (isLoading && !clonedScene) {\n    console.log('[PresenceAvatar] Loading avatar...');\n    return (\n      <group position={position}>\n        <mesh>\n          <boxGeometry args={[0.5, 0.5, 0.5]} />\n          <meshBasicMaterial color=\"gray\" />\n        </mesh>\n      </group>\n    );\n  }\n\n  // Don't render if scene isn't loaded (shouldn't happen with loading check above)\n  if (!clonedScene) {\n    console.error('[PresenceAvatar] No cloned scene available after loading');\n    return null;\n  }\n  \n  // Ensure cloned scene is visible\n  if (!clonedScene.visible) {\n    console.warn('[PresenceAvatar] Cloned scene is not visible, forcing visibility');\n    clonedScene.visible = true;\n  }\n\n  return (\n    <group \n      ref={group} \n      position={position} \n      scale={scaleVector}\n    >\n      {/* Render the cloned scene as a single primitive */}\n      <primitive object={clonedScene} />\n      \n      {/* Debug marker to ensure group is rendering */}\n      <mesh position={[0, 2.5, 0]}>\n        <boxGeometry args={[0.3, 0.3, 0.3]} />\n        <meshBasicMaterial color=\"purple\" />\n      </mesh>\n      \n      {/* Subtle shadow for grounding */}\n      <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, 0.01, 0]} receiveShadow>\n        <planeGeometry args={[2, 2]} />\n        <shadowMaterial opacity={0.4} />\n      </mesh>\n      \n      {/* Custom Box3Helper implementation */}\n      {clonedScene && (\n        <mesh ref={(ref) => {\n          if (ref) {\n            const box = new THREE.Box3().setFromObject(clonedScene);\n            const center = new THREE.Vector3();\n            const size = new THREE.Vector3();\n            box.getCenter(center);\n            box.getSize(size);\n            ref.position.copy(center);\n            ref.scale.copy(size);\n          }\n        }}>\n          <boxGeometry args={[1, 1, 1]} />\n          <meshBasicMaterial color=\"red\" wireframe />\n        </mesh>\n      )}\n    </group>\n  );\n};\n\nexport { PresenceAvatar };\nexport default PresenceAvatar;\n"],"names":["useGLTF","preload","PresenceAvatar","_ref","avatarUrl","idleAnimationUrl","talkAnimationUrl","position","scale","emotionalState","partnerState","trackingData","debugMode","isUser","cameraPosition","cameraTarget","disableMorphTargets","console","log","group","useRef","currentAction","hasLoggedMorphTargets","hasAppliedFix","headBone","neckBone","spineBone","smoothedRotation","x","y","z","smoothedPosition","baseHeadPosition","defaultHeadRotation","lastLogTime","frameCount","lastTrackingState","scene","isLoading","setIsLoading","useState","clonedScene","useMemo","error","cloned","SkeletonUtils","clone","originalChildren","children","length","clonedChildren","traverse","child","isMesh","isSkinnedMesh","mesh","frustumCulled","material","Array","isArray","forEach","mat","visible","opacity","transparent","name","materialVisible","set","useEffect","findBones","useCallback","skinnedMesh","getObjectByProperty","skeleton","bones","head","find","bone","toLowerCase","includes","neck","spine","current","rotation","foundBones","boneNames","node","index","push","concat","isRPM","some","slice","boneName","boneNameLower","updateMatrixWorld","warn","idleGLTF","talkGLTF","animations","anims","idleAnim","talkAnim","animationTarget","THREE","actions","mixer","useAnimations","map","a","Object","keys","timer","setTimeout","values","action","stop","idleAction","reset","setEffectiveWeight","setEffectiveTimeScale","play","update","clearTimeout","targetAction","isSpeaking","fadeTime","fadeOut","fadeIn","useFrame","state","delta","hasTrackingData","_group$current","_group$current2","_group$current3","_group$current4","_group$current5","_group$current6","_group$current7","from","to","groupVisible","clonedSceneVisible","groupPosition","toArray","groupScale","clonedScenePosition","clonedSceneScale","frame","hasClonedScene","clonedSceneInGroup","pos","hasNaN","v","isNaN","hasZeroScale","_trackingData$facialE","Math","random","hasFacialExpressions","facialExpressions","hasHeadRotation","headRotation","sampleExpression","mouthSmile","pitch","toFixed","yaw","roll","sensitivity","targetRotation","lerp","faceData","landmarks","leftPoint","rightPoint","faceWidth","sqrt","pow","normalizedDistance","targetZ","clamp","smoothedZ","applied","posture","keypoints","leftShoulder","rightShoulder","shoulderTilt","clampedTilt","leftY","rightY","tilt","beforeVisible","beforePosition","beforeScale","meshWithMorphs","morphTargetDictionary","morphTargetInfluences","meshAny","morphDict","morphInfluences","expressions","activeExpressions","entries","_ref2","key","value","now","Date","join","hasMesh","morphTargetCount","findMorphTarget","possibleNames","hasOwnProperty","applyMorphTargets","hasSmile","mouthSmileLeft","mouthSmileRight","hasFrown","mouthFrownLeft","mouthFrownRight","hasPucker","mouthPucker","expressionMorphMap","eyeBlinkLeft","eyeBlinkRight","eyeWideLeft","eyeWideRight","eyeSquintLeft","eyeSquintRight","eyebrowRaiseLeft","eyebrowRaiseRight","eyebrowFurrow","browDownLeft","browDownRight","browInnerUp","mouthFrown","mouthOpen","mouthPress","mouthPressLeft","mouthPressRight","mouthUpperUpLeft","mouthUpperUpRight","mouthLowerDown","mouthStretchLeft","mouthStretchRight","mouthDimpleLeft","mouthDimpleRight","jawLeft","jawRight","jawForward","cheekPuff","cheekSquintLeft","cheekSquintRight","noseSneerLeft","noseSneerRight","tongueOut","_ref3","targetName","mouthOpenReduction","targetValue","amplification","amplifiedValue","min","applyBilateral","leftExpName","rightExpName","rightPossible","leftTarget","rightTarget","leftIndex","rightIndex","leftValue","rightValue","maxValue","max","_meshAny$parent","meshVisible","meshPosition","meshScale","parentVisible","parent","sceneVisible","before","after","afterPosition","afterScale","equals","positionBefore","positionAfter","scaleBefore","scaleAfter","scaleVector","skinnedMeshCount","visibleMeshCount","_child$parent","_mesh$geometry","geometry","geometryBounds","boundingBox","materialOpacity","materialTransparent","groupRef","clonedSceneChildren","groupPos","clonedPos","clonedScale","hasInvalidValues","isFinite","clonedPosition","_jsx","_jsxs","args","color","ref","object","PI","receiveShadow","box","setFromObject","center","size","getCenter","getSize","copy","wireframe"],"sourceRoot":""}