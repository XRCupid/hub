{"version":3,"file":"static/js/5361.6a0b91e6.chunk.js","mappings":"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","sources":["components/FullBodyAvatar.tsx"],"sourcesContent":["import React, { useRef, useEffect, useState, useMemo } from 'react';\nimport { useGLTF, useAnimations } from '@react-three/drei';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { MathUtils } from 'three';\nimport { TrackingData, PostureData } from '../types/tracking';\n\ninterface FullBodyAvatarProps {\n  avatarUrl: string;\n  trackingData?: TrackingData | null;\n  postureData?: PostureData | null;\n  position?: [number, number, number];\n  scale?: number;\n}\n\nconst FullBodyAvatar: React.FC<FullBodyAvatarProps> = ({ \n  avatarUrl, \n  trackingData,\n  postureData,\n  position = [0, 0, 0],\n  scale = 1\n}) => {\n  const groupRef = useRef<THREE.Group>(null);\n  const { scene } = useGLTF(avatarUrl);\n  \n  // Clone the scene to avoid modifying the cached version\n  const clonedScene = useMemo(() => scene.clone(), [scene]);\n  \n  // Bone references\n  const headBone = useRef<THREE.Bone | null>(null);\n  const leftShoulderBone = useRef<THREE.Bone | null>(null);\n  const rightShoulderBone = useRef<THREE.Bone | null>(null);\n  const leftArmBone = useRef<THREE.Bone | null>(null);\n  const rightArmBone = useRef<THREE.Bone | null>(null);\n  const leftForeArmBone = useRef<THREE.Bone | null>(null);\n  const rightForeArmBone = useRef<THREE.Bone | null>(null);\n  \n  // Store initial bone rotations (T-pose)\n  const initialRotations = useRef<{[key: string]: THREE.Quaternion}>({});\n  const initialEulers = useRef<{[key: string]: THREE.Euler}>({});\n  \n  // Morph target references\n  const morphTargetMeshes = useRef<THREE.SkinnedMesh[]>([]);\n  \n  // Frame counter for debugging\n  const frameCount = useRef(0);\n  \n  // Debug flag\n  const debugBonesFound = useRef(false);\n\n  // Debug spheres for keypoints\n  const debugSpheres = useRef<{[key: string]: THREE.Mesh}>({});\n  const [debugMode] = useState(true); // Enable debug mode\n\n  // Animation state\n  const poseInitialized = useRef(false);\n  const idlePoseTimer = useRef<number>(0);\n  \n  // Idle pose rotations (arms slightly down and forward)\n  const idlePose = {\n    leftArm: new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, -Math.PI / 4)), // 45 degrees down\n    rightArm: new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, Math.PI / 4)), // 45 degrees down\n    leftForeArm: new THREE.Euler(0, 0, -Math.PI / 8), // Slight bend\n    rightForeArm: new THREE.Euler(0, 0, Math.PI / 8) // Slight bend\n  };\n\n  // Find bones and morph targets\n  useEffect(() => {\n    if (!clonedScene) return;\n    \n    const meshes: THREE.SkinnedMesh[] = [];\n    \n    clonedScene.traverse((child) => {\n      if (child instanceof THREE.Bone) {\n        const name = child.name.toLowerCase();\n        console.log('[FullBodyAvatar] Found bone:', child.name);\n        \n        // Head\n        if (name.includes('head') && !name.includes('headtop')) {\n          headBone.current = child;\n        }\n        \n        // Shoulders\n        if (name.includes('leftshoulder') || name.includes('shoulder_l')) {\n          leftShoulderBone.current = child;\n        }\n        if (name.includes('rightshoulder') || name.includes('shoulder_r')) {\n          rightShoulderBone.current = child;\n        }\n        \n        // Arms (upper arm)\n        if ((name.includes('leftarm') || name.includes('arm_l') || name.includes('leftupperarm') || name.includes('upperarm_l')) && !name.includes('fore')) {\n          leftArmBone.current = child;\n          initialRotations.current['leftArm'] = child.quaternion.clone();\n          initialEulers.current['leftArm'] = child.rotation.clone();\n        }\n        if ((name.includes('rightarm') || name.includes('arm_r') || name.includes('rightupperarm') || name.includes('upperarm_r')) && !name.includes('fore')) {\n          rightArmBone.current = child;\n          initialRotations.current['rightArm'] = child.quaternion.clone();\n          initialEulers.current['rightArm'] = child.rotation.clone();\n        }\n        \n        // Forearms\n        if (name.includes('leftforearm') || name.includes('forearm_l') || name.includes('leftlowerarm') || name.includes('lowerarm_l')) {\n          leftForeArmBone.current = child;\n          initialRotations.current['leftForeArm'] = child.quaternion.clone();\n          initialEulers.current['leftForeArm'] = child.rotation.clone();\n        }\n        if (name.includes('rightforearm') || name.includes('forearm_r') || name.includes('rightlowerarm') || name.includes('lowerarm_r')) {\n          rightForeArmBone.current = child;\n          initialRotations.current['rightForeArm'] = child.quaternion.clone();\n          initialEulers.current['rightForeArm'] = child.rotation.clone();\n        }\n      }\n      \n      // Find meshes with morph targets\n      if (child instanceof THREE.SkinnedMesh && child.morphTargetDictionary) {\n        meshes.push(child);\n      }\n    });\n    \n    morphTargetMeshes.current = meshes;\n    \n    console.log('[FullBodyAvatar] Bone mapping complete:', {\n      head: !!headBone.current,\n      leftShoulder: !!leftShoulderBone.current,\n      rightShoulder: !!rightShoulderBone.current,\n      leftArm: !!leftArmBone.current,\n      rightArm: !!rightArmBone.current,\n      leftForeArm: !!leftForeArmBone.current,\n      rightForeArm: !!rightForeArmBone.current,\n      morphTargetMeshes: meshes.length\n    });\n    \n    console.log('[FullBodyAvatar] Bones found:', {\n      head: headBone.current?.name,\n      leftArm: leftArmBone.current?.name,\n      rightArm: rightArmBone.current?.name,\n      leftForeArm: leftForeArmBone.current?.name,\n      rightForeArm: rightForeArmBone.current?.name\n    });\n    \n    console.log('[FullBodyAvatar] Initial rotations:', {\n      leftArm: initialRotations.current['leftArm'] ? {\n        quaternion: initialRotations.current['leftArm'].toArray().map(v => v.toFixed(3)),\n        euler: initialEulers.current['leftArm'] ? [\n          (initialEulers.current['leftArm'].x * 180 / Math.PI).toFixed(1),\n          (initialEulers.current['leftArm'].y * 180 / Math.PI).toFixed(1),\n          (initialEulers.current['leftArm'].z * 180 / Math.PI).toFixed(1)\n        ] : null\n      } : null,\n      rightArm: initialRotations.current['rightArm'] ? {\n        quaternion: initialRotations.current['rightArm'].toArray().map(v => v.toFixed(3)),\n        euler: initialEulers.current['rightArm'] ? [\n          (initialEulers.current['rightArm'].x * 180 / Math.PI).toFixed(1),\n          (initialEulers.current['rightArm'].y * 180 / Math.PI).toFixed(1),\n          (initialEulers.current['rightArm'].z * 180 / Math.PI).toFixed(1)\n        ] : null\n      } : null\n    });\n    \n    if (!debugBonesFound.current) {\n      console.log('[FullBodyAvatar] Bone search results:', {\n        head: headBone.current?.name || 'NOT FOUND',\n        leftShoulder: leftShoulderBone.current?.name || 'NOT FOUND',\n        rightShoulder: rightShoulderBone.current?.name || 'NOT FOUND',\n        leftArm: leftArmBone.current?.name || 'NOT FOUND',\n        rightArm: rightArmBone.current?.name || 'NOT FOUND',\n        leftForeArm: leftForeArmBone.current?.name || 'NOT FOUND',\n        rightForeArm: rightForeArmBone.current?.name || 'NOT FOUND'\n      });\n      \n      // List all bones in the model\n      const allBones: string[] = [];\n      clonedScene.traverse((child) => {\n        if (child instanceof THREE.Bone) {\n          allBones.push(child.name);\n        }\n      });\n      console.log('[FullBodyAvatar] All bones in model:', allBones);\n      \n      debugBonesFound.current = true;\n    }\n    \n    // Create debug spheres\n    if (debugMode) {\n      const sphereGeometry = new THREE.SphereGeometry(0.05, 16, 16);\n      const materials = {\n        shoulder: new THREE.MeshBasicMaterial({ color: 0xff0000 }),\n        elbow: new THREE.MeshBasicMaterial({ color: 0x00ff00 }),\n        wrist: new THREE.MeshBasicMaterial({ color: 0x0000ff })\n      };\n      \n      // Create spheres for each keypoint\n      const keypointNames = ['leftShoulder', 'leftElbow', 'leftWrist', 'rightShoulder', 'rightElbow', 'rightWrist'];\n      keypointNames.forEach(name => {\n        const material = name.includes('Shoulder') ? materials.shoulder :\n                        name.includes('Elbow') ? materials.elbow : materials.wrist;\n        const sphere = new THREE.Mesh(sphereGeometry, material);\n        sphere.visible = false;\n        clonedScene.add(sphere);\n        debugSpheres.current[name] = sphere;\n      });\n    }\n  }, [clonedScene, debugMode]);\n  \n  // Apply tracking data every frame\n  useFrame((state, delta) => {\n    if (!groupRef.current) return;\n    \n    // Debug log every 60 frames\n    frameCount.current++;\n    if (frameCount.current % 60 === 0) {\n      // Check if we're getting posture data from the service\n      if (postureData) {\n        console.log('[FullBodyAvatar] PostureData from service:', postureData);\n        console.log('[FullBodyAvatar] PostureData keypoints detail:', postureData.keypoints);\n      }\n      \n      // Check tracking data posture\n      if (trackingData?.posture) {\n        console.log('[FullBodyAvatar] TrackingData posture:', trackingData.posture);\n        console.log('[FullBodyAvatar] TrackingData keypoints detail:', trackingData.posture.keypoints);\n      }\n    }\n    \n    // Apply head rotation from face tracking\n    if (trackingData?.headRotation && headBone.current) {\n      const { pitch, yaw, roll } = trackingData.headRotation;\n      \n      // Apply rotation\n      headBone.current.rotation.x = MathUtils.degToRad(pitch * 0.5);\n      headBone.current.rotation.y = MathUtils.degToRad(-yaw * 0.6);\n      headBone.current.rotation.z = MathUtils.degToRad(-roll * 0.3);\n    }\n    \n    // Try to get posture keypoints from either source\n    const keypoints = postureData?.keypoints || trackingData?.posture?.keypoints;\n    \n    if (keypoints) {\n      // Log keypoint data every second\n      if (frameCount.current % 60 === 0) {\n        console.log('[FullBodyAvatar] Using keypoints:', keypoints);\n      }\n      \n      // Get video dimensions from the posture tracking service\n      const videoWidth = 640; // Default video width\n      const videoHeight = 480; // Default video height\n      \n      // Simple arm tracking - LEFT ARM\n      const leftShoulder = keypoints.leftShoulder;\n      const leftElbow = keypoints.leftElbow;\n      const leftWrist = keypoints.leftWrist;\n      \n      // Try different combinations of keypoints\n      if (leftShoulder && leftShoulder.confidence > 0.05) {\n        const normalizedLeftShoulder = {\n          x: leftShoulder.x / videoWidth,\n          y: leftShoulder.y / videoHeight\n        };\n        \n        // Case 1: All three keypoints available\n        if (leftWrist && leftWrist.confidence > 0.05 && leftElbow && leftElbow.confidence > 0.05) {\n          // Normalize coordinates (PoseNet gives pixel coordinates)\n          const normalizedLeftWrist = {\n            x: leftWrist.x / videoWidth,\n            y: leftWrist.y / videoHeight\n          };\n          const normalizedLeftElbow = {\n            x: leftElbow.x / videoWidth,\n            y: leftElbow.y / videoHeight\n          };\n          \n          // Log normalized coordinates\n          if (frameCount.current % 60 === 0) {\n            console.log('[FullBodyAvatar] Left arm normalized coords:', {\n              wrist: normalizedLeftWrist,\n              elbow: normalizedLeftElbow,\n              shoulder: normalizedLeftShoulder\n            });\n          }\n          \n          // Convert 2D normalized coordinates to 3D positions\n          const shoulderPos = new THREE.Vector3(\n            (normalizedLeftShoulder.x - 0.5) * 2,\n            -(normalizedLeftShoulder.y - 0.5) * 2,\n            0\n          );\n          const elbowPos = new THREE.Vector3(\n            (normalizedLeftElbow.x - 0.5) * 2,\n            -(normalizedLeftElbow.y - 0.5) * 2,\n            0.2  // Add some depth\n          );\n          const wristPos = new THREE.Vector3(\n            (normalizedLeftWrist.x - 0.5) * 2,\n            -(normalizedLeftWrist.y - 0.5) * 2,\n            0.3  // Add more depth\n          );\n          \n          // Update debug spheres\n          if (debugSpheres.current) {\n            if (debugSpheres.current.leftShoulder) {\n              debugSpheres.current.leftShoulder.position.copy(shoulderPos);\n              debugSpheres.current.leftShoulder.position.multiplyScalar(50); // Scale up for visibility\n              debugSpheres.current.leftShoulder.visible = true;\n            }\n            if (debugSpheres.current.leftElbow) {\n              debugSpheres.current.leftElbow.position.copy(elbowPos);\n              debugSpheres.current.leftElbow.position.multiplyScalar(50);\n              debugSpheres.current.leftElbow.visible = true;\n            }\n            if (debugSpheres.current.leftWrist) {\n              debugSpheres.current.leftWrist.position.copy(wristPos);\n              debugSpheres.current.leftWrist.position.multiplyScalar(50);\n              debugSpheres.current.leftWrist.visible = true;\n            }\n          }\n          \n          // Apply IK to upper arm\n          if (leftArmBone.current) {\n            const upperArmDir = elbowPos.clone().sub(shoulderPos).normalize();\n            const upperArmRotation = new THREE.Quaternion();\n            \n            // For T-pose avatars, arms point outward (along X axis)\n            // Calculate rotation from the T-pose direction to target direction\n            const tPoseDirection = new THREE.Vector3(-1, 0, 0); // Left arm points left in T-pose\n            upperArmRotation.setFromUnitVectors(tPoseDirection, upperArmDir);\n            \n            // Combine with initial rotation\n            const finalRotation = initialRotations.current['leftArm'] ? \n              initialRotations.current['leftArm'].clone().multiply(upperArmRotation) : \n              upperArmRotation;\n            \n            // Apply with damping\n            leftArmBone.current.quaternion.slerp(finalRotation, 0.3);\n          }\n          \n          // Apply elbow bend\n          if (leftForeArmBone.current && leftArmBone.current) {\n            const upperArmVector = elbowPos.clone().sub(shoulderPos);\n            const forearmVector = wristPos.clone().sub(elbowPos);\n            \n            // Calculate angle between upper arm and forearm\n            const angle = upperArmVector.angleTo(forearmVector);\n            const bendAngle = Math.PI - angle;\n            \n            // For T-pose, we need to apply the bend relative to the initial rotation\n            // Reset to initial rotation first\n            if (initialEulers.current['leftForeArm']) {\n              leftForeArmBone.current.rotation.copy(initialEulers.current['leftForeArm']);\n            }\n            \n            // Apply rotation on local Z axis for elbow bend (negative for proper direction)\n            leftForeArmBone.current.rotation.z -= Math.min(bendAngle * 0.8, Math.PI * 0.8);\n            \n            // Log IK calculations\n            if (frameCount.current % 60 === 0) {\n              console.log('[FullBodyAvatar] Left arm IK:', {\n                angle: (angle * 180 / Math.PI).toFixed(1),\n                bendAngle: (bendAngle * 180 / Math.PI).toFixed(1),\n                appliedBend: (leftForeArmBone.current.rotation.z * 180 / Math.PI).toFixed(1)\n              });\n            }\n          }\n        }\n        // Case 2: Only shoulder and wrist (no elbow)\n        else if (leftWrist && leftWrist.confidence > 0.05 && leftArmBone.current) {\n          const normalizedLeftWrist = {\n            x: leftWrist.x / videoWidth,\n            y: leftWrist.y / videoHeight\n          };\n          \n          // Direct shoulder to wrist direction\n          const shoulderPos = new THREE.Vector3(\n            (normalizedLeftShoulder.x - 0.5) * 2,\n            -(normalizedLeftShoulder.y - 0.5) * 2,\n            0\n          );\n          const wristPos = new THREE.Vector3(\n            (normalizedLeftWrist.x - 0.5) * 2,\n            -(normalizedLeftWrist.y - 0.5) * 2,\n            0.4\n          );\n          \n          // Update debug spheres\n          if (debugSpheres.current) {\n            if (debugSpheres.current.leftShoulder) {\n              debugSpheres.current.leftShoulder.position.copy(shoulderPos);\n              debugSpheres.current.leftShoulder.position.multiplyScalar(50); // Scale up for visibility\n              debugSpheres.current.leftShoulder.visible = true;\n            }\n            if (debugSpheres.current.leftWrist) {\n              debugSpheres.current.leftWrist.position.copy(wristPos);\n              debugSpheres.current.leftWrist.position.multiplyScalar(50);\n              debugSpheres.current.leftWrist.visible = true;\n            }\n            if (debugSpheres.current.leftElbow) {\n              debugSpheres.current.leftElbow.visible = false;\n            }\n          }\n          \n          const armDir = wristPos.clone().sub(shoulderPos).normalize();\n          const armRotation = new THREE.Quaternion();\n          \n          // For T-pose avatars, arms point outward\n          const tPoseDirection = new THREE.Vector3(-1, 0, 0); // Left arm points left\n          armRotation.setFromUnitVectors(tPoseDirection, armDir);\n          \n          // Combine with initial rotation\n          const finalRotation = initialRotations.current['leftArm'] ? \n            initialRotations.current['leftArm'].clone().multiply(armRotation) : \n            armRotation;\n          \n          leftArmBone.current.quaternion.slerp(finalRotation, 0.2);\n          \n          if (frameCount.current % 60 === 0) {\n            console.log('[FullBodyAvatar] Left arm (shoulder-wrist only):', {\n              shoulderPos: shoulderPos.toArray().map(v => v.toFixed(2)),\n              wristPos: wristPos.toArray().map(v => v.toFixed(2)),\n              armDir: armDir.toArray().map(v => v.toFixed(2))\n            });\n          }\n        }\n        // Case 3: Only shoulder - apply default pose\n        else if (leftArmBone.current) {\n          // Slowly return to T-pose\n          const defaultRotation = initialRotations.current['leftArm'] || new THREE.Quaternion();\n          leftArmBone.current.quaternion.slerp(defaultRotation, 0.05);\n          \n          if (leftForeArmBone.current) {\n            // Return forearm to initial rotation\n            if (initialEulers.current['leftForeArm']) {\n              const currentRotation = leftForeArmBone.current.rotation.clone();\n              const targetRotation = initialEulers.current['leftForeArm'];\n              leftForeArmBone.current.rotation.x = THREE.MathUtils.lerp(currentRotation.x, targetRotation.x, 0.05);\n              leftForeArmBone.current.rotation.y = THREE.MathUtils.lerp(currentRotation.y, targetRotation.y, 0.05);\n              leftForeArmBone.current.rotation.z = THREE.MathUtils.lerp(currentRotation.z, targetRotation.z, 0.05);\n            }\n          }\n          \n          // Update debug spheres\n          if (debugSpheres.current) {\n            if (debugSpheres.current.leftShoulder) {\n              debugSpheres.current.leftShoulder.visible = false;\n            }\n            if (debugSpheres.current.leftElbow) {\n              debugSpheres.current.leftElbow.visible = false;\n            }\n            if (debugSpheres.current.leftWrist) {\n              debugSpheres.current.leftWrist.visible = false;\n            }\n          }\n        }\n      }\n      \n      // Right arm tracking\n      if (postureData && postureData.keypoints.rightShoulder) {\n        const rightShoulder = postureData.keypoints.rightShoulder;\n        const rightElbow = postureData.keypoints.rightElbow;\n        const rightWrist = postureData.keypoints.rightWrist;\n        \n        if (rightShoulder.confidence > 0.05) {\n          const normalizedRightShoulder = {\n            x: rightShoulder.x / 640,\n            y: rightShoulder.y / 480\n          };\n          \n          // Case 1: All three keypoints available\n          if (rightWrist && rightWrist.confidence > 0.05 && rightElbow && rightElbow.confidence > 0.05) {\n            // Normalize coordinates (assuming 640x480 video)\n            const normalizedRightWrist = {\n              x: rightWrist.x / 640,\n              y: rightWrist.y / 480\n            };\n            const normalizedRightElbow = {\n              x: rightElbow.x / 640,\n              y: rightElbow.y / 480\n            };\n            \n            // Log normalized coordinates\n            if (frameCount.current % 60 === 0) {\n              console.log('[FullBodyAvatar] Right arm normalized coords:', {\n                wrist: normalizedRightWrist,\n                elbow: normalizedRightElbow,\n                shoulder: normalizedRightShoulder\n              });\n            }\n            \n            // Apply proper 3D IK for right arm\n            if (rightArmBone.current) {\n              // Convert 2D positions to 3D world positions\n              const shoulderPos = new THREE.Vector3(\n                (normalizedRightShoulder.x - 0.5) * 2,\n                -(normalizedRightShoulder.y - 0.5) * 2,\n                0\n              );\n              const elbowPos = new THREE.Vector3(\n                (normalizedRightElbow.x - 0.5) * 2,\n                -(normalizedRightElbow.y - 0.5) * 2,\n                0.2\n              );\n              const wristPos = new THREE.Vector3(\n                (normalizedRightWrist.x - 0.5) * 2,\n                -(normalizedRightWrist.y - 0.5) * 2,\n                0.3\n              );\n              \n              // Update debug spheres\n              if (debugSpheres.current) {\n                if (debugSpheres.current.rightShoulder) {\n                  debugSpheres.current.rightShoulder.position.copy(shoulderPos);\n                  debugSpheres.current.rightShoulder.position.multiplyScalar(50); // Scale up for visibility\n                  debugSpheres.current.rightShoulder.visible = true;\n                }\n                if (debugSpheres.current.rightElbow) {\n                  debugSpheres.current.rightElbow.position.copy(elbowPos);\n                  debugSpheres.current.rightElbow.position.multiplyScalar(50);\n                  debugSpheres.current.rightElbow.visible = true;\n                }\n                if (debugSpheres.current.rightWrist) {\n                  debugSpheres.current.rightWrist.position.copy(wristPos);\n                  debugSpheres.current.rightWrist.position.multiplyScalar(50);\n                  debugSpheres.current.rightWrist.visible = true;\n                }\n              }\n              \n              // Calculate upper arm direction\n              const upperArmDir = elbowPos.clone().sub(shoulderPos).normalize();\n              \n              // Calculate rotation for upper arm\n              const upperArmRotation = new THREE.Quaternion();\n              \n              // For T-pose avatars, right arm points right (along positive X axis)\n              const tPoseDirection = new THREE.Vector3(1, 0, 0); // Right arm points right in T-pose\n              upperArmRotation.setFromUnitVectors(tPoseDirection, upperArmDir);\n              \n              // Combine with initial rotation\n              const finalRotation = initialRotations.current['rightArm'] ? \n                initialRotations.current['rightArm'].clone().multiply(upperArmRotation) : \n                upperArmRotation;\n              \n              // Apply rotation with damping\n              rightArmBone.current.quaternion.slerp(finalRotation, 0.3);\n              \n              // Apply elbow bend\n              if (rightForeArmBone.current) {\n                const upperArmVector = elbowPos.clone().sub(shoulderPos);\n                const forearmVector = wristPos.clone().sub(elbowPos);\n                \n                const angle = upperArmVector.angleTo(forearmVector);\n                const bendAngle = Math.PI - angle;\n                \n                // For T-pose, we need to apply the bend relative to the initial rotation\n                // Reset to initial rotation first\n                if (initialEulers.current['rightForeArm']) {\n                  rightForeArmBone.current.rotation.copy(initialEulers.current['rightForeArm']);\n                }\n                \n                // Apply rotation on local Z axis for elbow bend (positive for right arm)\n                rightForeArmBone.current.rotation.z += Math.min(bendAngle * 0.8, Math.PI * 0.8);\n                \n                if (frameCount.current % 60 === 0) {\n                  console.log('[FullBodyAvatar] Right arm IK:', {\n                    angle: (angle * 180 / Math.PI).toFixed(1),\n                    bendAngle: (bendAngle * 180 / Math.PI).toFixed(1),\n                    appliedBend: (rightForeArmBone.current.rotation.z * 180 / Math.PI).toFixed(1)\n                  });\n                }\n              }\n            }\n          }\n          // Case 2: Only shoulder and wrist (no elbow)\n          else if (rightWrist && rightWrist.confidence > 0.05 && rightArmBone.current) {\n            const normalizedRightWrist = {\n              x: rightWrist.x / 640,\n              y: rightWrist.y / 480\n            };\n            \n            const shoulderPos = new THREE.Vector3(\n              (normalizedRightShoulder.x - 0.5) * 2,\n              -(normalizedRightShoulder.y - 0.5) * 2,\n              0\n            );\n            const wristPos = new THREE.Vector3(\n              (normalizedRightWrist.x - 0.5) * 2,\n              -(normalizedRightWrist.y - 0.5) * 2,\n              0.4\n            );\n            \n            // Update debug spheres\n            if (debugSpheres.current) {\n              if (debugSpheres.current.rightShoulder) {\n                debugSpheres.current.rightShoulder.position.copy(shoulderPos);\n                debugSpheres.current.rightShoulder.position.multiplyScalar(50); // Scale up for visibility\n                debugSpheres.current.rightShoulder.visible = true;\n              }\n              if (debugSpheres.current.rightWrist) {\n                debugSpheres.current.rightWrist.position.copy(wristPos);\n                debugSpheres.current.rightWrist.position.multiplyScalar(50);\n                debugSpheres.current.rightWrist.visible = true;\n              }\n              if (debugSpheres.current.rightElbow) {\n                debugSpheres.current.rightElbow.visible = false;\n              }\n            }\n            \n            const armDir = wristPos.clone().sub(shoulderPos).normalize();\n            const armRotation = new THREE.Quaternion();\n            \n            // For T-pose avatars, right arm points right\n            const tPoseDirection = new THREE.Vector3(1, 0, 0); // Right arm points right\n            armRotation.setFromUnitVectors(tPoseDirection, armDir);\n            \n            // Combine with initial rotation\n            const finalRotation = initialRotations.current['rightArm'] ? \n              initialRotations.current['rightArm'].clone().multiply(armRotation) : \n              armRotation;\n            \n            rightArmBone.current.quaternion.slerp(finalRotation, 0.2);\n            \n            if (frameCount.current % 60 === 0) {\n              console.log('[FullBodyAvatar] Right arm (shoulder-wrist only):', {\n                shoulderPos: shoulderPos.toArray().map(v => v.toFixed(2)),\n                wristPos: wristPos.toArray().map(v => v.toFixed(2)),\n                armDir: armDir.toArray().map(v => v.toFixed(2))\n              });\n            }\n          }\n          // Case 3: Only shoulder - apply default pose\n          else if (rightArmBone.current) {\n            const defaultRotation = initialRotations.current['rightArm'] || new THREE.Quaternion();\n            rightArmBone.current.quaternion.slerp(defaultRotation, 0.05);\n            \n            if (rightForeArmBone.current) {\n              // Return forearm to initial rotation\n              if (initialEulers.current['rightForeArm']) {\n                const currentRotation = rightForeArmBone.current.rotation.clone();\n                const targetRotation = initialEulers.current['rightForeArm'];\n                rightForeArmBone.current.rotation.x = THREE.MathUtils.lerp(currentRotation.x, targetRotation.x, 0.05);\n                rightForeArmBone.current.rotation.y = THREE.MathUtils.lerp(currentRotation.y, targetRotation.y, 0.05);\n                rightForeArmBone.current.rotation.z = THREE.MathUtils.lerp(currentRotation.z, targetRotation.z, 0.05);\n              }\n            }\n            \n            // Update debug spheres\n            if (debugSpheres.current) {\n              if (debugSpheres.current.rightShoulder) {\n                debugSpheres.current.rightShoulder.visible = false;\n              }\n              if (debugSpheres.current.rightElbow) {\n                debugSpheres.current.rightElbow.visible = false;\n              }\n              if (debugSpheres.current.rightWrist) {\n                debugSpheres.current.rightWrist.visible = false;\n              }\n            }\n          }\n        }\n      }\n    } else {\n      // Log when no keypoints are available\n      if (frameCount.current % 60 === 0) {\n        console.log('[FullBodyAvatar] No keypoints available');\n      }\n    }\n    \n    // Apply facial expressions\n    if (trackingData?.expressions && morphTargetMeshes.current.length > 0) {\n      const expressions = trackingData.expressions;\n      morphTargetMeshes.current.forEach(mesh => {\n        if (!mesh.morphTargetDictionary || !mesh.morphTargetInfluences) return;\n        \n        Object.entries(expressions).forEach(([expression, value]) => {\n          const index = mesh.morphTargetDictionary![expression];\n          if (index !== undefined && mesh.morphTargetInfluences) {\n            mesh.morphTargetInfluences[index] = value * 1.5; // Amplify\n          }\n        });\n      });\n    }\n    \n    // Idle pose system\n    if (!poseInitialized.current) {\n      idlePoseTimer.current += delta;\n      if (idlePoseTimer.current > 2) {\n        poseInitialized.current = true;\n      }\n    }\n    \n    if (poseInitialized.current) {\n      if (leftArmBone.current) {\n        leftArmBone.current.quaternion.slerp(idlePose.leftArm, 0.05);\n      }\n      if (rightArmBone.current) {\n        rightArmBone.current.quaternion.slerp(idlePose.rightArm, 0.05);\n      }\n      if (leftForeArmBone.current) {\n        leftForeArmBone.current.rotation.z = THREE.MathUtils.lerp(leftForeArmBone.current.rotation.z, idlePose.leftForeArm.z, 0.05);\n      }\n      if (rightForeArmBone.current) {\n        rightForeArmBone.current.rotation.z = THREE.MathUtils.lerp(rightForeArmBone.current.rotation.z, idlePose.rightForeArm.z, 0.05);\n      }\n    }\n  });\n  \n  return (\n    <group ref={groupRef} position={position} scale={scale}>\n      <primitive object={clonedScene} />\n    </group>\n  );\n};\n\nexport default FullBodyAvatar;\n"],"names":["_ref","avatarUrl","trackingData","postureData","position","scale","groupRef","useRef","scene","useGLTF","clonedScene","useMemo","clone","headBone","leftShoulderBone","rightShoulderBone","leftArmBone","rightArmBone","leftForeArmBone","rightForeArmBone","initialRotations","initialEulers","morphTargetMeshes","frameCount","debugBonesFound","debugSpheres","debugMode","useState","poseInitialized","idlePoseTimer","idlePose","leftArm","THREE","setFromEuler","Math","PI","rightArm","leftForeArm","rightForeArm","useEffect","_headBone$current","_leftArmBone$current","_rightArmBone$current","_leftForeArmBone$curr","_rightForeArmBone$cur","meshes","traverse","child","name","toLowerCase","console","log","includes","current","quaternion","rotation","morphTargetDictionary","push","head","leftShoulder","rightShoulder","length","toArray","map","v","toFixed","euler","x","y","z","_headBone$current2","_leftShoulderBone$cur","_rightShoulderBone$cu","_leftArmBone$current2","_rightArmBone$current2","_leftForeArmBone$curr2","_rightForeArmBone$cur2","allBones","sphereGeometry","materials","shoulder","color","elbow","wrist","forEach","material","sphere","visible","add","useFrame","state","delta","_trackingData$posture","keypoints","posture","headRotation","pitch","yaw","roll","MathUtils","degToRad","videoWidth","videoHeight","leftElbow","leftWrist","confidence","normalizedLeftShoulder","normalizedLeftWrist","normalizedLeftElbow","shoulderPos","elbowPos","wristPos","copy","multiplyScalar","upperArmDir","sub","normalize","upperArmRotation","tPoseDirection","setFromUnitVectors","finalRotation","multiply","slerp","upperArmVector","forearmVector","angle","angleTo","bendAngle","min","appliedBend","armDir","armRotation","defaultRotation","currentRotation","targetRotation","lerp","rightElbow","rightWrist","normalizedRightShoulder","normalizedRightWrist","normalizedRightElbow","expressions","mesh","morphTargetInfluences","Object","entries","_ref2","expression","value","index","undefined","_jsx","ref","children","object"],"sourceRoot":""}