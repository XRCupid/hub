{"version":3,"file":"static/js/6583.72900196.chunk.js","mappings":"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","sources":["components/SimulationAvatar.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { Avatar } from '@readyplayerme/visage';\n// Removed TalkingHeadAvatar import\n\n\n\nconst EMOTION_BLENDSHAPES = {\n  neutral: {\n    eyeBlinkLeft: 0.1,\n    eyeBlinkRight: 0.1,\n    browInnerUp: 0,\n    browDownLeft: 0,\n    browDownRight: 0,\n    jawOpen: 0,\n    mouthSmileLeft: 0,\n    mouthSmileRight: 0,\n    mouthFrownLeft: 0,\n    mouthFrownRight: 0,\n    cheekPuffLeft: 0,\n    cheekPuffRight: 0\n  },\n  happy: { \n    eyeBlinkLeft: 0.05,\n    eyeBlinkRight: 0.05,\n    mouthSmileLeft: 0.8, \n    mouthSmileRight: 0.8,\n    browInnerUp: 0.4,\n    jawOpen: 0.2,\n    cheekPuffLeft: 0.3,\n    cheekPuffRight: 0.3\n  },\n  sad: { \n    eyeBlinkLeft: 0.5,\n    eyeBlinkRight: 0.5,\n    mouthFrownLeft: 0.7, \n    mouthFrownRight: 0.7,\n    browDownLeft: 0.6,\n    browDownRight: 0.6,\n    jawOpen: 0.3,\n    cheekPuffLeft: 0.1,\n    cheekPuffRight: 0.1\n  },\n  surprised: { \n    eyeWideLeft: 0.7,\n    eyeWideRight: 0.7,\n    jawOpen: 0.7,\n    browInnerUp: 0.8,\n    mouthOpen: 0.5,\n    cheekPuffLeft: 0.2,\n    cheekPuffRight: 0.2\n  },\n  angry: {\n    browDownLeft: 0.8,\n    browDownRight: 0.8,\n    mouthPressLeft: 0.6,\n    mouthPressRight: 0.6,\n    eyeBlinkLeft: 0.4,\n    eyeBlinkRight: 0.4,\n    jawOpen: 0.3,\n    mouthFrownLeft: 0.5,\n    mouthFrownRight: 0.5\n  }\n};\n\nconst SimulationAvatar = ({ \n  type = 'coach',\n  avatarUrl = 'https://models.readyplayer.me/681d6cd903879b2f11528470.glb',\n  ttsApiKey = null,\n  gazeWander = false, // NEW: enable subtle randomized gaze\n  textToSpeak = '' // NEW: if provided, avatar will speak this text\n}) => {\n  console.log('[DEBUG] SimulationAvatar mounted');\n  const [emotion, setEmotion] = useState('neutral');\n  const [blendShapes, setBlendShapes] = useState({});\n  const audioContextRef = useRef(null);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n  const utteranceRef = useRef(null); // Track the current utterance for cleanup\n\n  // --- Speech synthesis effect ---\n  useEffect(() => {\n    if (!textToSpeak || typeof window === 'undefined' || !window.speechSynthesis) return;\n    // Cancel any previous utterance\n    if (utteranceRef.current) {\n      window.speechSynthesis.cancel();\n      utteranceRef.current = null;\n    }\n    const utter = new window.SpeechSynthesisUtterance(textToSpeak);\n    utter.onstart = () => setIsSpeaking(true);\n    utter.onend = () => setIsSpeaking(false);\n    utter.onerror = () => setIsSpeaking(false);\n    utteranceRef.current = utter;\n    window.speechSynthesis.speak(utter);\n    return () => {\n      if (utteranceRef.current) {\n        window.speechSynthesis.cancel();\n        utteranceRef.current = null;\n      }\n    };\n  }, [textToSpeak]);\n  const avatarRef = useRef(null);\n  const morphMeshRef = useRef(null); // Ref to mesh with morph targets\n\n  // --- Gaze wandering state ---\n  const [gazeTarget, setGazeTarget] = useState({\n    horizontal: 0, // -1 (left) to 1 (right)\n    vertical: 0    // -1 (down) to 1 (up)\n  });\n  const gazeCurrent = useRef({ horizontal: 0, vertical: 0 });\n  const gazeTimeout = useRef(null);\n\n  // Helper: Pick a new random gaze target (subtle wandering)\n  function pickRandomGazeTarget() {\n    // Small range: e.g., -0.2 to 0.2 for both axes\n    return {\n      horizontal: (Math.random() - 0.5) * 0.4, // -0.2 to +0.2\n      vertical: (Math.random() - 0.5) * 0.2   // -0.1 to +0.1\n    };\n  }\n\n  // Gaze wandering effect\n  useEffect(() => {\n    if (!gazeWander) return;\n    let active = true;\n    function loop() {\n      if (!active) return;\n      setGazeTarget(pickRandomGazeTarget());\n      gazeTimeout.current = setTimeout(loop, 1000 + Math.random() * 1000); // 1–2s\n    }\n    loop();\n    return () => {\n      active = false;\n      if (gazeTimeout.current) clearTimeout(gazeTimeout.current);\n    };\n  }, [gazeWander]);\n\n  // --- Procedural Speaking Animation & Blinking ---\n  useEffect(() => {\n    let blinkTimeout;\n    let blinkActive = false;\n    let speakingAnimationFrame;\n    let blinkValue = 0;\n    let blinkDirection = 1; // 1 = closing, -1 = opening\n    let jawPhase = Math.random() * Math.PI * 2;\n\n    function getEmotionBlendShapes() {\n      return EMOTION_BLENDSHAPES[emotion] || EMOTION_BLENDSHAPES.neutral;\n    }\n\n    function animateBlink() {\n      // Animate blink up and down (0 to 1 and back)\n      blinkValue += blinkDirection * 0.2;\n      if (blinkValue >= 1) {\n        blinkValue = 1;\n        blinkDirection = -1;\n      } else if (blinkValue <= 0) {\n        blinkValue = 0;\n        blinkDirection = 1;\n        blinkActive = false;\n        scheduleNextBlink();\n        return;\n      }\n      updateBlendShapes();\n      blinkTimeout = setTimeout(animateBlink, 40);\n    }\n\n    function scheduleNextBlink() {\n      // Blink every 2.5–5 seconds\n      const next = 2500 + Math.random() * 2500;\n      blinkTimeout = setTimeout(() => {\n        blinkActive = true;\n        blinkDirection = 1;\n        animateBlink();\n      }, next);\n    }\n\n    function updateBlendShapes() {\n      // Amplify emotion blendshapes for visibility\n      const rawBase = getEmotionBlendShapes();\n      const base = {};\n      for (const k in rawBase) {\n        // Amplify all blendshapes except blinks/jaw (which are handled separately)\n        if (k.startsWith('mouth') || k.startsWith('brow') || k.startsWith('cheek') || k.startsWith('eye') || k.startsWith('nose')) {\n          base[k] = Math.min(1.0, (rawBase[k] || 0) * 3.0);\n        } else {\n          base[k] = rawBase[k];\n        }\n      }\n      // Animate jawOpen if speaking\n      let jawOpen = base.jawOpen || 0;\n      if (isSpeaking) {\n        // Animate jaw with a sine wave (fast if speaking)\n        const now = performance.now() / 1000;\n        jawOpen = 0.3 + 0.2 * Math.abs(Math.sin(now * 6 + jawPhase));\n      }\n      // Animate blink\n      const eyeBlinkLeft = blinkActive ? blinkValue : base.eyeBlinkLeft || 0;\n      const eyeBlinkRight = blinkActive ? blinkValue : base.eyeBlinkRight || 0;\n\n      // --- Gaze wandering logic ---\n      let eyeLookInLeft = base.eyeLookInLeft || 0;\n      let eyeLookOutLeft = base.eyeLookOutLeft || 0;\n      let eyeLookUpLeft = base.eyeLookUpLeft || 0;\n      let eyeLookDownLeft = base.eyeLookDownLeft || 0;\n      let eyeLookInRight = base.eyeLookInRight || 0;\n      let eyeLookOutRight = base.eyeLookOutRight || 0;\n      let eyeLookUpRight = base.eyeLookUpRight || 0;\n      let eyeLookDownRight = base.eyeLookDownRight || 0;\n\n      if (gazeWander) {\n        // Smoothly interpolate current gaze toward target\n        const interp = (from, to, amt) => from + (to - from) * amt;\n        gazeCurrent.current.horizontal = interp(gazeCurrent.current.horizontal, gazeTarget.horizontal, 0.07);\n        gazeCurrent.current.vertical = interp(gazeCurrent.current.vertical, gazeTarget.vertical, 0.07);\n        // Map horizontal: negative = left, positive = right\n        // Map vertical: negative = down, positive = up\n        // ARKit: eyeLookIn = toward nose, eyeLookOut = away from nose\n        eyeLookInLeft = Math.max(0, -gazeCurrent.current.horizontal);\n        eyeLookOutLeft = Math.max(0, gazeCurrent.current.horizontal);\n        eyeLookInRight = Math.max(0, gazeCurrent.current.horizontal);\n        eyeLookOutRight = Math.max(0, -gazeCurrent.current.horizontal);\n        eyeLookUpLeft = Math.max(0, gazeCurrent.current.vertical);\n        eyeLookDownLeft = Math.max(0, -gazeCurrent.current.vertical);\n        eyeLookUpRight = Math.max(0, gazeCurrent.current.vertical);\n        eyeLookDownRight = Math.max(0, -gazeCurrent.current.vertical);\n      }\n\n      const finalBlendShapes = {\n        ...base,\n        jawOpen,\n        eyeBlinkLeft,\n        eyeBlinkRight,\n        eyeLookInLeft,\n        eyeLookOutLeft,\n        eyeLookUpLeft,\n        eyeLookDownLeft,\n        eyeLookInRight,\n        eyeLookOutRight,\n        eyeLookUpRight,\n        eyeLookDownRight\n      };\n      console.log('[EMOTION DEBUG] Amplified blendShapes:', finalBlendShapes);\n      setBlendShapes(finalBlendShapes);\n    }\n\n    // Speaking animation\n    function speakingLoop() {\n      updateBlendShapes();\n      speakingAnimationFrame = requestAnimationFrame(speakingLoop);\n    }\n\n    // Start loops\n    scheduleNextBlink();\n    speakingLoop();\n\n    return () => {\n      clearTimeout(blinkTimeout);\n      cancelAnimationFrame(speakingAnimationFrame);\n    };\n  }, [emotion, isSpeaking]);\n\n  useEffect(() => {\n    const initAudioAnalysis = async () => {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n        const audioContext = new AudioContext();\n        const analyser = audioContext.createAnalyser();\n        const source = audioContext.createMediaStreamSource(stream);\n        source.connect(analyser);\n\n        const checkAudioIntensity = () => {\n          const bufferLength = analyser.frequencyBinCount;\n          const dataArray = new Uint8Array(bufferLength);\n          analyser.getByteFrequencyData(dataArray);\n          \n          const volume = dataArray.reduce((a, b) => a + b) / bufferLength;\n          setIsSpeaking(volume > 10);\n\n          requestAnimationFrame(checkAudioIntensity);\n        };\n\n        checkAudioIntensity();\n      } catch (error) {\n        console.error('Audio capture error:', error);\n      }\n    };\n\n    initAudioAnalysis();\n  }, []);\n\n  // --- useFrame: Reapply blendshapes every frame ---\n  useFrame(() => {\n    if (!morphMeshRef.current) {\n      // Only log occasionally to avoid spam\n      if (Math.random() < 0.01) console.warn('[DEBUG][useFrame] morphMeshRef.current is NOT set');\n      return;\n    }\n    const dict = morphMeshRef.current.morphTargetDictionary;\n    const influences = morphMeshRef.current.morphTargetInfluences;\n    if (dict && influences && blendShapes) {\n      // Log mesh name and blendshapes (occasionally)\n      if (Math.random() < 0.01) {\n        console.log('[DEBUG][useFrame] Updating mesh:', morphMeshRef.current.name);\n        console.log('[DEBUG][useFrame] BlendShapes:', blendShapes);\n        console.log('[DEBUG][useFrame] morphTargetInfluences (before):', [...influences]);\n      }\n      Object.entries(blendShapes).forEach(([name, value]) => {\n        const idx = dict[name];\n        if (idx !== undefined) {\n          influences[idx] = value;\n        }\n      });\n      if (Math.random() < 0.01) {\n        console.log('[DEBUG][useFrame] morphTargetInfluences (after):', [...influences]);\n      }\n    }\n  });\n\n  return (\n    <div className=\"simulation-avatar\">\n      {console.log('Rendering Avatar component')}\n      <Avatar \n        ref={avatarRef}\n        modelSrc={avatarUrl}\n        blendShapes={blendShapes}\n        environment=\"sunset\"\n        onModelLoaded={(model) => {\n          console.log('Model loaded!', model);\n          console.log('Avatar model loaded:', model);\n\n          // --- BEGIN: Morph Target Name Logging ---\n          if (model && model.scene) {\n            model.scene.traverse((child) => {\n              if (child.isMesh && child.morphTargetDictionary) {\n                console.log('[DEBUG] Mesh:', child.name);\n                console.log('[DEBUG] Morph Target Names:', Object.keys(child.morphTargetDictionary));\n                // Store the first mesh with morph targets for useFrame updates\n                if (!morphMeshRef.current) {\n                  morphMeshRef.current = child;\n                  console.log('[DEBUG][onModelLoaded] morphMeshRef set to:', child.name);\n                }\n              }\n            });\n          } else {\n            console.warn('[DEBUG] Model or scene missing for morph target inspection');\n          }\n          // --- END: Morph Target Name Logging ---\n\n          // Comprehensive blendshape debugging\n          if (model && model.userData) {\n            console.group('Avatar Model Debug');\n            console.log('Model Source:', avatarUrl);\n            \n            // Check blendshapes\n            if (model.userData.blendShapes) {\n              console.log('Available Blendshape Names:', Object.keys(model.userData.blendShapes));\n              console.log('Blendshape Values:', model.userData.blendShapes);\n              \n              // Warn if no blendshapes are being applied\n              if (Object.keys(blendShapes).length === 0) {\n                console.warn('WARNING: No blendshapes are being applied to the avatar!');\n              }\n              \n              // Validate blendshape names against known ARKit names\n              const arKitBlendshapes = [\n                'eyeBlinkLeft', 'eyeBlinkRight', \n                'jawOpen', \n                'mouthSmileLeft', 'mouthSmileRight',\n                'mouthFrownLeft', 'mouthFrownRight',\n                'browInnerUp', 'browDownLeft', 'browDownRight',\n                'cheekPuffLeft', 'cheekPuffRight'\n              ];\n              \n              const missingBlendshapes = arKitBlendshapes.filter(\n                name => !Object.keys(model.userData.blendShapes).includes(name)\n              );\n              \n              if (missingBlendshapes.length > 0) {\n                console.warn('Missing expected blendshapes:', missingBlendshapes);\n              }\n            } else {\n              console.warn('No blendshapes found in model.userData');\n            }\n            \n            // Check mesh and skeleton\n            if (model.scene) {\n              console.log('Scene Children:', model.scene.children.length);\n              model.scene.traverse((child) => {\n                if (child.isMesh) {\n                  console.log('Mesh:', child.name);\n                  \n                  // Detailed morphtarget logging\n                  if (child.morphTargetDictionary) {\n                    console.log('Morphtarget Dictionary:', Object.keys(child.morphTargetDictionary));\n                  }\n                  if (child.morphTargetInfluences) {\n                    console.log('Morphtarget Influences:', child.morphTargetInfluences);\n                  }\n                }\n              });\n            }\n            \n            console.groupEnd();\n          } else {\n            console.warn('Model or userData is undefined');\n          }\n        }}\n      />\n      \n      <div className=\"avatar-controls\">\n        <select value={emotion} onChange={(e) => setEmotion(e.target.value)}>\n          {Object.keys(EMOTION_BLENDSHAPES).map(em => (\n            <option key={em} value={em}>{em}</option>\n          ))}\n        </select>\n        <div style={{fontSize: '0.9em', color: '#888'}}>Gaze wander: {gazeWander ? 'On' : 'Off'}</div>\n        \n        <div className=\"avatar-info\">\n          <p>Character Type: {type}</p>\n          <p>Speaking: {isSpeaking ? 'Yes' : 'No'}</p>\n          <p>Current Emotion: {emotion}</p>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default SimulationAvatar;\n"],"names":["EMOTION_BLENDSHAPES","neutral","eyeBlinkLeft","eyeBlinkRight","browInnerUp","browDownLeft","browDownRight","jawOpen","mouthSmileLeft","mouthSmileRight","mouthFrownLeft","mouthFrownRight","cheekPuffLeft","cheekPuffRight","happy","sad","surprised","eyeWideLeft","eyeWideRight","mouthOpen","angry","mouthPressLeft","mouthPressRight","_ref","type","avatarUrl","ttsApiKey","gazeWander","textToSpeak","console","log","emotion","setEmotion","useState","blendShapes","setBlendShapes","isSpeaking","setIsSpeaking","useRef","utteranceRef","useEffect","window","speechSynthesis","current","cancel","utter","SpeechSynthesisUtterance","onstart","onend","onerror","speak","avatarRef","morphMeshRef","gazeTarget","setGazeTarget","horizontal","vertical","gazeCurrent","gazeTimeout","active","loop","Math","random","setTimeout","clearTimeout","blinkTimeout","speakingAnimationFrame","blinkActive","blinkValue","blinkDirection","jawPhase","PI","animateBlink","scheduleNextBlink","updateBlendShapes","next","rawBase","base","k","startsWith","min","now","performance","abs","sin","eyeLookInLeft","eyeLookOutLeft","eyeLookUpLeft","eyeLookDownLeft","eyeLookInRight","eyeLookOutRight","eyeLookUpRight","eyeLookDownRight","interp","from","to","amt","max","finalBlendShapes","_objectSpread","speakingLoop","requestAnimationFrame","cancelAnimationFrame","async","stream","navigator","mediaDevices","getUserMedia","audio","audioContext","AudioContext","analyser","createAnalyser","createMediaStreamSource","connect","checkAudioIntensity","bufferLength","frequencyBinCount","dataArray","Uint8Array","getByteFrequencyData","volume","reduce","a","b","error","initAudioAnalysis","useFrame","warn","dict","morphTargetDictionary","influences","morphTargetInfluences","name","Object","entries","forEach","_ref2","value","idx","undefined","_jsxs","className","children","_jsx","Avatar","ref","modelSrc","environment","onModelLoaded","model","scene","traverse","child","isMesh","keys","userData","group","length","missingBlendshapes","filter","includes","groupEnd","onChange","e","target","map","em","style","fontSize","color"],"sourceRoot":""}