{"version":3,"file":"static/js/556.d8373fb9.chunk.js","mappings":"kLAgBA,MAgDA,EAhD0EA,IAOnE,IAPoE,UACzEC,EAAS,aACTC,EAAY,YACZC,EAAc,CAAC,EAAC,SAChBC,EAAW,CAAC,GAAI,IAAK,GAAE,SACvBC,EAAW,CAAC,EAAG,EAAG,GAAE,MACpBC,EAAQ,CAAC,IAAK,IAAK,MACpBN,EAEC,MAAQO,MAAOC,IAAWC,EAAAA,EAAAA,GAAQR,IAC1BS,WAAYC,IAAcF,EAAAA,EAAAA,GAAQP,IACpC,QAAEU,IAAYC,EAAAA,EAAAA,GAAcF,EAAWH,GACvCM,GAAYC,EAAAA,EAAAA,QAAY,MA6B9B,OA1BAC,EAAAA,EAAAA,YAAU,KAC8B,IAADC,EAAjCL,GAAWD,EAAUO,OAAS,IACN,QAA1BD,EAAAL,EAAQD,EAAU,GAAGQ,aAAK,IAAAF,GAA1BA,EAA4BG,QAAQC,OAAO,IAAKC,QAElD,MAAO,KACLC,OAAOC,OAAOZ,GAASa,SAASC,GAAiB,OAANA,QAAM,IAANA,OAAM,EAANA,EAAQC,YAEpD,CAACf,EAASD,KAGbiB,EAAAA,EAAAA,IAAS,KACFpB,GACLA,EAAOqB,UAAUC,IACf,GAAIA,EAAMC,QAAUD,EAAME,uBAAyBF,EAAMG,sBAAuB,CAC9E,MAAMC,EAAOJ,EAAME,sBACbG,EAAaL,EAAMG,sBACzBV,OAAOa,QAAQjC,GAAasB,SAAQY,IAAoB,IAAlBlB,EAAMmB,GAAMD,EAChD,MAAME,EAAML,EAAKf,QACLqB,IAARD,IACFJ,EAAWI,GAAOD,KAGxB,QAIC9B,GAGHiC,EAAAA,EAAAA,KAAA,aAAWC,IAAK5B,EAAW6B,OAAQnC,EAAQJ,SAAUA,EAAUC,SAAUA,EAAUC,MAAOA,IAHxE,K","sources":["components/AnimatedSimulationAvatar.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport { useGLTF, useAnimations } from '@react-three/drei';\nimport { useFrame } from '@react-three/fiber';\n\ninterface AnimatedSimulationAvatarProps {\n  avatarUrl: string;\n  animationUrl: string;\n  blendShapes?: Record<string, number>;\n  position?: [number, number, number];\n  rotation?: [number, number, number];\n  scale?: [number, number, number];\n}\n\n/**\n * Combines skeletal animation (body movement) and blendshape animation (facial, lipsync, emotion).\n */\nconst AnimatedSimulationAvatar: React.FC<AnimatedSimulationAvatarProps> = ({\n  avatarUrl,\n  animationUrl,\n  blendShapes = {},\n  position = [0, -1.1, 0],\n  rotation = [0, 0, 0],\n  scale = [1.4, 1.4, 1.4],\n}) => {\n  // Load avatar and animation\n  const { scene: avatar } = useGLTF(avatarUrl);\n  const { animations: animClips } = useGLTF(animationUrl);\n  const { actions } = useAnimations(animClips, avatar);\n  const avatarRef = useRef<any>(null);\n\n  // Play the first animation\n  useEffect(() => {\n    if (actions && animClips.length > 0) {\n      actions[animClips[0].name]?.reset().fadeIn(0.2).play();\n    }\n    return () => {\n      Object.values(actions).forEach((action) => action?.stop());\n    };\n  }, [actions, animClips]);\n\n  // Re-apply blendshapes every frame (after animation)\n  useFrame(() => {\n    if (!avatar) return;\n    avatar.traverse((child: any) => {\n      if (child.isMesh && child.morphTargetDictionary && child.morphTargetInfluences) {\n        const dict = child.morphTargetDictionary;\n        const influences = child.morphTargetInfluences;\n        Object.entries(blendShapes).forEach(([name, value]) => {\n          const idx = dict[name];\n          if (idx !== undefined) {\n            influences[idx] = value;\n          }\n        });\n      }\n    });\n  });\n\n  if (!avatar) return null;\n  return (\n    // @ts-ignore\n    <primitive ref={avatarRef} object={avatar} position={position} rotation={rotation} scale={scale} />\n  );\n};\n\nexport default AnimatedSimulationAvatar;\n"],"names":["_ref","avatarUrl","animationUrl","blendShapes","position","rotation","scale","scene","avatar","useGLTF","animations","animClips","actions","useAnimations","avatarRef","useRef","useEffect","_actions$animClips$0$","length","name","reset","fadeIn","play","Object","values","forEach","action","stop","useFrame","traverse","child","isMesh","morphTargetDictionary","morphTargetInfluences","dict","influences","entries","_ref2","value","idx","undefined","_jsx","ref","object"],"sourceRoot":""}