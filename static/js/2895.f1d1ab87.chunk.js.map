{"version":3,"file":"static/js/2895.f1d1ab87.chunk.js","mappings":"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","sources":["components/UserAvatarPiP.june11-conference.tsx"],"sourcesContent":["import React, { useState, useRef, useEffect, Suspense, useCallback } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { OrbitControls } from '@react-three/drei';\nimport { CombinedFaceTrackingService } from '../services/CombinedFaceTrackingService';\nimport { PresenceAvatar } from './PresenceAvatar';\nimport { FacialExpressions } from '../types/tracking';\nimport './UserAvatarPiP.css';\n\n// Error boundary for Canvas\nclass CanvasErrorBoundary extends React.Component<\n  { children: React.ReactNode },\n  { hasError: boolean; error: Error | null }\n> {\n  constructor(props: { children: React.ReactNode }) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    console.error('[CanvasErrorBoundary] Caught error:', error);\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('[CanvasErrorBoundary] Error details:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div style={{ padding: '20px', color: 'red' }}>\n          <h3>Canvas Error</h3>\n          <p>{this.state.error?.message}</p>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Separate canvas component to prevent re-renders\nconst AvatarCanvas = ({ \n  avatarUrl, \n  trackingData,\n  idleAnimationUrl = \"/animations/M_Standing_Idle_001.glb\",\n  onContextLost\n}: { \n  avatarUrl: string;\n  trackingData: any;\n  idleAnimationUrl?: string;\n  onContextLost?: () => void;\n}) => {\n  console.log('[AvatarCanvas] Rendering with:', { avatarUrl, hasTrackingData: !!trackingData });\n  \n  // Add a test to ensure canvas doesn't lose context\n  React.useEffect(() => {\n    console.log('[AvatarCanvas] Mounted');\n    return () => {\n      console.log('[AvatarCanvas] Unmounting!');\n    };\n  }, []);\n  \n  return (\n    <CanvasErrorBoundary>\n      <Canvas \n        camera={{ \n          position: [0, 1.5, 2.0],\n          fov: 28,\n          near: 0.1,\n          far: 100\n        }}\n        style={{ width: '100%', height: '100%' }}\n        gl={{ preserveDrawingBuffer: true }}\n        onCreated={({ gl }) => {\n          console.log('[AvatarCanvas] WebGL context created');\n          // Monitor context loss\n          const canvas = gl.domElement;\n          canvas.addEventListener('webglcontextlost', (e) => {\n            console.error('[AvatarCanvas] WebGL context lost!', e);\n            e.preventDefault(); // Try to prevent default behavior\n            if (onContextLost) {\n              onContextLost();\n            }\n          });\n          canvas.addEventListener('webglcontextrestored', (e) => {\n            console.log('[AvatarCanvas] WebGL context restored', e);\n          });\n        }}\n      >\n        <ambientLight intensity={0.6} />\n        <directionalLight \n          position={[0, 10, 5]} \n          intensity={0.8} \n          castShadow \n          shadow-mapSize={[1024, 1024]}\n        />\n        <directionalLight position={[0, 5, 10]} intensity={0.5} />\n        \n        <Suspense fallback={null}>\n          <PresenceAvatar\n            avatarUrl={avatarUrl}\n            trackingData={trackingData}\n            position={[0, 0, 0]}\n            scale={1}\n          />\n        </Suspense>\n        \n        <OrbitControls \n          enablePan={false}\n          enableZoom={false}\n          enableRotate={false}\n          target={[0, 1.5, 0]}\n        />\n      </Canvas>\n    </CanvasErrorBoundary>\n  );\n};\n\nAvatarCanvas.displayName = 'AvatarCanvas';\n\n// Custom comparison to prevent unnecessary re-renders\nconst arePropsEqual = (prevProps: any, nextProps: any) => {\n  // Only re-render if avatar URL changes\n  if (prevProps.avatarUrl !== nextProps.avatarUrl) return false;\n  if (prevProps.idleAnimationUrl !== nextProps.idleAnimationUrl) return false;\n  \n  // Don't re-render for tracking data changes\n  return true;\n};\n\n// Use the memoized version with custom comparison\nconst MemoizedAvatarCanvas = React.memo(AvatarCanvas, arePropsEqual);\n\ninterface UserAvatarPiPProps {\n  avatarUrl?: string;\n  onClose?: () => void;\n  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n  size?: 'small' | 'medium' | 'large';\n  trackingData?: any;\n}\n\nexport const UserAvatarPiP: React.FC<UserAvatarPiPProps> = ({\n  avatarUrl = '/avatars/default_avatar.glb',\n  onClose,\n  position = 'bottom-right',\n  size = 'medium',\n  trackingData\n}) => {\n  console.log('[UserAvatarPiP] Component rendering with props:', { avatarUrl, position, size, hasTrackingData: !!trackingData });\n  \n  const [isTracking, setIsTracking] = useState(false);\n  const [trackingDataState, setTrackingData] = useState<{\n    facialExpressions: FacialExpressions | null;\n    posture: any | null;\n    hands: any | null;\n    headRotation?: { pitch: number; yaw: number; roll: number } | null;\n    landmarks?: any[] | null;\n  }>({\n    facialExpressions: null,\n    posture: null,\n    hands: null\n  });\n  \n  // Use ref to store tracking data to avoid constant re-renders\n  const trackingDataRef = useRef(trackingDataState);\n  const [error, setError] = useState<string | null>(null);\n  const [isMinimized, setIsMinimized] = useState(false);\n  const [attemptReload, setAttemptReload] = useState(0);\n  const [trackingSource, setTrackingSource] = useState<string>('ML5');\n  \n  const videoRef = useRef<HTMLVideoElement>(null);\n  const trackingService = useRef<CombinedFaceTrackingService | null>(null);\n  const streamRef = useRef<MediaStream | null>(null);\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Handle WebGL context loss and recovery\n  const handleContextLost = useCallback(() => {\n    console.error('[UserAvatarPiP] WebGL context lost, attempting recovery...');\n    setError('WebGL context lost');\n    // Trigger a re-render after a short delay\n    setTimeout(() => {\n      setError(null);\n      setAttemptReload(prev => prev + 1);\n    }, 1000);\n  }, []);\n\n  // Update tracking data ref when parent tracking data changes\n  useEffect(() => {\n    if (trackingData) {\n      trackingDataRef.current = trackingData;\n    }\n  }, [trackingData]);\n\n  // Camera position for face framing\n  const cameraPosition: [number, number, number] = [0, 1.5, 2.0];\n  const cameraTarget: [number, number, number] = [0, 1.5, 0];\n\n  // Log state changes\n  React.useEffect(() => {\n    console.log('[UserAvatarPiP] State updated:', {\n      isTracking,\n      hasError: !!error,\n      isMinimized,\n      hasTrackingData: !!trackingDataState\n    });\n  }, [isTracking, error, isMinimized, trackingDataState]);\n\n  useEffect(() => {\n    // If trackingData is provided from parent, use that instead of camera tracking\n    if (trackingData) {\n      console.log('[UserAvatarPiP] Using trackingData from parent');\n      setTrackingData(trackingData);\n      setIsTracking(true);\n      setTrackingSource('Parent');\n      return; // Don't initialize camera tracking\n    }\n    \n    // Otherwise, initialize camera tracking\n    console.log('[UserAvatarPiP] No trackingData provided, initializing camera tracking');\n    const initializeTracking = async () => {\n      try {\n        // Initialize tracking service\n        if (!trackingService.current) {\n          trackingService.current = CombinedFaceTrackingService.getInstance();\n          \n          // Force ML5-only for now due to Hume API issues\n          // const hasHume = process.env.REACT_APP_HUME_API_KEY ? true : false;\n          const hasHume = false; // Disable Hume temporarily\n          setTrackingSource(hasHume ? 'ML5 + Hume' : 'ML5');\n        }\n        \n        await trackingService.current.initialize();\n        \n        // Set up camera\n        const stream = await navigator.mediaDevices.getUserMedia({ \n          video: { \n            width: { ideal: 640 },\n            height: { ideal: 480 },\n            facingMode: 'user'\n          } \n        });\n        \n        streamRef.current = stream;\n        \n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n          \n          // Wait for video to be ready\n          await new Promise<void>((resolve) => {\n            if (videoRef.current) {\n              videoRef.current.onloadedmetadata = () => {\n                videoRef.current!.play();\n                resolve();\n              };\n            }\n          });\n          \n          // Start tracking\n          startTracking();\n        }\n      } catch (err) {\n        console.error('Failed to initialize tracking:', err);\n        setError('Failed to access camera or initialize tracking');\n      }\n    };\n\n    initializeTracking();\n\n    return () => {\n      stopTracking();\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, []);\n\n  const startTracking = async () => {\n    // Don't start camera tracking if we're using parent trackingData\n    if (trackingData) {\n      console.log('[UserAvatarPiP] Using parent trackingData, skipping camera tracking');\n      return;\n    }\n    \n    try {\n      if (!trackingService.current || !videoRef.current) {\n        throw new Error('Tracking service or video not initialized');\n      }\n      \n      setIsTracking(true);\n      setError('');\n      \n      await trackingService.current.startTracking(videoRef.current);\n      \n      // Update tracking data at 50ms\n      intervalRef.current = setInterval(async () => {\n        if (trackingService.current) {\n          const expressions = trackingService.current.getExpressions();\n          const headRotation = trackingService.current.getHeadRotation();\n          const postureData = trackingService.current.getPostureData();\n          const landmarks = trackingService.current.getLandmarks();\n          \n          // Log tracking data occasionally\n          if (Math.random() < 0.05) {\n            console.log('[UserAvatarPiP] Raw tracking data:', {\n              expressions,\n              headRotation,\n              expressionKeys: expressions ? Object.keys(expressions) : null,\n              hasAnyExpression: expressions ? Object.values(expressions).some(v => v > 0) : false\n            });\n          }\n          \n          // Update ref immediately\n          trackingDataRef.current = {\n            facialExpressions: expressions,\n            headRotation: headRotation,\n            posture: postureData,\n            hands: null,\n            landmarks: landmarks || []\n          };\n          \n          // Update state every time to ensure data flows to avatar\n          setTrackingData(trackingDataRef.current);\n        }\n      }, 50);\n    } catch (err: any) {\n      console.error('Tracking error:', err);\n      setError(err.message || 'Failed to start tracking');\n      setIsTracking(false);\n    }\n  };\n\n  const stopTracking = () => {\n    if (intervalRef.current) {\n      clearInterval(intervalRef.current);\n      intervalRef.current = null;\n    }\n    \n    if (trackingService.current) {\n      trackingService.current.stopTracking();\n    }\n    \n    setIsTracking(false);\n  };\n\n  const getSizeClass = () => {\n    switch (size) {\n      case 'small': return 'pip-small';\n      case 'large': return 'pip-large';\n      default: return 'pip-medium';\n    }\n  };\n\n  return (\n    <div className={`user-avatar-pip ${position} ${getSizeClass()} ${isMinimized ? 'minimized' : ''}`}>\n      {/* Hidden video element for camera feed */}\n      <video \n        ref={videoRef} \n        style={{ display: 'none' }} \n        playsInline\n        muted\n      />\n      \n      {/* Minimal floating close button */}\n      {onClose && (\n        <button \n          className=\"pip-close-button\"\n          onClick={onClose}\n          title=\"Close\"\n        >\n          ✕\n        </button>\n      )}\n      \n      {/* Avatar content takes full space */}\n      <div className=\"pip-content\">\n        {error ? (\n          <div className=\"pip-error\">\n            <p>{error}</p>\n            <button onClick={() => {\n              setError(null);\n              setAttemptReload(prev => prev + 1);\n            }}>\n              Retry\n            </button>\n          </div>\n        ) : (\n          <div \n            key={`avatar-canvas-container-${attemptReload}`} \n            style={{ width: '100%', height: '100%' }}\n          >\n            <MemoizedAvatarCanvas \n              avatarUrl={avatarUrl}\n              trackingData={trackingData || trackingDataState}\n              idleAnimationUrl=\"/animations/M_Standing_Idle_001.glb\"\n              onContextLost={handleContextLost}\n            />\n          </div>\n        )}\n        \n        {(trackingData || trackingDataState)?.facialExpressions && !error && (\n          <div className=\"expression-debug\">\n            <div className=\"expression-mini\">\n              {isTracking && <div style={{color: 'lime', fontSize: '10px'}}>● TRACKING ACTIVE</div>}\n              {Object.entries((trackingData || trackingDataState).facialExpressions)\n                .filter(([_, value]) => (value as number) > 0.2)\n                .slice(0, 3)\n                .map(([name, value]) => (\n                  <div key={name} style={{ fontSize: '10px', marginBottom: '2px' }}>\n                    {name}: {((value as number) * 100).toFixed(0)}%\n                  </div>\n                ))}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n"],"names":["CanvasErrorBoundary","React","constructor","props","super","this","state","hasError","error","getDerivedStateFromError","console","componentDidCatch","errorInfo","render","_this$state$error","_jsxs","style","padding","color","children","_jsx","message","AvatarCanvas","_ref","avatarUrl","trackingData","idleAnimationUrl","onContextLost","log","hasTrackingData","Canvas","camera","position","fov","near","far","width","height","gl","preserveDrawingBuffer","onCreated","_ref2","canvas","domElement","addEventListener","e","preventDefault","intensity","castShadow","Suspense","fallback","PresenceAvatar","scale","OrbitControls","enablePan","enableZoom","enableRotate","target","displayName","arePropsEqual","prevProps","nextProps","MemoizedAvatarCanvas","UserAvatarPiP","_ref3","_ref4","onClose","size","isTracking","setIsTracking","useState","trackingDataState","setTrackingData","facialExpressions","posture","hands","trackingDataRef","useRef","setError","isMinimized","setIsMinimized","attemptReload","setAttemptReload","trackingSource","setTrackingSource","videoRef","trackingService","streamRef","intervalRef","handleContextLost","useCallback","setTimeout","prev","useEffect","current","async","CombinedFaceTrackingService","getInstance","initialize","stream","navigator","mediaDevices","getUserMedia","video","ideal","facingMode","srcObject","Promise","resolve","onloadedmetadata","play","startTracking","err","initializeTracking","stopTracking","getTracks","forEach","track","stop","Error","setInterval","expressions","getExpressions","headRotation","getHeadRotation","postureData","getPostureData","landmarks","getLandmarks","Math","random","expressionKeys","Object","keys","hasAnyExpression","values","some","v","clearInterval","className","concat","getSizeClass","ref","display","playsInline","muted","onClick","title","fontSize","entries","filter","_ref5","_","value","slice","map","_ref6","name","marginBottom","toFixed"],"sourceRoot":""}