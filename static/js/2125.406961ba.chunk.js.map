{"version":3,"file":"static/js/2125.406961ba.chunk.js","mappings":"yKAkBA,MAuDA,EAvDuBA,EAAAA,YACrB,CAAAC,EAKGC,KAAS,IALX,UACCC,EAAS,YACTC,EAAc,CAAC,EAAC,SAChBC,EAAW,CAAC,EAAG,EAAG,GAAE,MACpBC,EAAQ,CAAC,EAAG,EAAG,IAChBL,EACC,MAAMM,GAAWC,EAAAA,EAAAA,QAAoB,MAC/BC,GAAeD,EAAAA,EAAAA,QAAyB,OAGxC,MAAEE,IAAUC,EAAAA,EAAAA,GAAQR,GAoC1B,OAjCAS,EAAAA,EAAAA,YAAU,KACHF,GAGLA,EAAMG,UAAUC,IACd,MAAMC,EAAOD,EACTC,EAAKC,QAAU,0BAA2BD,IAC5CN,EAAaQ,QAAUF,EACvBG,QAAQC,IAAI,yBACVC,OAAOC,KAAKZ,EAAaQ,QAAQK,uBAAyB,CAAC,UAGhE,CAACZ,KAGJa,EAAAA,EAAAA,IAAS,KACP,IAAKd,EAAaQ,UAAYb,EAAa,OAE3C,MAAMW,EAAON,EAAaQ,QACpBO,EAAOT,EAAKO,sBACZG,EAAaV,EAAKW,sBAEnBF,GAASC,GAGdL,OAAOO,QAAQvB,GAAawB,SAAQC,IAAoB,IAAlBC,EAAMC,GAAMF,EAChD,MAAMG,EAAMR,EAAKM,QACLG,IAARD,GAAqBA,EAAMP,EAAWS,SACxCT,EAAWO,GAAOD,UAMtBI,EAAAA,EAAAA,KAAA,SAAOjC,IAAKK,EAAUF,SAAUA,EAAUC,MAAOA,EAAM8B,UACrDD,EAAAA,EAAAA,KAAA,aAAWE,OAAQ3B,EAAOR,IAAKA,Q","sources":["components/SimpleAvatar3D.tsx"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { useGLTF } from '@react-three/drei';\nimport * as THREE from 'three';\n\n// Extend the Mesh type to include morph targets\ntype MorphMesh = THREE.Mesh<THREE.BufferGeometry, THREE.Material | THREE.Material[]> & {\n  morphTargetDictionary?: { [key: string]: number };\n  morphTargetInfluences?: number[];\n};\n\ninterface SimpleAvatar3DProps {\n  avatarUrl: string;\n  blendShapes?: Record<string, number>;\n  position?: [number, number, number];\n  scale?: [number, number, number];\n}\n\nconst SimpleAvatar3D = React.forwardRef<THREE.Group, SimpleAvatar3DProps>(\n  ({ \n    avatarUrl, \n    blendShapes = {}, \n    position = [0, 0, 0], \n    scale = [1, 1, 1] \n  }, ref) => {\n    const groupRef = useRef<THREE.Group>(null);\n    const morphMeshRef = useRef<MorphMesh | null>(null);\n    \n    // Load the GLB model\n    const { scene } = useGLTF(avatarUrl) as unknown as { scene: THREE.Group };\n    \n    // Set up the scene when the model loads\n    useEffect(() => {\n      if (!scene) return;\n      \n      // Find the mesh with morph targets\n      scene.traverse((child) => {\n        const mesh = child as THREE.Mesh;\n        if (mesh.isMesh && 'morphTargetDictionary' in mesh) {\n          morphMeshRef.current = mesh as MorphMesh;\n          console.log('Available blendshapes:', \n            Object.keys(morphMeshRef.current.morphTargetDictionary || {}));\n        }\n      });\n    }, [scene]);\n    \n    // Apply blendshapes every frame\n    useFrame(() => {\n      if (!morphMeshRef.current || !blendShapes) return;\n      \n      const mesh = morphMeshRef.current;\n      const dict = mesh.morphTargetDictionary;\n      const influences = mesh.morphTargetInfluences;\n      \n      if (!dict || !influences) return;\n      \n      // Apply each blendshape value to the corresponding morph target\n      Object.entries(blendShapes).forEach(([name, value]) => {\n        const idx = dict[name];\n        if (idx !== undefined && idx < influences.length) {\n          influences[idx] = value;\n        }\n      });\n    });\n    \n    return (\n      <group ref={groupRef} position={position} scale={scale}>\n        <primitive object={scene} ref={ref} />\n      </group>\n    );\n  }\n);\n\nexport default SimpleAvatar3D;\n"],"names":["React","_ref","ref","avatarUrl","blendShapes","position","scale","groupRef","useRef","morphMeshRef","scene","useGLTF","useEffect","traverse","child","mesh","isMesh","current","console","log","Object","keys","morphTargetDictionary","useFrame","dict","influences","morphTargetInfluences","entries","forEach","_ref2","name","value","idx","undefined","length","_jsx","children","object"],"sourceRoot":""}