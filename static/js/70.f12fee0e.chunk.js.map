{"version":3,"file":"static/js/70.f12fee0e.chunk.js","mappings":"4NAQA,MAcMA,EAA4E,CAChF,YAAe,CAAEC,OAAQ,cAAeC,QAAS,KACjD,aAAgB,CAAED,OAAQ,eAAgBC,QAAS,KACnD,cAAiB,CAAED,OAAQ,gBAAiBC,QAAS,KACrD,gBAAmB,CAAED,OAAQ,kBAAmBC,QAAS,KACzD,iBAAoB,CAAED,OAAQ,mBAAoBC,QAAS,KAC3D,eAAkB,CAAED,OAAQ,iBAAkBC,QAAS,KACvD,gBAAmB,CAAED,OAAQ,kBAAmBC,QAAS,KACzD,eAAkB,CAAED,OAAQ,iBAAkBC,QAAS,KACvD,gBAAmB,CAAED,OAAQ,kBAAmBC,QAAS,KACzD,UAAa,CAAED,OAAQ,YAAaC,QAAS,GAC7C,YAAe,CAAED,OAAQ,cAAeC,QAAS,KACjD,UAAa,CAAED,OAAQ,YAAaC,QAAS,KAC7C,WAAc,CAAED,OAAQ,aAAcC,QAAS,KAC/C,cAAiB,CAAED,OAAQ,gBAAiBC,QAAS,KACrD,eAAkB,CAAED,OAAQ,iBAAkBC,QAAS,KACvD,YAAe,CAAED,OAAQ,cAAeC,QAAS,KACjD,aAAgB,CAAED,OAAQ,eAAgBC,QAAS,KACnD,UAAa,CAAED,OAAQ,YAAaC,QAAS,KAC7C,gBAAmB,CAAED,OAAQ,kBAAmBC,QAAS,KACzD,iBAAoB,CAAED,OAAQ,mBAAoBC,QAAS,KAC3D,cAAiB,CAAED,OAAQ,gBAAiBC,QAAS,KACrD,eAAkB,CAAED,OAAQ,iBAAkBC,QAAS,KACvD,QAAW,CAAED,OAAQ,UAAWC,QAAS,GACzC,QAAW,CAAED,OAAQ,UAAWC,QAAS,KACzC,SAAY,CAAED,OAAQ,WAAYC,QAAS,MAGvCC,EAA+F,CACnG,UAAa,CAAEC,QAAS,CAAC,WAAYF,QAAS,GAAKG,OAAO,GAC1D,WAAc,CAAED,QAAS,CAAC,iBAAkB,mBAAoBF,QAAS,GACzE,WAAc,CAAEE,QAAS,CAAC,iBAAkB,mBAAoBF,QAAS,GACzE,YAAe,CAAEE,QAAS,CAAC,eAAgBF,QAAS,KACpD,YAAe,CAAEE,QAAS,CAAC,eAAgBF,QAAS,KACpD,WAAc,CAAEE,QAAS,CAAC,mBAAoBF,QAAS,KACvD,YAAe,CAAEE,QAAS,CAAC,oBAAqBF,QAAS,KACzD,iBAAoB,CAAEE,QAAS,CAAC,mBAAoBF,QAAS,GAC7D,kBAAqB,CAAEE,QAAS,CAAC,oBAAqBF,QAAS,GAC/D,cAAiB,CAAEE,QAAS,CAAC,eAAgB,iBAAkBF,QAAS,GACxE,cAAiB,CAAEE,QAAS,CAAC,iBAAkBF,QAAS,GACxD,eAAkB,CAAEE,QAAS,CAAC,kBAAmBF,QAAS,GAC1D,YAAe,CAAEE,QAAS,CAAC,eAAgBF,QAAS,GACpD,aAAgB,CAAEE,QAAS,CAAC,gBAAiBF,QAAS,GACtD,UAAa,CAAEE,QAAS,CAAC,aAAcF,QAAS,KAChD,gBAAmB,CAAEE,QAAS,CAAC,mBAAoBF,QAAS,KAC5D,iBAAoB,CAAEE,QAAS,CAAC,oBAAqBF,QAAS,KAC9D,UAAa,CAAEE,QAAS,CAAC,gBAAiB,kBAAmBF,QAAS,KACtE,QAAW,CAAEE,QAAS,CAAC,WAAYF,QAAS,KAC5C,SAAY,CAAEE,QAAS,CAAC,YAAaF,QAAS,KAC9C,UAAa,CAAEE,QAAS,CAAC,aAAcF,QAAS,KAChD,WAAc,CAAEE,QAAS,CAAC,cAAeF,QAAS,KAClD,eAAkB,CAAEE,QAAS,CAAC,kBAAmBF,QAAS,KAC1D,eAAkB,CAAEE,QAAS,CAAC,kBAAmBF,QAAS,KAC1D,gBAAmB,CAAEE,QAAS,CAAC,mBAAoBF,QAAS,KAC5D,gBAAmB,CAAEE,QAAS,CAAC,mBAAoBF,QAAS,KAC5D,YAAe,CAAEE,QAAS,CAAC,eAAgBF,QAAS,KACpD,WAAc,CAAEE,QAAS,CAAC,iBAAkB,mBAAoBF,QAAS,KACzE,eAAkB,CAAEE,QAAS,CAAC,qBAAsB,uBAAwBF,QAAS,KACrF,aAAgB,CAAEE,QAAS,CAAC,mBAAoB,qBAAsBF,QAAS,KAC/E,UAAa,CAAEE,QAAS,CAAC,eAAgBF,QAAS,MA0BpD,SAASI,EAAKC,EAAiBN,EAAgBO,GAC7C,OAAOD,GAAWN,EAASM,GAAWC,CACxC,CAEkB,IAAIC,EAAAA,MACL,IAAIA,EAAAA,WACF,IAAIA,EAAAA,QACH,IAAIA,EAAAA,QACE,IAAIA,EAAAA,QACG,IAAIA,EAAAA,QACX,IAAIA,EAAAA,QAN9B,MAQaC,EAAgDC,EAAAA,MAAWC,IASjE,IATkE,UACvEC,EAAS,aACTC,EAAY,SACZC,EAAW,CAAC,EAAG,EAAG,GAAE,MACpBC,EAAQ,EAAC,cACTC,EAAa,cACbC,EAAgB,OAAM,qBACtBC,EAAoB,UACpBC,GACDR,EAEC,MAAMS,OAAiCC,IAAjBR,EAChBS,EAAaF,EAAgB,QAAU,OAGvCG,GAAgBC,EAAAA,EAAAA,QAAOC,KAAKC,SAASC,SAAS,IAAIC,OAAO,EAAG,KAElEC,EAAAA,EAAAA,YAAU,KACRC,QAAQC,IAAI,mBAADC,OAAoBT,EAAcjB,QAAO,cAAc,CAChEgB,aACAN,gBACAiB,kBAAmBpB,EACnBD,YACAsB,UAAWC,KAAKC,QAEX,KACLN,QAAQC,IAAI,mBAADC,OAAoBT,EAAcjB,QAAO,mBAErD,KAEHuB,EAAAA,EAAAA,YAAU,KACJT,GAAiBF,GAAwBmB,OAAOC,KAAKpB,GAAsBqB,OAAS,GACtFT,QAAQC,IAAI,mBAADC,OAAoBT,EAAcjB,QAAO,4BAA4B+B,OAAOC,KAAKpB,GAAsBqB,SAE/GnB,GAA6B,OAAZP,QAAY,IAAZA,GAAAA,EAAc2B,mBAClCV,QAAQC,IAAI,mBAADC,OAAoBT,EAAcjB,QAAO,gCAAgC+B,OAAOC,KAAKzB,EAAa2B,mBAAmBD,UAEjI,CAACrB,EAAsBL,EAAcO,EAAeE,IAGvD,MAAMmB,GAAWjB,EAAAA,EAAAA,QAAoB,MAC/BkB,GAAelB,EAAAA,EAAAA,QAA8B,MAC7CmB,GAAuBnB,EAAAA,EAAAA,QAA0B,MACjDoB,GAAWpB,EAAAA,EAAAA,QAA0B,MACrCqB,GAAWrB,EAAAA,EAAAA,QAA0B,MAErCsB,IADUtB,EAAAA,EAAAA,QAA0B,OACJA,EAAAA,EAAAA,QAAgC,OAChEuB,GAAgCvB,EAAAA,EAAAA,QAAgC,MAChEwB,GAAkBxB,EAAAA,EAAAA,QAA4B,MAC9CyB,GAAgBzB,EAAAA,EAAAA,QAAO,GACvB0B,GAAkB1B,EAAAA,EAAAA,QAAe,IAKjC,MAAE2B,KAJmB3B,EAAAA,EAAAA,QAA6B,CAAC,IAC/BA,EAAAA,EAAAA,QAA+B,CAAC,IAC5BA,EAAAA,EAAAA,SAAO,IAEnB4B,EAAAA,EAAAA,GAAQxC,GAtKD,6BAyKnByC,GAAcC,EAAAA,EAAAA,UAAQ,KAC1B,IAAKH,EAAO,OAAO,KAEnB,OADeI,EAAAA,EAAcC,MAAML,KAElC,CAACA,IAGEM,EAAmB,kDACjBC,WAAYC,IAAmBP,EAAAA,EAAAA,GAAQK,GAC/CL,EAAAA,EAAQQ,QAAQH,GAGhB,MAAMI,GAAuBP,EAAAA,EAAAA,UAAQ,IAAM,CACzC,2CACA,2CACA,2CACA,2CACA,2CACA,6CACC,KAGKI,WAAYI,IAAaV,EAAAA,EAAAA,GAAQS,EAAqB,KACtDH,WAAYK,IAAaX,EAAAA,EAAAA,GAAQS,EAAqB,KACtDH,WAAYM,IAAaZ,EAAAA,EAAAA,GAAQS,EAAqB,KACtDH,WAAYO,IAAab,EAAAA,EAAAA,GAAQS,EAAqB,KACtDH,WAAYQ,IAAad,EAAAA,EAAAA,GAAQS,EAAqB,KACtDH,WAAYS,IAAaf,EAAAA,EAAAA,GAAQS,EAAqB,IAGxDO,GAAoBd,EAAAA,EAAAA,UAAQ,IACzB,IAAIQ,KAAaC,KAAaC,KAAaC,KAAaC,KAAaC,IAC3E,CAACL,EAAUC,EAAUC,EAAUC,EAAUC,EAAUC,IAGtDN,EAAqBQ,SAAQC,GAAOlB,EAAAA,EAAQQ,QAAQU,KAGpD,MAAMC,GAAgBjB,EAAAA,EAAAA,UAAQ,IAGrB,IAAIK,KAAmBS,IAC7B,CAACT,EAAgBS,KACd,QAAEI,EAAO,MAAEC,IAAUC,EAAAA,EAAAA,GAAcH,EAAelB,GAAeZ,GAEjEkC,GAAsBnD,EAAAA,EAAAA,QAAsB,MAC5CoD,GAA0BpD,EAAAA,EAAAA,QAAsB,OAGtDK,EAAAA,EAAAA,YAAU,KACR,IAAK2C,GAA2C,IAAhCnC,OAAOC,KAAKkC,GAASjC,OAEnC,YADAT,QAAQC,IAAI,4DAIdD,QAAQC,IAAI,gDAAiDM,OAAOC,KAAKkC,IAGzE,MAAMJ,EAAoB/B,OAAOC,KAAKkC,GAASK,QAAOC,GACpDA,EAAKC,cAAcC,SAAS,SAC5BF,EAAKC,cAAcC,SAAS,UAC5BF,EAAKC,cAAcC,SAAS,eAG1BZ,EAAkB7B,OAAS,GAC7BT,QAAQC,IAAI,iDAAkDqC,GAGhE,IAAIa,EAAmB,GACvB,GAAsB,YAAlBhE,GAA+BmD,EAAkB7B,OAAS,EAE5D,GAAI6B,EAAkB7B,OAAS,EAAG,CAChC,IAAI2C,EAAsBd,EAAkBS,QAAOM,GAAQA,IAASP,EAAwBtE,UACzD,IAA/B4E,EAAoB3C,SACtB2C,EAAsBd,GAExBa,EAAmBC,EAAoBzD,KAAK2D,MAAM3D,KAAKC,SAAWwD,EAAoB3C,SACtFqC,EAAwBtE,QAAU2E,CACpC,MACEA,EAAmBb,EAAkB,QAE9BI,EAAc,KACvBS,EAAmB,OACV5C,OAAOC,KAAKkC,GAASjC,OAAS,IACrC0C,EAAmB5C,OAAOC,KAAKkC,GAAS,GACxC1C,QAAQuD,KAAK,gEAADrD,OAAiEiD,KAGjF,IAAKA,IAAqBT,EAAQS,GAE9B,YADAnD,QAAQwD,MAAM,sCAADtD,OAAuCiD,EAAgB,4BAIxE,MAAMM,EAAYf,EAAQS,GACpBO,EAAgBb,EAAoBrE,QACpCmF,EAAYD,EAAgBhB,EAAQgB,GAAiB,KAEtDD,EAKDA,IAAcE,GAAsB,OAATF,QAAS,IAATA,GAAAA,EAAWG,cAKtCD,GAAaA,IAAcF,GAC7BE,EAAUE,QAAQ,IAIpBJ,EAAUK,QACVL,EAAUM,QAAQrF,EAAAA,WAAkBsF,KACpCP,EAAUQ,mBAAmB,GAC7BR,EAAUS,sBAAwC,YAAlB/E,EAA8B,GAAM,IACpEsE,EAAUU,OAAO,IAAKC,OAEtBvB,EAAoBrE,QAAU2E,EAC9BnD,QAAQC,IAAI,2CAADC,OAA4CiD,KArBrDnD,QAAQwD,MAAM,+BAADtD,OAAgCiD,EAAgB,2CAuB9D,CAACT,EAASvD,KAGbY,EAAAA,EAAAA,YAAU,KAAO,IAADsE,EAAAC,EACd,IAAK/C,EAAa,OAElBvB,QAAQC,IAAI,iEAGZW,EAAapC,QAAU+C,EAGvBA,EAAYgD,UAAUC,IAChBA,aAAiB9F,EAAAA,aAAqB8F,EAAMC,uBAAyBD,EAAME,wBAC7E1E,QAAQC,IAAI,mBAADC,OAAoBT,EAAcjB,QAAO,oCAAoC,CACtFgB,aACAmF,OAAQH,EAAMI,KACdC,aAActE,OAAOC,KAAKgE,EAAMC,uBAAuBhE,OACvDqE,KAAMN,IAER3D,EAAqBrC,QAAUgG,MAKnC,MAAMO,EAAqB,GAqF3B,GApFAxD,EAAYgD,UAAUC,IAKpB,GAJIA,aAAiB9F,EAAAA,MAAc8F,EAAMC,uBAAyBD,EAAME,wBACtE1E,QAAQC,IAAI,kDAAmDuE,EAAMxB,MACrEnC,EAAqBrC,QAAUgG,GAE7BA,aAAiB9F,EAAAA,KAAY,CAC/BqG,EAASC,KAAKR,EAAMxB,MACpB,MAAMiC,EAAYT,EAAMxB,KAAKC,eAGxBgC,EAAU/B,SAAS,SAAyB,SAAd+B,IAAwBA,EAAU/B,SAAS,YACtE+B,EAAU/B,SAAS,SACnB+B,EAAU/B,SAAS,QACnB+B,EAAU/B,SAAS,QACnB+B,EAAU/B,SAAS,QACnB+B,EAAU/B,SAAS,SACzBlD,QAAQC,IAAI,oCAAqCuE,EAAMxB,MACvDlC,EAAStC,QAAUgG,IAIjBS,EAAU/B,SAAS,SAAyB,SAAd+B,GAAwBA,EAAU/B,SAAS,cAC3ElD,QAAQC,IAAI,oCAAqCuE,EAAMxB,MACvDjC,EAASvC,QAAUgG,EAEvB,KAGFxE,QAAQC,IAAI,6CAA8C8E,GAC1D/E,QAAQC,IAAI,oCAAqCa,EAAStC,QAAyB,QAAlB6F,EAAEvD,EAAStC,eAAO,IAAA6F,OAAA,EAAhBA,EAAkBrB,MACrFhD,QAAQC,IAAI,oCAAqCc,EAASvC,QAAyB,QAAlB8F,EAAEvD,EAASvC,eAAO,IAAA8F,OAAA,EAAhBA,EAAkBtB,MAGjFlC,EAAStC,UAEXsC,EAAStC,QAAQ0G,SAASC,EAAI,EAC9BrE,EAAStC,QAAQ0G,SAASE,EAAI,EAC9BtE,EAAStC,QAAQ0G,SAASG,EAAI,EAE9BrE,EAA8BxC,QAAUsC,EAAStC,QAAQ8G,WAAW5D,QACpE1B,QAAQC,IAAI,4DAGVc,EAASvC,UAEXuC,EAASvC,QAAQ0G,SAASC,EAAI,EAC9BpE,EAASvC,QAAQ0G,SAASE,EAAI,EAC9BrE,EAASvC,QAAQ0G,SAASG,EAAI,EAE9BpE,EAA8BzC,QAAUuC,EAASvC,QAAQ8G,WAAW5D,QACpE1B,QAAQC,IAAI,4DA2BdD,QAAQC,IAAI,wCAAyC,CACnDsF,kBAAmB1E,EAAqBrC,QACxCgH,cAAe1E,EAAStC,QACxBiH,cAAe1E,EAASvC,UAItBmC,EAASnC,QAAS,CAEpB,KAAOmC,EAASnC,QAAQkH,SAASjF,OAAS,GACxCE,EAASnC,QAAQmH,OAAOhF,EAASnC,QAAQkH,SAAS,IAEpD/E,EAASnC,QAAQoH,IAAIrE,EACvB,CAEAvB,QAAQC,IAAI,wCAAyC,CACnDsF,kBAAmB1E,EAAqBrC,QACxCgH,cAAe1E,EAAStC,QACxBiH,cAAe1E,EAASvC,YAEzB,CAAC+C,KAGJxB,EAAAA,EAAAA,YAAU,KACR,GAAIhB,EAAc,CAAC,IAAD8G,EAAAC,EAIhB,IAAIC,EAEJ,GAAqB,QAArBF,EAAI9G,EAAaiH,YAAI,IAAAH,GAAjBA,EAAmBX,SAAU,CAC/B,MAAMe,EAAMlH,EAAaiH,KAAKd,SAE9B,GAAI,UAAWe,GAAO,QAASA,GAAO,SAAUA,EAC9CF,EAAeE,OACV,GAAI,MAAOA,GAAO,MAAOA,GAAO,MAAOA,GAAO,MAAOA,EAAK,CAE/D,MAAMC,EAAO,IAAIxH,EAAAA,WAAiBuH,EAAId,EAAGc,EAAIb,EAAGa,EAAIZ,EAAGY,EAAIE,GACrDC,GAAQ,IAAI1H,EAAAA,OAAc2H,kBAAkBH,GAClDH,EAAe,CACbO,MAAOF,EAAMjB,EACboB,IAAKH,EAAMhB,EACXoB,KAAMJ,EAAMf,EAEhB,CACF,MAAWtG,EAAagH,eACtBA,EAAehH,EAAagH,cAO9B,IAJKA,GAAgBhH,EAAamG,WAChCa,EAAehH,EAAamG,WAGzBa,GAAgBhH,EAAaiH,KAAM,CAEtC,MAAMA,EAAOjH,EAAaiH,UACPzG,IAAfyG,EAAKM,YAAoC/G,IAAbyG,EAAKO,UAAmChH,IAAdyG,EAAKQ,OAC7DT,EAAeC,EAEnB,CAGKD,GAAwC,kBAAjBA,IAC1BA,EAAe,CAAEO,MAAO,EAAGC,IAAK,EAAGC,KAAM,IAI3CT,EAAe,CACbO,MAAqC,kBAAvBP,EAAaO,MAAqBP,EAAaO,MAAQ,EACrEC,IAAiC,kBAArBR,EAAaQ,IAAmBR,EAAaQ,IAAM,EAC/DC,KAAmC,kBAAtBT,EAAaS,KAAoBT,EAAaS,KAAO,GAGpE,MAAMC,EAAwB,CAC5B/F,mBAAoC,QAAjBoF,EAAA/G,EAAa2H,YAAI,IAAAZ,OAAA,EAAjBA,EAAmBa,SAAU5H,EAAa2B,mBAAqB,CAAC,EACnFqF,gBAGF7E,EAAgB1C,QAAUiI,EAEtBA,EAAsB/F,mBAAqBH,OAAOC,KAAKiG,EAAsB/F,mBAAmBD,OAAS,GAC3GT,QAAQC,IAAI,uCAAwCM,OAAOC,KAAKiG,EAAsB/F,mBAAmBD,QAEvGgG,EAAsBV,cACxB/F,QAAQC,IAAI,+CAAgDwG,EAAsBV,aAEtF,MAEE7E,EAAgB1C,QAAU,CACxBkC,kBAAmB,CAAC,EACpBqF,kBAAcxG,KAGjB,CAACR,KAG0ByC,EAAAA,EAAAA,UAAQ,KAAO,IAADoF,EAAAC,EAC1C,IAAK9H,QAAiCQ,IAAjBR,EACnB,OAAO,KAIT,IAAIgH,EAEJ,GAAqB,QAArBa,EAAI7H,EAAaiH,YAAI,IAAAY,GAAjBA,EAAmB1B,SAAU,CAC/B,MAAMe,EAAMlH,EAAaiH,KAAKd,SAE9B,GAAI,UAAWe,GAAO,QAASA,GAAO,SAAUA,EAC9CF,EAAeE,OACV,GAAI,MAAOA,GAAO,MAAOA,GAAO,MAAOA,GAAO,MAAOA,EAAK,CAE/D,MAAMC,EAAO,IAAIxH,EAAAA,WAAiBuH,EAAId,EAAGc,EAAIb,EAAGa,EAAIZ,EAAGY,EAAIE,GACrDC,GAAQ,IAAI1H,EAAAA,OAAc2H,kBAAkBH,GAClDH,EAAe,CACbO,MAAOF,EAAMjB,EACboB,IAAKH,EAAMhB,EACXoB,KAAMJ,EAAMf,EAEhB,CACF,MAAWtG,EAAagH,eACtBA,EAAehH,EAAagH,cAO9B,IAJKA,GAAgBhH,EAAamG,WAChCa,EAAehH,EAAamG,WAGzBa,GAAgBhH,EAAaiH,KAAM,CAEtC,MAAMA,EAAOjH,EAAaiH,UACPzG,IAAfyG,EAAKM,YAAoC/G,IAAbyG,EAAKO,UAAmChH,IAAdyG,EAAKQ,OAC7DT,EAAeC,EAEnB,CAGKD,GAAwC,kBAAjBA,IAC1BA,EAAe,CAAEO,MAAO,EAAGC,IAAK,EAAGC,KAAM,IAI3CT,EAAe,CACbO,MAAqC,kBAAvBP,EAAaO,MAAqBP,EAAaO,MAAQ,EACrEC,IAAiC,kBAArBR,EAAaQ,IAAmBR,EAAaQ,IAAM,EAC/DC,KAAmC,kBAAtBT,EAAaS,KAAoBT,EAAaS,KAAO,GAGpE,MAAMM,EAAY,CAChBpG,mBAAoC,QAAjBmG,EAAA9H,EAAa2H,YAAI,IAAAG,OAAA,EAAjBA,EAAmBF,SAAU5H,EAAa2B,mBAAqB,CAAC,EACnFqF,gBAQF,OAJIxF,OAAOC,KAAKsG,EAAUpG,mBAAmBD,OAAS,GACpDT,QAAQC,IAAI,gDAAiDM,OAAOC,KAAKsG,EAAUpG,mBAAmBD,OAAQ,eAGzGqG,IACN,CAAC/H,IAmVN,OAhVEgB,EAAAA,EAAAA,YAAU,KACHwB,GAELA,EAAYgD,UAAUC,IAChBA,aAAiB9F,EAAAA,OACnB8F,EAAMuC,eAAgB,EAElBvC,EAAMwC,UAAY,QAASxC,EAAMwC,UAAYxC,EAAMwC,SAASC,MAC9DzC,EAAMwC,SAASC,IAAIC,UAAYxI,EAAAA,yBAC/B8F,EAAMwC,SAASC,IAAIE,iBAAkB,SAI1C,CAAC5F,KAGJ6F,EAAAA,EAAAA,IAAS,CAACC,EAAOC,KACfnG,EAAc3C,UACd,MAAM+I,EAAY1G,EAAqBrC,QACvC,IAAKoC,EAAapC,QAAS,OAE3B,MAAMgJ,EAA8C,GAA1BH,EAAMI,MAAMC,YACtCvG,EAAc3C,QAAUmB,KAAK2D,MAAMkE,GAG/B7E,GACFA,EAAMgF,OAAOL,GAGf,MAAMM,EAAW1G,EAAgB1C,QACjC,IAAKoJ,IAAa/G,EAAqBrC,UAAYqC,EAAqBrC,QAAQkG,sBAC9E,OAGF,IAAKxD,EAAgB1C,QAAS,CAE5B,GAAIsC,EAAStC,QAAS,CACpB,MAAMqJ,EAAoB,KAAbxH,KAAKC,MACZwH,EAAiC,IAAvBnI,KAAKoI,IAAW,GAAPF,GACzB/G,EAAStC,QAAQ0G,SAASC,EAAI5G,EAAKuC,EAAStC,QAAQ0G,SAASC,EAAG2C,EAAS,GAC3E,CAIA,YAHI3G,EAAc3C,QAAU,MAAQ,GAClCwB,QAAQC,IAAI,8CAGhB,CAEIkB,EAAc3C,QAAU,KAAO,GACjCwB,QAAQC,IAAI,sDAAuDiB,EAAgB1C,SAIrF,MAAMwJ,EAAiD,CAAC,EAElDC,EAA0B7I,GAAwBmB,OAAOC,KAAKpB,GAAsBqB,OAAS,EAI7FnB,EAA+B,gBADDC,IAAjBR,EAA6B,QAAU,QAgB1D,GAZIoC,EAAc3C,QAAU,KAAO,GACjCwB,QAAQC,IAAI,mCAAoC,CAC9Cd,gBACA+I,2BAAqC,OAATX,QAAS,IAATA,IAAAA,EAAW9C,uBACvC0D,gBAA0B,OAATZ,QAAS,IAATA,GAAAA,EAAW9C,sBAAwBlE,OAAOC,KAAK+G,EAAU9C,uBAAuB2D,MAAM,EAAG,IAAM,GAChHC,eAAgBhJ,GAAaA,EAAUoB,OAAS,EAChDnB,gBACAgJ,SAAmB,OAATf,QAAS,IAATA,OAAS,EAATA,EAAWgB,KACrBC,SAAmB,OAATjB,QAAS,IAATA,OAAS,EAATA,EAAWvE,OAIH,YAAlB7D,GAA+BE,GAAaA,EAAUoB,OAAS,GAAc,OAAT8G,QAAS,IAATA,GAAAA,EAAW9C,sBAAuB,CAIxG,IAFiB,GAEDnF,EAAe,CAE7B,MAAMuI,EAAOxH,KAAKC,MAAQ,IACpBmI,EAAuC,IAA1B9I,KAAKoI,IAAW,EAAPF,GAAY,GAExC7H,QAAQC,IAAI,iDAAkDwI,GAW9D,IAAIC,GAAiB,EAmBrB,MA3BwB,CACtB,UAAW,YAAa,YAAa,WAAY,iBAAkB,kBAAmB,YAAa,aACnG,cAAe,cAAe,kBAAmB,mBACjD,mBAAoB,oBAAqB,iBAAkB,iBAC3D,kBAAmB,kBAAmB,iBAAkB,kBACxD,qBAAsB,sBAAuB,mBAAoB,qBAInDnG,SAAQrE,IACtB,GAAa,OAATqJ,QAAS,IAATA,GAAAA,EAAW9C,4BAAqElF,IAA5CgI,EAAU9C,sBAAsBvG,GAAuB,CAC7F,MAAMyK,EAAapB,EAAU9C,sBAAsBvG,GAC/CqJ,EAAU7C,4BAAwCnF,IAAfoJ,IACrCpB,EAAU7C,sBAAsBiE,GAAcF,EAC9CC,GAAiB,EACbvH,EAAc3C,QAAU,KAAO,GACjCwB,QAAQC,IAAI,2CAADC,OAA4ChC,EAAM,KAAKuK,GAGxE,UAGGC,GAAkBvH,EAAc3C,QAAU,KAAO,GACpDwB,QAAQwD,MAAM,gFACZjD,OAAOC,MAAc,OAAT+G,QAAS,IAATA,OAAS,EAATA,EAAW9C,wBAAyB,CAAC,IAIvD,CAGA,IAAImE,EAAc,EAClB,MAAMC,EAAelJ,KAAKmJ,IAAI,GAAIzJ,EAAUoB,QAC5C,IAAIsI,EAAY,EAEhB,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAcG,IAAK,CAErC,IAAIC,EAAS,EACTD,GAAK,GAAKA,GAAK,KACjBC,EAAS,GAGXL,GADkBvJ,EAAU2J,GAAKC,EAEjCF,EAAYpJ,KAAKuJ,IAAIH,EAAW1J,EAAU2J,GAC5C,CAGA,MAAMG,EAAgBN,EAAe,EAAID,EAAcC,EAAe,IAAM,EACtEO,EAAaL,EAAY,IACzBM,EAAiB1J,KAAKuJ,IAAIC,EAA4B,GAAbC,GAGzCE,EAAqB,CAAC,UAAW,YAAa,YAAa,WAAY,IAAK,KAClF,IAAIC,GAAiB,EAErB,IAAK,MAAMrL,KAAUoL,EACnB,GAAa,OAAT/B,QAAS,IAATA,GAAAA,EAAW9C,4BAAqElF,IAA5CgI,EAAU9C,sBAAsBvG,GAAuB,CAE7F,MAAMsL,EAAeC,EAAAA,UAAUC,MAAuB,EAAjBL,EAAsB,EAAG,IAGxDV,EAAapB,EAAU9C,sBAAsBvG,GAMnD,GALIqJ,EAAU7C,4BAAwCnF,IAAfoJ,IACrCpB,EAAU7C,sBAAsBiE,GAAca,GAIjC,YAAXtL,GAAmC,cAAXA,EAAwB,CAE3B,CAAC,iBAAkB,kBAAmB,YAAa,aAAc,cAAe,cAAe,kBAAmB,oBAC1HqE,SAAQoH,IACrB,GAAa,OAATpC,QAAS,IAATA,GAAAA,EAAW9C,4BAAsElF,IAA7CgI,EAAU9C,sBAAsBkF,GAAwB,CAC9F,MAAMC,EAAerC,EAAU9C,sBAAsBkF,GACjDpC,EAAU7C,wBACZ6C,EAAU7C,sBAAsBkF,GAA+B,GAAfJ,EAEpD,IAEJ,CAGA,GAAe,MAAXtL,GAA2B,OAATqJ,QAAS,IAATA,GAAAA,EAAW9C,4BAAkElF,IAAzCgI,EAAU9C,sBAAsB,GAAoB,CAC5G,MAAMoF,EAAiBtC,EAAU9C,sBAAsB,GACnD8C,EAAU7C,4BAA4CnF,IAAnBsK,IACrCtC,EAAU7C,sBAAsBmF,GAAiC,GAAfL,EAEtD,CAGIrI,EAAc3C,QAAU,KAAO,GACjCwB,QAAQC,IAAI,qCAAsC,CAChD/B,SACAiL,gBACAC,aACAC,iBACAG,eACAb,aACAC,cACAG,YACAe,gBAAiBzK,EAAUoB,OAC3BsJ,gBAAiBC,MAAMC,KAAK5K,EAAU+I,MAAM,EAAG,OAGnDmB,GAAiB,EACjB,KACF,CAGGA,GACHvJ,QAAQuD,KAAK,uEAAwEhD,OAAOC,MAAc,OAAT+G,QAAS,IAATA,OAAS,EAATA,EAAW9C,wBAAyB,CAAC,GAE1I,CAGA,GAAIwD,EAEF1H,OAAO2J,QAAQ9K,GAAsBmD,SAAQ4H,IAA0B,IAAxBC,EAASC,GAASF,EAC/D,GAAwB,kBAAbE,EAAuB,OAClC,MAAMC,EAAUrM,EAAoBmM,GACpC,GAAIE,EAAS,CAAC,IAADC,EACX,MAAMC,EAA+B,QAAlBD,EAAGD,EAAQnM,eAAO,IAAAoM,EAAAA,EAAI,EACnCE,EAAiBhB,EAAAA,UAAUC,MAAMgB,OAAOL,GAAYG,EAAe,EAAG,GAC5ExC,EAAuBsC,EAAQpM,QAAUyB,KAAKuJ,IAAIlB,EAAuBsC,EAAQpM,SAAW,EAAGuM,EACjG,UAEG,GAAY,OAAR7C,QAAQ,IAARA,GAAAA,EAAUlH,mBAA6B,OAARkH,QAAQ,IAARA,GAAAA,EAAU+C,YAAa,CAAC,IAADC,EAE/D,MAAMD,EAAyC,QAA9BC,EAAW,OAARhD,QAAQ,IAARA,OAAQ,EAARA,EAAUlH,yBAAiB,IAAAkK,EAAAA,EAAY,OAARhD,QAAQ,IAARA,OAAQ,EAARA,EAAU+C,YACzDA,GACFpK,OAAO2J,QAAQS,GAAapI,SAAQsI,IAAyB,IAAvBC,EAAQT,GAASQ,EACrD,GAAwB,kBAAbR,EAAuB,OAClC,MAAMC,EAAUlM,EAAmB0M,GACnC,GAAIR,EAAS,CAAC,IAADS,EACX,MAAMP,EAA+B,QAAlBO,EAAGT,EAAQnM,eAAO,IAAA4M,EAAAA,EAAI,EACnCC,EAAkBN,OAAOL,GACzBI,EAAiBhB,EAAAA,UAAUC,MAAMsB,EAAkBR,EAAe,EAAG,GAGvEC,EAAiB,KAAQK,EAAO5H,SAAS,UAAY4H,EAAO5H,SAAS,WACvElD,QAAQC,IAAI,gCAADC,OAAiC4K,EAAM,OAAA5K,OAAMuK,IAG1DH,EAAQjM,QAAQkE,SAAQ0I,IACtBjD,EAAuBiD,GAAiBtL,KAAKuJ,IAAIlB,EAAuBiD,IAAkB,EAAGR,KAEjG,IAGN,CAGA,GAAa,OAATlD,QAAS,IAATA,GAAAA,EAAW9C,uBAAkC,OAAT8C,QAAS,IAATA,GAAAA,EAAW7C,sBAAuB,CAExE,MAAMwG,EAAiB,CAAC,UAAW,YAAa,YAAa,WAAY,iBAAkB,kBAAmB,YAAa,aAAc,eAEzI3K,OAAOC,KAAK+G,EAAU9C,uBAAuBlC,SAAQ0I,IACnD,MAAMtC,EAAapB,EAAU9C,sBAAuBwG,GACpD,QAAmB1L,IAAfoJ,EAA0B,CAE5B,GAAsB,YAAlBxJ,GAA+B+L,EAAehI,SAAS+H,GACzD,OAGF,MAAME,EAAcnD,EAAuBiD,IAAkB,EACvDG,OAAgE7L,IAAjDgI,EAAU7C,sBAAuBiE,GAA4BpB,EAAU7C,sBAAuBiE,GAAc,EAE7HhJ,KAAK0L,IAAID,EAAeD,GAAe,KACzC5D,EAAU7C,sBAAuBiE,GAAcpK,EAC7C6M,EACAD,EAzMmB,IA4MI,IAAhBA,GAAsC,IAAjBC,IAC7B7D,EAAU7C,sBAAuBiE,GAAc,EAEpD,IAEJ,CAEA,MAAMrI,EAAMD,KAAKC,MACjB,GAAIA,EAAMc,EAAgB5C,QAAU,IAAM,CACxC,IAAI8M,EAAoB,EACX,OAAT/D,QAAS,IAATA,GAAAA,EAAW7C,uBACb6C,EAAU7C,sBAAsBnC,SAASgJ,IACnCA,EAAY,KAAMD,OAGtBA,EAAoB,GACtBtL,QAAQC,IAAI,wCAADC,OAAyCoL,IAEtDlK,EAAgB5C,QAAU8B,CAC5B,CAiBA,GAdIa,EAAc3C,QAAU,KAAO,GACjCwB,QAAQC,IAAI,iDAAkD,CAC5DuL,UAAWjE,EACXkE,iBAA2B,OAATlE,QAAS,IAATA,GAAAA,EAAW9C,sBAAwBlE,OAAOC,KAAK+G,EAAU9C,uBAAuBhE,OAAS,EAC3GoE,aAAuB,OAAT0C,QAAS,IAATA,GAAAA,EAAW9C,sBAAwBlE,OAAOC,KAAK+G,EAAU9C,uBAAuB2D,MAAM,EAAG,GAAK,GAC5GH,0BAA2B7I,GAAwBmB,OAAOC,KAAKpB,GAAsBqB,OAAS,EAC9FiL,SAAUtM,EACVD,gBACA2K,iBAA0B,OAATzK,QAAS,IAATA,OAAS,EAATA,EAAWoB,SAAU,EACtCvB,kBAKQ,OAAR0I,QAAQ,IAARA,GAAAA,EAAU7B,cAAgBjF,EAAStC,UAAYc,EAAe,CAChE,MAAMyG,EAAe6B,EAAS7B,aAE9B,GAAIA,GAAwC,kBAAjBA,EAA2B,CACpD,MAAM4F,EAAqB,GAG3B,GAAkC,kBAAvB5F,EAAaO,MAAoB,CAE1C,MAAMsF,EAAcnC,EAAAA,UAAUC,MAAM3D,EAAaO,OAAQ,GAAK,IAC9DxF,EAAStC,QAAQ0G,SAASC,EAAI5G,EAAKuC,EAAStC,QAAQ0G,SAASC,EAAGyG,EAAaD,EAC/E,CACA,GAAgC,kBAArB5F,EAAaQ,IAAkB,CACxC,MAAMsF,EAAYpC,EAAAA,UAAUC,MAAyB,GAAnB3D,EAAaQ,KAAY,GAAK,IAChEzF,EAAStC,QAAQ0G,SAASE,EAAI7G,EAAKuC,EAAStC,QAAQ0G,SAASE,EAAGyG,EAAWF,EAC7E,CACA,GAAiC,kBAAtB5F,EAAaS,KAAmB,CACzC,MAAMsF,EAAarC,EAAAA,UAAUC,MAA0B,GAApB3D,EAAaS,MAAa,GAAK,IAClE1F,EAAStC,QAAQ0G,SAASG,EAAI9G,EAAKuC,EAAStC,QAAQ0G,SAASG,EAAGyG,EAAYH,EAC9E,CAGI5K,EAASvC,UACXuC,EAASvC,QAAQ0G,SAASC,EAAI5G,EAAKwC,EAASvC,QAAQ0G,SAASC,EAAiC,GAA9BrE,EAAStC,QAAQ0G,SAASC,EAASwG,GACnG5K,EAASvC,QAAQ0G,SAASE,EAAI7G,EAAKwC,EAASvC,QAAQ0G,SAASE,EAAiC,GAA9BtE,EAAStC,QAAQ0G,SAASE,EAASuG,GAEvG,CACF,MAAO,GAAIrM,GAAiBwB,EAAStC,QAAS,CAE5C,MAAMqJ,EAAoB,KAAbxH,KAAKC,MACZwH,EAAiC,IAAvBnI,KAAKoI,IAAW,GAAPF,GACzB/G,EAAStC,QAAQ0G,SAASC,EAAI5G,EAAKuC,EAAStC,QAAQ0G,SAASC,EAAG2C,EAAS,GAC3E,MAGF/H,EAAAA,EAAAA,YAAU,KACRC,QAAQC,IAAI,yEAA0Ef,GAC/E,KACLc,QAAQC,IAAI,oDAEb,CAACf,IAGDqC,GAAgBX,EAAapC,SAMlCwB,QAAQC,IAAI,qCAAsCsB,EAAa,gBAAiBX,EAAapC,UAE3FuN,EAAAA,EAAAA,KAAA,SAAOC,IAAKrL,EAAU3B,SAAUA,EAAsCC,MAAOA,EAAMyG,SAChF9E,EAAapC,UAAWuN,EAAAA,EAAAA,KAAA,aAAWE,OAAQrL,EAAapC,QAAS0N,QAAS,UANtE,QAWT,G","sources":["components/PresenceAvatarMasculine.tsx"],"sourcesContent":["import React, { useMemo, useRef, useEffect } from 'react';\nimport * as THREE from 'three';\nimport { useFrame, useGraph } from '@react-three/fiber';\nimport { useGLTF, useAnimations } from '@react-three/drei';\nimport { SkeletonUtils } from 'three-stdlib';\nimport { MathUtils } from 'three';\nimport type { TrackingData, FacialExpressions } from '../types/tracking';\n\nconst DEFAULT_AVATAR_URL = '/avatars/coach_grace.glb';\n\ninterface PresenceAvatarProps {\n  avatarUrl?: string;\n  position?: [number, number, number] | THREE.Vector3;\n  scale?: number; // Overall scale for the group\n  trackingData?: TrackingData; // For user's face tracking (ML5)\n  animationName?: string; // e.g., 'idle', 'talking'\n  emotionalBlendshapes?: Record<string, number>; // For Hume EVI prosody\n  audioData?: Uint8Array; // For lip-sync from Hume EVI audio\n  participantId?: string;\n}\n\n// Hume to RPM blendshape mapping with amplification factors\nconst HUME_TO_RPM_MAPPING: Record<string, { target: string; amplify?: number }> = {\n  'browInnerUp': { target: 'browInnerUp', amplify: 1.5 },\n  'browDownLeft': { target: 'browDownLeft', amplify: 1.8 },\n  'browDownRight': { target: 'browDownRight', amplify: 1.8 },\n  'browOuterUpLeft': { target: 'browOuterUpLeft', amplify: 1.5 },\n  'browOuterUpRight': { target: 'browOuterUpRight', amplify: 1.5 },\n  'mouthSmileLeft': { target: 'mouthSmileLeft', amplify: 2.5 },\n  'mouthSmileRight': { target: 'mouthSmileRight', amplify: 2.5 },\n  'mouthFrownLeft': { target: 'mouthFrownLeft', amplify: 2.2 },\n  'mouthFrownRight': { target: 'mouthFrownRight', amplify: 2.2 },\n  'mouthOpen': { target: 'mouthOpen', amplify: 1.0 },\n  'mouthPucker': { target: 'mouthPucker', amplify: 1.8 },\n  'mouthLeft': { target: 'mouthLeft', amplify: 1.5 },\n  'mouthRight': { target: 'mouthRight', amplify: 1.5 },\n  'eyeSquintLeft': { target: 'eyeSquintLeft', amplify: 1.4 },\n  'eyeSquintRight': { target: 'eyeSquintRight', amplify: 1.4 },\n  'eyeWideLeft': { target: 'eyeWideLeft', amplify: 1.2 },\n  'eyeWideRight': { target: 'eyeWideRight', amplify: 1.2 },\n  'cheekPuff': { target: 'cheekPuff', amplify: 1.5 },\n  'cheekSquintLeft': { target: 'cheekSquintLeft', amplify: 1.3 },\n  'cheekSquintRight': { target: 'cheekSquintRight', amplify: 1.3 },\n  'noseSneerLeft': { target: 'noseSneerLeft', amplify: 1.5 },\n  'noseSneerRight': { target: 'noseSneerRight', amplify: 1.5 },\n  'jawOpen': { target: 'jawOpen', amplify: 1.0 },\n  'jawLeft': { target: 'jawLeft', amplify: 1.2 },\n  'jawRight': { target: 'jawRight', amplify: 1.2 }\n};\n\nconst ML5_TO_RPM_MAPPING: Record<string, { targets: string[]; amplify?: number; debug?: boolean }> = {\n  'mouthOpen': { targets: ['jawOpen'], amplify: 0.8, debug: true },\n  'mouthSmile': { targets: ['mouthSmileLeft', 'mouthSmileRight'], amplify: 7.0 }, // Restore high amplification for smiles\n  'mouthFrown': { targets: ['mouthFrownLeft', 'mouthFrownRight'], amplify: 7.0 },\n  'mouthPucker': { targets: ['mouthPucker'], amplify: 1.8 },\n  'browInnerUp': { targets: ['browInnerUp'], amplify: 1.5 },\n  'browUpLeft': { targets: ['browOuterUpLeft'], amplify: 1.5 },\n  'browUpRight': { targets: ['browOuterUpRight'], amplify: 1.5 },\n  'eyebrowRaiseLeft': { targets: ['browOuterUpLeft'], amplify: 5.0 }, // Restore high amplification\n  'eyebrowRaiseRight': { targets: ['browOuterUpRight'], amplify: 5.0 },\n  'eyebrowFurrow': { targets: ['browDownLeft', 'browDownRight'], amplify: 5.0 },\n  'eyeSquintLeft': { targets: ['eyeSquintLeft'], amplify: 3.0 },\n  'eyeSquintRight': { targets: ['eyeSquintRight'], amplify: 3.0 },\n  'eyeWideLeft': { targets: ['eyeWideLeft'], amplify: 3.0 },\n  'eyeWideRight': { targets: ['eyeWideRight'], amplify: 3.0 },\n  'cheekPuff': { targets: ['cheekPuff'], amplify: 1.5 },\n  'cheekSquintLeft': { targets: ['cheekSquintLeft'], amplify: 1.3 },\n  'cheekSquintRight': { targets: ['cheekSquintRight'], amplify: 1.3 },\n  'noseSneer': { targets: ['noseSneerLeft', 'noseSneerRight'], amplify: 1.5 },\n  'jawLeft': { targets: ['jawLeft'], amplify: 1.2 },\n  'jawRight': { targets: ['jawRight'], amplify: 1.2 },\n  'mouthLeft': { targets: ['mouthLeft'], amplify: 1.5 },\n  'mouthRight': { targets: ['mouthRight'], amplify: 1.5 },\n  'mouthRollLower': { targets: ['mouthRollLower'], amplify: 1.5 },\n  'mouthRollUpper': { targets: ['mouthRollUpper'], amplify: 1.5 },\n  'mouthShrugLower': { targets: ['mouthShrugLower'], amplify: 1.5 },\n  'mouthShrugUpper': { targets: ['mouthShrugUpper'], amplify: 1.5 },\n  'mouthFunnel': { targets: ['mouthFunnel'], amplify: 1.5 },\n  'mouthPress': { targets: ['mouthPressLeft', 'mouthPressRight'], amplify: 1.5 },\n  'mouthLowerDown': { targets: ['mouthLowerDownLeft', 'mouthLowerDownRight'], amplify: 1.5 },\n  'mouthUpperUp': { targets: ['mouthUpperUpLeft', 'mouthUpperUpRight'], amplify: 1.5 },\n  'mouthPout': { targets: ['mouthPucker'], amplify: 1.8 } // Map pout to pucker with amplification\n};\n\nconst ROTATION_LIMITS = {\n  head: {\n    pitch: { min: -0.5, max: 0.5 },\n    yaw: { min: -0.8, max: 0.8 },\n    roll: { min: -0.3, max: 0.3 },\n    pitchFactor: 1,\n    yawFactor: 1,\n    rollFactor: 1\n  },\n  neck: {\n    pitch: { min: -0.3, max: 0.3 },\n    yaw: { min: -0.4, max: 0.4 },\n    roll: { min: -0.2, max: 0.2 },\n    pitchFactor: 0.2, // Neck takes 20% of pitch\n    yawFactor: 0.2,   // Neck takes 20% of yaw\n    rollFactor: 0.2   // Neck takes 20% of roll\n  }\n};\n\nfunction clampRotation(value: number, limits: { min: number; max: number }): number {\n  return Math.max(limits.min, Math.min(limits.max, value));\n}\n\nfunction lerp(current: number, target: number, factor: number): number {\n  return current + (target - current) * factor;\n}\n\nconst tempEuler = new THREE.Euler();\nconst tempQuat = new THREE.Quaternion();\nconst tempMatrix = new THREE.Matrix4();\nconst deltaMatrix = new THREE.Matrix4();\nconst targetWorldMatrix = new THREE.Matrix4();\nconst parentInverseWorldMatrix = new THREE.Matrix4();\nconst targetLocalMatrix = new THREE.Matrix4();\n\nexport const PresenceAvatar: React.FC<PresenceAvatarProps> = React.memo(({\n  avatarUrl,\n  trackingData,\n  position = [0, 0, 0],\n  scale = 1,\n  participantId,\n  animationName = 'idle',\n  emotionalBlendshapes,\n  audioData\n}) => {\n  // Determine if this is a coach avatar\n  const isCoachAvatar = trackingData === undefined;\n  const avatarType = isCoachAvatar ? 'coach' : 'user';\n  \n  // Debug: Add unique instance tracking\n  const instanceIdRef = useRef(Math.random().toString(36).substr(2, 9));\n  \n  useEffect(() => {\n    console.log(`[PresenceAvatar-${instanceIdRef.current}] Mounted:`, {\n      avatarType,\n      participantId,\n      hasTrackingData: !!trackingData,\n      avatarUrl,\n      timestamp: Date.now()\n    });\n    return () => {\n      console.log(`[PresenceAvatar-${instanceIdRef.current}] Unmounted`);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (isCoachAvatar && emotionalBlendshapes && Object.keys(emotionalBlendshapes).length > 0) {\n      console.log(`[PresenceAvatar-${instanceIdRef.current}] Emotional blendshapes:`, Object.keys(emotionalBlendshapes).length);\n    }\n    if (!isCoachAvatar && trackingData?.facialExpressions) {\n      console.log(`[PresenceAvatar-${instanceIdRef.current}] Tracking data expressions:`, Object.keys(trackingData.facialExpressions).length);\n    }\n  }, [emotionalBlendshapes, trackingData, isCoachAvatar, avatarType]);\n\n  // All hooks must be called unconditionally at the top\n  const groupRef = useRef<THREE.Group>(null!); // Non-null assertion to avoid constant null checks\n  const modelRootRef = useRef<THREE.Object3D | null>(null);\n  const meshWithMorphTargets = useRef<THREE.Mesh | null>(null);\n  const headBone = useRef<THREE.Bone | null>(null);\n  const neckBone = useRef<THREE.Bone | null>(null);\n  const jawBone = useRef<THREE.Bone | null>(null);\n  const initialHeadLocalQuaternionRef = useRef<THREE.Quaternion | null>(null);\n  const initialNeckLocalQuaternionRef = useRef<THREE.Quaternion | null>(null);\n  const trackingDataRef = useRef<TrackingData | null>(null);\n  const frameCountRef = useRef(0);\n  const lastDebugLogRef = useRef<number>(0);\n  const morphTargetMapping = useRef<{ logged?: boolean }>({});\n  const currentInfluences = useRef<Record<string, number>>({});\n  const morphTargetsLoggedRef = useRef(false);\n  \n  const { scene } = useGLTF(avatarUrl || DEFAULT_AVATAR_URL);\n  \n  // Clone the scene using useMemo to prevent re-cloning on every render\n  const clonedScene = useMemo(() => {\n    if (!scene) return null;\n    const cloned = SkeletonUtils.clone(scene);\n    return cloned;\n  }, [scene]);\n\n  // Load basic idle animation - most subtle option\n  const idleAnimationUrl = '/animations/M_Standing_Idle_Variations_001.glb';\n  const { animations: idleAnimations } = useGLTF(idleAnimationUrl);\n  useGLTF.preload(idleAnimationUrl);\n\n  // Load talking animations\n  const talkingAnimationUrls = useMemo(() => [\n    '/animations/M_Talking_Variations_001.glb',\n    '/animations/M_Talking_Variations_002.glb', \n    '/animations/M_Talking_Variations_003.glb',\n    '/animations/M_Talking_Variations_004.glb',\n    '/animations/M_Talking_Variations_005.glb',\n    '/animations/M_Talking_Variations_006.glb'\n  ], []);\n  \n  // Load all talking animations separately\n  const { animations: talking1 } = useGLTF(talkingAnimationUrls[0]);\n  const { animations: talking2 } = useGLTF(talkingAnimationUrls[1]);\n  const { animations: talking3 } = useGLTF(talkingAnimationUrls[2]);\n  const { animations: talking4 } = useGLTF(talkingAnimationUrls[3]);\n  const { animations: talking5 } = useGLTF(talkingAnimationUrls[4]);\n  const { animations: talking6 } = useGLTF(talkingAnimationUrls[5]);\n  \n  // Combine all talking animations\n  const talkingAnimations = useMemo(() => {\n    return [...talking1, ...talking2, ...talking3, ...talking4, ...talking5, ...talking6];\n  }, [talking1, talking2, talking3, talking4, talking5, talking6]);\n  \n  // Preload all animations\n  talkingAnimationUrls.forEach(url => useGLTF.preload(url));\n  \n  // Combine all animations. Ensure names are unique if they aren't already.\n  const allAnimations = useMemo(() => {\n    // It's good practice to ensure animation names are unique if loaded from different files and might clash.\n    // For now, assuming 'idle' and 'F_Talking_Variations_001' are distinct enough or come from files with unique animation names.\n    return [...idleAnimations, ...talkingAnimations];\n  }, [idleAnimations, talkingAnimations]);\n  const { actions, mixer } = useAnimations(allAnimations, clonedScene || groupRef);\n  \n  const activeActionNameRef = useRef<string | null>(null);\n  const lastTalkingAnimationRef = useRef<string | null>(null);\n\n  // Play animations based on animationName prop\n  useEffect(() => {\n    if (!actions || Object.keys(actions).length === 0) {\n      console.log('[PresenceAvatar] No animation actions available to play.');\n      return;\n    }\n\n    console.log('[PresenceAvatar] Available animation actions:', Object.keys(actions));\n\n    // Find all talking animations\n    const talkingAnimations = Object.keys(actions).filter(name => \n      name.toLowerCase().includes('talk') || \n      name.toLowerCase().includes('speak') ||\n      name.toLowerCase().includes('f_talking')\n    );\n    \n    if (talkingAnimations.length > 0) {\n      console.log('[PresenceAvatar] Available talking animations:', talkingAnimations);\n    }\n\n    let targetActionName = '';\n    if (animationName === 'talking' && talkingAnimations.length > 0) {\n      // If we have multiple talking animations, pick one randomly (but not the same as last time)\n      if (talkingAnimations.length > 1) {\n        let availableAnimations = talkingAnimations.filter(anim => anim !== lastTalkingAnimationRef.current);\n        if (availableAnimations.length === 0) {\n          availableAnimations = talkingAnimations; // Reset if we've filtered everything out\n        }\n        targetActionName = availableAnimations[Math.floor(Math.random() * availableAnimations.length)];\n        lastTalkingAnimationRef.current = targetActionName;\n      } else {\n        targetActionName = talkingAnimations[0];\n      }\n    } else if (actions['idle']) { // Default to 'idle' if available\n      targetActionName = 'idle';\n    } else if (Object.keys(actions).length > 0) { // Fallback to the first available animation if 'idle' is not found\n        targetActionName = Object.keys(actions)[0];\n        console.warn(`[PresenceAvatar] 'idle' animation not found, falling back to ${targetActionName}`);\n    }\n\n    if (!targetActionName || !actions[targetActionName]) {\n        console.error(`[PresenceAvatar] Target animation '${targetActionName}' not found in actions.`);\n        return;\n    }\n\n    const newAction = actions[targetActionName];\n    const oldActionName = activeActionNameRef.current;\n    const oldAction = oldActionName ? actions[oldActionName] : null;\n\n    if (!newAction) {\n      console.error(`[PresenceAvatar] newAction '${targetActionName}' is unexpectedly null or undefined.`);\n      return;\n    }\n\n    if (newAction === oldAction && newAction?.isRunning()) {\n        return; // Already playing the target animation\n    }\n\n    // Fade out old action if it exists and is different\n    if (oldAction && oldAction !== newAction) {\n      oldAction.fadeOut(0.3);\n    }\n\n    // Configure and play new action\n    newAction.reset();\n    newAction.setLoop(THREE.LoopRepeat, Infinity);\n    newAction.setEffectiveWeight(1.0); // Full weight for primary action\n    newAction.setEffectiveTimeScale(animationName === 'talking' ? 0.4 : 0.3); // Talking slowed to 0.4, idle at 0.3\n    newAction.fadeIn(0.3).play();\n\n    activeActionNameRef.current = targetActionName;\n    console.log(`[PresenceAvatar] Switched animation to: ${targetActionName}`);\n\n  }, [actions, animationName]);\n\n  // useEffect for model setup\n  useEffect(() => {\n    if (!clonedScene) return;\n\n    console.log('[PresenceAvatar] useEffect: scene loaded, setting up model...');\n    \n    // Set the model root reference\n    modelRootRef.current = clonedScene;\n    \n    // Find mesh with morph targets\n    clonedScene.traverse((child) => {\n      if (child instanceof THREE.SkinnedMesh && child.morphTargetDictionary && child.morphTargetInfluences) {\n        console.log(`[PresenceAvatar-${instanceIdRef.current}] Found mesh with morph targets:`, {\n          avatarType,\n          meshId: child.uuid,\n          morphTargets: Object.keys(child.morphTargetDictionary).length,\n          mesh: child\n        });\n        meshWithMorphTargets.current = child;\n      }\n    });\n\n    // Find and configure bones\n    const allBones: string[] = [];\n    clonedScene.traverse((child) => {\n      if (child instanceof THREE.Mesh && child.morphTargetDictionary && child.morphTargetInfluences) {\n        console.log('[PresenceAvatar] Found mesh with morph targets:', child.name);\n        meshWithMorphTargets.current = child;\n      }\n      if (child instanceof THREE.Bone) {\n        allBones.push(child.name);\n        const lowerName = child.name.toLowerCase();\n        \n        // Head bone - check for various naming conventions\n        if ((lowerName.includes('head') || lowerName === 'head' || lowerName.includes('head_01')) \n            && !lowerName.includes('neck') \n            && !lowerName.includes('eye')\n            && !lowerName.includes('jaw')\n            && !lowerName.includes('top')  // Exclude HeadTop_End\n            && !lowerName.includes('end')) { // Exclude end bones\n          console.log('[PresenceAvatar] Found head bone:', child.name);\n          headBone.current = child;\n        }\n        \n        // Neck bone - check for various naming conventions\n        if (lowerName.includes('neck') || lowerName === 'neck' || lowerName.includes('neck_01')) {\n          console.log('[PresenceAvatar] Found neck bone:', child.name);\n          neckBone.current = child;\n        }\n      }\n    });\n    \n    console.log('[PresenceAvatar] All bones found in scene:', allBones);\n    console.log('[PresenceAvatar] Head bone set:', !!headBone.current, headBone.current?.name);\n    console.log('[PresenceAvatar] Neck bone set:', !!neckBone.current, neckBone.current?.name);\n    \n    // Fix any default pose issues first\n    if (headBone.current) {\n      // Reset head to neutral position before storing initial rotation\n      headBone.current.rotation.x = 0;\n      headBone.current.rotation.y = 0;\n      headBone.current.rotation.z = 0;\n      // Now store the corrected initial rotation\n      initialHeadLocalQuaternionRef.current = headBone.current.quaternion.clone();\n      console.log('[PresenceAvatar] Reset and stored head initial position');\n    }\n    \n    if (neckBone.current) {\n      // Reset neck to neutral position\n      neckBone.current.rotation.x = 0;\n      neckBone.current.rotation.y = 0;\n      neckBone.current.rotation.z = 0;\n      // Store the corrected initial rotation\n      initialNeckLocalQuaternionRef.current = neckBone.current.quaternion.clone();\n      console.log('[PresenceAvatar] Reset and stored neck initial position');\n    }\n\n    // Fix T-pose by adjusting arm positions for more natural idle pose\n    // Commenting out to let animation take control\n    /*\n    const leftUpperArm = clonedScene.getObjectByName('LeftArm') || clonedScene.getObjectByName('mixamorigLeftArm');\n    const rightUpperArm = clonedScene.getObjectByName('RightArm') || clonedScene.getObjectByName('mixamorigRightArm');\n    const leftForeArm = clonedScene.getObjectByName('LeftForeArm') || clonedScene.getObjectByName('mixamorigLeftForeArm');\n    const rightForeArm = clonedScene.getObjectByName('RightForeArm') || clonedScene.getObjectByName('mixamorigRightForeArm');\n\n    if (leftUpperArm) {\n      leftUpperArm.rotation.z = Math.PI / 4; // Rotate left arm down\n      console.log('[PresenceAvatar] Fixed left upper arm T-pose');\n    }\n    if (rightUpperArm) {\n      rightUpperArm.rotation.z = -Math.PI / 4; // Rotate right arm down\n      console.log('[PresenceAvatar] Fixed right upper arm T-pose');\n    }\n    if (leftForeArm) {\n      leftForeArm.rotation.y = Math.PI / 6; // Slight bend in left forearm\n    }\n    if (rightForeArm) {\n      rightForeArm.rotation.y = -Math.PI / 6; // Slight bend in right forearm\n    }\n    */\n\n    console.log('[PresenceAvatar] Model setup complete', {\n      hasMorphTargets: !!meshWithMorphTargets.current,\n      hasHeadBone: !!headBone.current,\n      hasNeckBone: !!neckBone.current\n    });\n\n    // Add the cloned scene to the group\n    if (groupRef.current) {\n      // Clear any existing children\n      while (groupRef.current.children.length > 0) {\n        groupRef.current.remove(groupRef.current.children[0]);\n      }\n      groupRef.current.add(clonedScene);\n    }\n\n    console.log('[PresenceAvatar] Model setup complete', {\n      hasMorphTargets: !!meshWithMorphTargets.current,\n      hasHeadBone: !!headBone.current,\n      hasNeckBone: !!neckBone.current\n    });\n  }, [clonedScene]);\n\n  // useEffect for tracking data\n  useEffect(() => {\n    if (trackingData) {\n      // Track if tracking data is updated - removed to prevent re-renders\n      // console.log('[PresenceAvatar] Tracking data updated:', trackingData);\n      \n      let headRotation: { pitch: number; yaw: number; roll: number; } | undefined;\n      \n      if (trackingData.head?.rotation) {\n        const rot = trackingData.head.rotation;\n        // Check if it's already in pitch/yaw/roll format\n        if ('pitch' in rot && 'yaw' in rot && 'roll' in rot) {\n          headRotation = rot as { pitch: number; yaw: number; roll: number; };\n        } else if ('x' in rot && 'y' in rot && 'z' in rot && 'w' in rot) {\n          // Convert quaternion to euler angles\n          const quat = new THREE.Quaternion(rot.x, rot.y, rot.z, rot.w);\n          const euler = new THREE.Euler().setFromQuaternion(quat);\n          headRotation = {\n            pitch: euler.x,\n            yaw: euler.y,\n            roll: euler.z\n          };\n        }\n      } else if (trackingData.headRotation) {\n        headRotation = trackingData.headRotation;\n      }\n      \n      if (!headRotation && trackingData.rotation) {\n        headRotation = trackingData.rotation;\n      }\n      \n      if (!headRotation && trackingData.head) {\n        // Convert head object to headRotation format if needed\n        const head = trackingData.head as any;\n        if (head.pitch !== undefined || head.yaw !== undefined || head.roll !== undefined) {\n          headRotation = head;\n        }\n      }\n      \n      // Ensure we have valid rotation values\n      if (!headRotation || typeof headRotation !== 'object') {\n        headRotation = { pitch: 0, yaw: 0, roll: 0 };\n      }\n      \n      // Ensure all rotation values are numbers\n      headRotation = {\n        pitch: typeof headRotation.pitch === 'number' ? headRotation.pitch : 0,\n        yaw: typeof headRotation.yaw === 'number' ? headRotation.yaw : 0,\n        roll: typeof headRotation.roll === 'number' ? headRotation.roll : 0\n      };\n      \n      const convertedTrackingData = {\n        facialExpressions: trackingData.face?.shapes || trackingData.facialExpressions || {},\n        headRotation\n      };\n      \n      trackingDataRef.current = convertedTrackingData;\n      \n      if (convertedTrackingData.facialExpressions && Object.keys(convertedTrackingData.facialExpressions).length > 0) {\n        console.log('[PresenceAvatar] Facial expressions:', Object.keys(convertedTrackingData.facialExpressions).length);\n      }\n      if (convertedTrackingData.headRotation) {\n        console.log('[PresenceAvatar] Head rotation data present:', convertedTrackingData.headRotation);\n      }\n    } else {\n      // Keep an empty object instead of null to avoid runtime errors\n      trackingDataRef.current = { \n        facialExpressions: {} as FacialExpressions, \n        headRotation: undefined \n      };\n    }\n  }, [trackingData]);\n\n  // Process tracking data with memoization to avoid unnecessary recalculations\n  const processedTrackingData = useMemo(() => {\n    if (!trackingData || trackingData === undefined) {\n      return null;\n    }\n    \n    // Process the tracking data directly here instead of relying on ref\n    let headRotation: { pitch: number; yaw: number; roll: number; } | undefined;\n    \n    if (trackingData.head?.rotation) {\n      const rot = trackingData.head.rotation;\n      // Check if it's already in pitch/yaw/roll format\n      if ('pitch' in rot && 'yaw' in rot && 'roll' in rot) {\n        headRotation = rot as { pitch: number; yaw: number; roll: number; };\n      } else if ('x' in rot && 'y' in rot && 'z' in rot && 'w' in rot) {\n        // Convert quaternion to euler angles\n        const quat = new THREE.Quaternion(rot.x, rot.y, rot.z, rot.w);\n        const euler = new THREE.Euler().setFromQuaternion(quat);\n        headRotation = {\n          pitch: euler.x,\n          yaw: euler.y,\n          roll: euler.z\n        };\n      }\n    } else if (trackingData.headRotation) {\n      headRotation = trackingData.headRotation;\n    }\n    \n    if (!headRotation && trackingData.rotation) {\n      headRotation = trackingData.rotation;\n    }\n    \n    if (!headRotation && trackingData.head) {\n      // Convert head object to headRotation format if needed\n      const head = trackingData.head as any;\n      if (head.pitch !== undefined || head.yaw !== undefined || head.roll !== undefined) {\n        headRotation = head;\n      }\n    }\n    \n    // Ensure we have valid rotation values\n    if (!headRotation || typeof headRotation !== 'object') {\n      headRotation = { pitch: 0, yaw: 0, roll: 0 };\n    }\n    \n    // Ensure all rotation values are numbers\n    headRotation = {\n      pitch: typeof headRotation.pitch === 'number' ? headRotation.pitch : 0,\n      yaw: typeof headRotation.yaw === 'number' ? headRotation.yaw : 0,\n      roll: typeof headRotation.roll === 'number' ? headRotation.roll : 0\n    };\n    \n    const processed = {\n      facialExpressions: trackingData.face?.shapes || trackingData.facialExpressions || {},\n      headRotation\n    };\n    \n    // Debug log to verify data is being processed\n    if (Object.keys(processed.facialExpressions).length > 0) {\n      console.log('[PresenceAvatar] Processed tracking data with', Object.keys(processed.facialExpressions).length, 'expressions');\n    }\n    \n    return processed;\n  }, [trackingData]);\n\n  // Add frustum culling and LOD\n  useEffect(() => {\n    if (!clonedScene) return;\n    \n    clonedScene.traverse((child) => {\n      if (child instanceof THREE.Mesh) {\n        child.frustumCulled = true;\n        // Reduce texture size if possible\n        if (child.material && 'map' in child.material && child.material.map) {\n          child.material.map.minFilter = THREE.LinearMipMapLinearFilter;\n          child.material.map.generateMipmaps = true;\n        }\n      }\n    });\n  }, [clonedScene]);\n\n  // useFrame hook for real-time updates\n  useFrame((state, delta) => {\n    frameCountRef.current++;\n    const morphMesh = meshWithMorphTargets.current;\n    if (!modelRootRef.current) return;\n\n    const currentFrameCount = state.clock.elapsedTime * 60; // Approximate frame count\n    frameCountRef.current = Math.floor(currentFrameCount);\n    \n    // Update animation mixer\n    if (mixer) {\n      mixer.update(delta);\n    }\n    \n    const tracking = trackingDataRef.current;\n    if (!tracking || !meshWithMorphTargets.current || !meshWithMorphTargets.current.morphTargetInfluences) {\n      return;\n    }\n\n    if (!trackingDataRef.current) {\n      // Apply idle animation when no tracking data\n      if (headBone.current) {\n        const time = Date.now() * 0.001;\n        const idleNod = Math.sin(time * 0.5) * 0.05;\n        headBone.current.rotation.x = lerp(headBone.current.rotation.x, idleNod, 0.1);\n      }\n      if (frameCountRef.current % 300 === 0) { // Every 5 seconds at 60fps\n        console.log('[PresenceAvatar useFrame] No tracking data');\n      }\n      return;\n    }\n\n    if (frameCountRef.current % 60 === 0) { // Every second at 60fps\n      console.log('[PresenceAvatar useFrame] Processing tracking data:', trackingDataRef.current);\n    }\n\n    // Initialize target morph values for this frame\n    const frameMorphTargetValues: Record<string, number> = {};\n    const expressionLerpFactor = 0.7; // Increased for near 1:1 responsiveness\n    const hasEmotionalBlendshapes = emotionalBlendshapes && Object.keys(emotionalBlendshapes).length > 0;\n    \n    // Determine avatar type based on whether tracking data exists\n    const avatarType = trackingData === undefined ? 'coach' : 'user';\n    const isCoachAvatar = avatarType === 'coach';\n    \n    // Lip Sync Override (if talking and audioData is present) - APPLY FIRST\n    if (frameCountRef.current % 30 === 0) {\n      console.log('[PresenceAvatar] Lip sync check:', {\n        animationName,\n        hasMorphTargetDictionary: !!morphMesh?.morphTargetDictionary,\n        morphTargetKeys: morphMesh?.morphTargetDictionary ? Object.keys(morphMesh.morphTargetDictionary).slice(0, 10) : [],\n        hasAudioData: !!audioData && audioData.length > 0,\n        isCoachAvatar,\n        meshType: morphMesh?.type,\n        meshName: morphMesh?.name\n      });\n    }\n    \n    if (animationName === 'talking' && audioData && audioData.length > 0 && morphMesh?.morphTargetDictionary) {\n      // TEST MODE: Force lip sync movement when talking\n      const testMode = false; // Disable test mode now that we know it works!\n      \n      if (testMode && isCoachAvatar) {\n        // Generate a sine wave for testing mouth movement\n        const time = Date.now() / 1000;\n        const testValue = (Math.sin(time * 5) + 1) * 0.5; // 0 to 1 oscillating value\n        \n        console.log('[PresenceAvatar] TEST MODE - Forcing lip sync:', testValue);\n        \n        // Try to apply to ALL possible mouth/jaw targets\n        const allMouthTargets = [\n          'jawOpen', 'mouthOpen', 'viseme_aa', 'viseme_O', 'mouthSmileLeft', 'mouthSmileRight', 'mouthLeft', 'mouthRight', \n          'mouthPucker', 'mouthFunnel', 'mouthDimpleLeft', 'mouthDimpleRight',\n          'mouthStretchLeft', 'mouthStretchRight', 'mouthRollLower', 'mouthRollUpper',\n          'mouthShrugLower', 'mouthShrugUpper', 'mouthPressLeft', 'mouthPressRight',\n          'mouthLowerDownLeft', 'mouthLowerDownRight', 'mouthUpperUpLeft', 'mouthUpperUpRight'\n        ];\n        \n        let foundAnyTarget = false;\n        allMouthTargets.forEach(target => {\n          if (morphMesh?.morphTargetDictionary && morphMesh.morphTargetDictionary[target] !== undefined) {\n            const morphIndex = morphMesh.morphTargetDictionary[target];\n            if (morphMesh.morphTargetInfluences && morphIndex !== undefined) {\n              morphMesh.morphTargetInfluences[morphIndex] = testValue;\n              foundAnyTarget = true;\n              if (frameCountRef.current % 30 === 0) { // Log less frequently\n                console.log(`[PresenceAvatar] TEST MODE - Applied to ${target}:`, testValue);\n              }\n            }\n          }\n        });\n        \n        if (!foundAnyTarget && frameCountRef.current % 60 === 0) {\n          console.error('[PresenceAvatar] TEST MODE - No mouth morph targets found! Available targets:', \n            Object.keys(morphMesh?.morphTargetDictionary || {}));\n        }\n        \n        return; // Skip normal lip sync processing in test mode\n      }\n      \n      // Normal lip sync processing\n      let totalEnergy = 0;\n      const relevantBins = Math.min(64, audioData.length); // Increased to 64 for even wider range\n      let maxEnergy = 0;\n      \n      for (let i = 0; i < relevantBins; i++) {\n        // Weight speech frequencies more heavily (100-1000 Hz range typically bins 2-20)\n        let weight = 1.0;\n        if (i >= 2 && i <= 20) {\n          weight = 2.0; // Double weight for speech frequencies\n        }\n        const binEnergy = audioData[i] * weight;\n        totalEnergy += binEnergy;\n        maxEnergy = Math.max(maxEnergy, audioData[i]);\n      }\n      \n      // Use both average and peak energy for more responsive lip sync\n      const averageEnergy = relevantBins > 0 ? totalEnergy / relevantBins / 255 : 0;\n      const peakEnergy = maxEnergy / 255;\n      const combinedEnergy = Math.max(averageEnergy, peakEnergy * 0.7); // Use whichever is higher\n      \n      // Try multiple possible jaw/mouth morph targets\n      const possibleJawTargets = ['jawOpen', 'mouthOpen', 'viseme_aa', 'viseme_O', '0', '1'];\n      let jawTargetFound = false;\n      \n      for (const target of possibleJawTargets) {\n        if (morphMesh?.morphTargetDictionary && morphMesh.morphTargetDictionary[target] !== undefined) {\n          // Reduced multiplier for more natural mouth movement\n          const lipSyncValue = MathUtils.clamp(combinedEnergy * 2.0, 0, 0.4); // Reduced from 10.0 to 2.0, max 0.4\n          \n          // Force set the value directly to ensure it's not overridden\n          const morphIndex = morphMesh.morphTargetDictionary[target];\n          if (morphMesh.morphTargetInfluences && morphIndex !== undefined) {\n            morphMesh.morphTargetInfluences[morphIndex] = lipSyncValue;\n          }\n          \n          // Also apply to related mouth shapes for more visible effect\n          if (target === 'jawOpen' || target === 'mouthOpen') {\n            // Apply to other mouth-related morph targets if they exist\n            const relatedTargets = ['mouthSmileLeft', 'mouthSmileRight', 'mouthLeft', 'mouthRight', 'mouthPucker', 'mouthFunnel', 'mouthDimpleLeft', 'mouthDimpleRight'];\n            relatedTargets.forEach(related => {\n              if (morphMesh?.morphTargetDictionary && morphMesh.morphTargetDictionary[related] !== undefined) {\n                const relatedIndex = morphMesh.morphTargetDictionary[related];\n                if (morphMesh.morphTargetInfluences) {\n                  morphMesh.morphTargetInfluences[relatedIndex] = lipSyncValue * 0.3; // Reduced from 0.7 to 0.3\n                }\n              }\n            });\n          }\n          \n          // For RPM avatars with numbered targets, apply to secondary target\n          if (target === '0' && morphMesh?.morphTargetDictionary && morphMesh.morphTargetDictionary['1'] !== undefined) {\n            const secondaryIndex = morphMesh.morphTargetDictionary['1'];\n            if (morphMesh.morphTargetInfluences && secondaryIndex !== undefined) {\n              morphMesh.morphTargetInfluences[secondaryIndex] = lipSyncValue * 0.5;\n            }\n          }\n          \n          // Debug lip sync every 30 frames - ALWAYS log when talking\n          if (frameCountRef.current % 30 === 0) {\n            console.log('[PresenceAvatar] Lip sync applied:', { \n              target, \n              averageEnergy, \n              peakEnergy,\n              combinedEnergy,\n              lipSyncValue,\n              morphIndex,\n              totalEnergy,\n              maxEnergy,\n              audioDataLength: audioData.length,\n              audioDataSample: Array.from(audioData.slice(0, 10))\n            });\n          }\n          jawTargetFound = true;\n          break; // Use the first available target\n        }\n      }\n      \n      if (!jawTargetFound) {\n        console.warn('[PresenceAvatar] No jaw/mouth morph target found! Available targets:', Object.keys(morphMesh?.morphTargetDictionary || {}));\n      }\n    }\n    \n    // Determine the source of expressions: Hume EVI or ML5 tracking data\n    if (hasEmotionalBlendshapes) {\n      // Priority 1: Hume EVI emotionalBlendshapes\n      Object.entries(emotionalBlendshapes).forEach(([humeKey, rawValue]) => {\n        if (typeof rawValue !== 'number') return;\n        const mapping = HUME_TO_RPM_MAPPING[humeKey as keyof typeof HUME_TO_RPM_MAPPING];\n        if (mapping) {\n          const amplification = mapping.amplify ?? 1.0;\n          const amplifiedValue = MathUtils.clamp(Number(rawValue) * amplification, 0, 1);\n          frameMorphTargetValues[mapping.target] = Math.max(frameMorphTargetValues[mapping.target] || 0, amplifiedValue);\n        }\n      });\n    } else if (tracking?.facialExpressions || tracking?.expressions) {\n      // Priority 2: ML5 trackingData (check both facialExpressions and expressions)\n      const expressions = tracking?.facialExpressions ?? tracking?.expressions;\n      if (expressions) {\n        Object.entries(expressions).forEach(([ml5Key, rawValue]) => {\n          if (typeof rawValue !== 'number') return;\n          const mapping = ML5_TO_RPM_MAPPING[ml5Key as keyof typeof ML5_TO_RPM_MAPPING];\n          if (mapping) {\n            const amplification = mapping.amplify ?? 1.0;\n            const numericRawValue = Number(rawValue);\n            const amplifiedValue = MathUtils.clamp(numericRawValue * amplification, 0, 1);\n            \n            // Debug log for high-value expressions\n            if (amplifiedValue > 0.3 && (ml5Key.includes('mouth') || ml5Key.includes('smile'))) {\n              console.log(`[PresenceAvatar] Expression: ${ml5Key} = ${amplifiedValue}`);\n            }\n            \n            mapping.targets.forEach(rpmTargetName => {\n              frameMorphTargetValues[rpmTargetName] = Math.max(frameMorphTargetValues[rpmTargetName] || 0, amplifiedValue);\n            });\n          }\n        });\n      }\n    }\n\n    // Apply the final frameMorphTargetValues to the actual morph targets with smoothing\n    if (morphMesh?.morphTargetDictionary && morphMesh?.morphTargetInfluences) {\n      // Track which morph targets were set by lip sync to avoid overriding them\n      const lipSyncTargets = ['jawOpen', 'mouthOpen', 'viseme_aa', 'viseme_O', 'mouthSmileLeft', 'mouthSmileRight', 'mouthLeft', 'mouthRight', 'mouthPucker'];\n      \n      Object.keys(morphMesh.morphTargetDictionary).forEach(rpmTargetName => {\n        const morphIndex = morphMesh.morphTargetDictionary![rpmTargetName];\n        if (morphIndex !== undefined) {\n          // Skip smoothing for lip sync targets when talking\n          if (animationName === 'talking' && lipSyncTargets.includes(rpmTargetName)) {\n            return; // Skip this iteration\n          }\n          \n          const targetValue = frameMorphTargetValues[rpmTargetName] || 0;\n          const currentValue = morphMesh.morphTargetInfluences![morphIndex] !== undefined ? morphMesh.morphTargetInfluences![morphIndex] : 0;\n          \n          if (Math.abs(currentValue - targetValue) > 0.001) { // Only lerp if there's a change\n            morphMesh.morphTargetInfluences![morphIndex] = lerp(\n              currentValue,\n              targetValue,\n              expressionLerpFactor\n            );\n          } else if (targetValue === 0 && currentValue !== 0) {\n             morphMesh.morphTargetInfluences![morphIndex] = 0; // Snap to 0 if target is 0 and current is not already 0\n          }\n        }\n      });\n    }\n\n    const now = Date.now();\n    if (now - lastDebugLogRef.current > 5000) { // Log every 5 seconds\n      let activeBlendshapes = 0;\n      if (morphMesh?.morphTargetInfluences) {\n        morphMesh.morphTargetInfluences.forEach((influence) => {\n          if (influence > 0.01) activeBlendshapes++;\n        });\n      }\n      if (activeBlendshapes > 0) {\n        console.log(`[PresenceAvatar] Active blendshapes: ${activeBlendshapes}`);\n      }\n      lastDebugLogRef.current = now;\n    }\n\n    // Log every 60 frames for Dougie\n    if (frameCountRef.current % 60 === 0) {\n      console.log('[PresenceAvatarMasculine/Dougie] Frame update:', {\n        hasMesh: !!morphMesh,\n        morphTargetCount: morphMesh?.morphTargetDictionary ? Object.keys(morphMesh.morphTargetDictionary).length : 0,\n        morphTargets: morphMesh?.morphTargetDictionary ? Object.keys(morphMesh.morphTargetDictionary).slice(0, 5) : [],\n        hasEmotionalBlendshapes: !!emotionalBlendshapes && Object.keys(emotionalBlendshapes).length > 0,\n        emotions: emotionalBlendshapes,\n        animationName,\n        audioDataLength: audioData?.length || 0,\n        participantId\n      });\n    }\n\n    // Head rotation from tracking data with neck support\n    if (tracking?.headRotation && headBone.current && !isCoachAvatar) {\n      const headRotation = tracking.headRotation;\n      \n      if (headRotation && typeof headRotation === 'object') {\n        const rotationLerpFactor = 0.8; // Restored high value for fast tracking\n        \n        // Apply rotation with minimal scaling and offset for pitch\n        if (typeof headRotation.pitch === 'number') {\n          // No manual offset needed - ML5 handles calibration\n          const targetPitch = MathUtils.clamp(headRotation.pitch, -0.8, 0.8);\n          headBone.current.rotation.x = lerp(headBone.current.rotation.x, targetPitch, rotationLerpFactor);\n        }\n        if (typeof headRotation.yaw === 'number') {\n          const targetYaw = MathUtils.clamp(headRotation.yaw * 0.9, -0.7, 0.7); // Minimal scaling for responsiveness\n          headBone.current.rotation.y = lerp(headBone.current.rotation.y, targetYaw, rotationLerpFactor);\n        }\n        if (typeof headRotation.roll === 'number') {\n          const targetRoll = MathUtils.clamp(headRotation.roll * 0.8, -0.4, 0.4); // Minimal scaling\n          headBone.current.rotation.z = lerp(headBone.current.rotation.z, targetRoll, rotationLerpFactor);\n        }\n        \n        // Also apply subtle neck movement for more natural look\n        if (neckBone.current) {\n          neckBone.current.rotation.x = lerp(neckBone.current.rotation.x, headBone.current.rotation.x * 0.3, rotationLerpFactor);\n          neckBone.current.rotation.y = lerp(neckBone.current.rotation.y, headBone.current.rotation.y * 0.3, rotationLerpFactor);\n        }\n      }\n    } else if (isCoachAvatar && headBone.current) {\n      // Coach avatar subtle idle movement\n      const time = Date.now() * 0.001;\n      const idleNod = Math.sin(time * 0.5) * 0.02;\n      headBone.current.rotation.x = lerp(headBone.current.rotation.x, idleNod, 0.1);\n    }\n  });\n\n  useEffect(() => {\n    console.log('[PresenceAvatarMasculine] Component mounted for Dougie, participantId:', participantId);\n    return () => {\n      console.log('[PresenceAvatarMasculine] Component unmounted');\n    };\n  }, [participantId]);\n\n// Now check if scene is loaded after all hooks\nif (!clonedScene || !modelRootRef.current) {\n  // Removed excessive logging\n  // console.log('[PresenceAvatar] Rendering. Scene:', clonedScene, 'ModelRootRef:', modelRootRef.current);\n  return null;\n}\n\nconsole.log('[PresenceAvatar] Rendering. Scene:', clonedScene, 'ModelRootRef:', modelRootRef.current);\nreturn (\n  <group ref={groupRef} position={position as [number, number, number]} scale={scale}>\n    {modelRootRef.current && <primitive object={modelRootRef.current} dispose={null} />}\n  </group>\n);\n});\n\nexport default PresenceAvatar;"],"names":["HUME_TO_RPM_MAPPING","target","amplify","ML5_TO_RPM_MAPPING","targets","debug","lerp","current","factor","THREE","PresenceAvatar","React","_ref","avatarUrl","trackingData","position","scale","participantId","animationName","emotionalBlendshapes","audioData","isCoachAvatar","undefined","avatarType","instanceIdRef","useRef","Math","random","toString","substr","useEffect","console","log","concat","hasTrackingData","timestamp","Date","now","Object","keys","length","facialExpressions","groupRef","modelRootRef","meshWithMorphTargets","headBone","neckBone","initialHeadLocalQuaternionRef","initialNeckLocalQuaternionRef","trackingDataRef","frameCountRef","lastDebugLogRef","scene","useGLTF","clonedScene","useMemo","SkeletonUtils","clone","idleAnimationUrl","animations","idleAnimations","preload","talkingAnimationUrls","talking1","talking2","talking3","talking4","talking5","talking6","talkingAnimations","forEach","url","allAnimations","actions","mixer","useAnimations","activeActionNameRef","lastTalkingAnimationRef","filter","name","toLowerCase","includes","targetActionName","availableAnimations","anim","floor","warn","error","newAction","oldActionName","oldAction","isRunning","fadeOut","reset","setLoop","Infinity","setEffectiveWeight","setEffectiveTimeScale","fadeIn","play","_headBone$current","_neckBone$current","traverse","child","morphTargetDictionary","morphTargetInfluences","meshId","uuid","morphTargets","mesh","allBones","push","lowerName","rotation","x","y","z","quaternion","hasMorphTargets","hasHeadBone","hasNeckBone","children","remove","add","_trackingData$head","_trackingData$face","headRotation","head","rot","quat","w","euler","setFromQuaternion","pitch","yaw","roll","convertedTrackingData","face","shapes","_trackingData$head2","_trackingData$face2","processed","frustumCulled","material","map","minFilter","generateMipmaps","useFrame","state","delta","morphMesh","currentFrameCount","clock","elapsedTime","update","tracking","time","idleNod","sin","frameMorphTargetValues","hasEmotionalBlendshapes","hasMorphTargetDictionary","morphTargetKeys","slice","hasAudioData","meshType","type","meshName","testValue","foundAnyTarget","morphIndex","totalEnergy","relevantBins","min","maxEnergy","i","weight","max","averageEnergy","peakEnergy","combinedEnergy","possibleJawTargets","jawTargetFound","lipSyncValue","MathUtils","clamp","related","relatedIndex","secondaryIndex","audioDataLength","audioDataSample","Array","from","entries","_ref2","humeKey","rawValue","mapping","_mapping$amplify","amplification","amplifiedValue","Number","expressions","_tracking$facialExpre","_ref3","ml5Key","_mapping$amplify2","numericRawValue","rpmTargetName","lipSyncTargets","targetValue","currentValue","abs","activeBlendshapes","influence","hasMesh","morphTargetCount","emotions","rotationLerpFactor","targetPitch","targetYaw","targetRoll","_jsx","ref","object","dispose"],"sourceRoot":""}