{"version":3,"file":"static/js/5051.e2bb0a80.chunk.js","mappings":"+KAGA,MAAMA,GAAuBC,EAAAA,EAAAA,eAAc,MAErCC,EAAe,CACnBC,UAAU,EACVC,MAAO,MAET,MAAMC,UAAsBC,EAAAA,UAC1BC,WAAAA,CAAYC,GACVC,MAAMD,GACNE,KAAKC,mBAAqBD,KAAKC,mBAAmBC,KAAKF,MACvDA,KAAKG,MAAQX,CACf,CACA,+BAAOY,CAAyBV,GAC9B,MAAO,CACLD,UAAU,EACVC,QAEJ,CACAO,kBAAAA,GACE,MAAM,MACJP,GACEM,KAAKG,MACT,GAAc,OAAVT,EAAgB,CAElB,IADA,IAAIW,EAAqBC,EAChBC,EAAOC,UAAUC,OAAQC,EAAO,IAAIC,MAAMJ,GAAOK,EAAO,EAAGA,EAAOL,EAAMK,IAC/EF,EAAKE,GAAQJ,UAAUI,GAEsC,QAA9DP,GAAuBC,EAAcN,KAAKF,OAAOe,eAA6C,IAAxBR,GAA0CA,EAAoBS,KAAKR,EAAa,CACrJI,OACAK,OAAQ,mBAEVf,KAAKgB,SAASxB,EAChB,CACF,CACAyB,iBAAAA,CAAkBvB,EAAOwB,GACvB,IAAIC,EAAqBC,EACuC,QAA/DD,GAAuBC,EAAepB,KAAKF,OAAOuB,eAA6C,IAAxBF,GAA0CA,EAAoBL,KAAKM,EAAc1B,EAAOwB,EAClK,CACAI,kBAAAA,CAAmBC,EAAWC,GAC5B,MAAM,SACJ/B,GACEO,KAAKG,OACH,UACJsB,GACEzB,KAAKF,MAQP,IAAI4B,EAAsBC,EADxBlC,GAAgC,OAApB+B,EAAU9B,OA8C9B,WACE,IAAIkC,EAAIpB,UAAUC,OAAS,QAAsBoB,IAAjBrB,UAAU,GAAmBA,UAAU,GAAK,GACxEsB,EAAItB,UAAUC,OAAS,QAAsBoB,IAAjBrB,UAAU,GAAmBA,UAAU,GAAK,GAC5E,OAAOoB,EAAEnB,SAAWqB,EAAErB,QAAUmB,EAAEG,MAAK,CAACC,EAAMC,KAAWC,OAAOC,GAAGH,EAAMF,EAAEG,KAC7E,CAlDgDG,CAAgBb,EAAUE,UAAWA,KAEd,QAAhEC,GAAwBC,EAAe3B,KAAKF,OAAOe,eAA8C,IAAzBa,GAA2CA,EAAqBZ,KAAKa,EAAc,CAC1JU,KAAMZ,EACNa,KAAMf,EAAUE,UAChBV,OAAQ,SAEVf,KAAKgB,SAASxB,GAElB,CACA+C,MAAAA,GACE,MAAM,SACJC,EAAQ,eACRC,EAAc,kBACdC,EAAiB,SACjBC,GACE3C,KAAKF,OACH,SACJL,EAAQ,MACRC,GACEM,KAAKG,MACT,IAAIyC,EAAgBJ,EACpB,GAAI/C,EAAU,CACZ,MAAMK,EAAQ,CACZJ,QACAO,mBAAoBD,KAAKC,oBAE3B,GAA8B,oBAAnBwC,EACTG,EAAgBH,EAAe3C,QAC1B,GAAI4C,EACTE,GAAgBC,EAAAA,EAAAA,eAAcH,EAAmB5C,OAC5C,SAAiB+B,IAAbc,EAGT,MAAMjD,EAFNkD,EAAgBD,CAGlB,CACF,CACA,OAAOE,EAAAA,EAAAA,eAAcvD,EAAqBwD,SAAU,CAClDC,MAAO,CACLtD,WACAC,QACAO,mBAAoBD,KAAKC,qBAE1B2C,EACL,E,eC7EF,SAASI,EAAcC,GAA+B,IAA9B,MAAEvD,GAAyBuD,EAEjD,OADAC,QAAQxD,MAAM,wBAAyBA,IAErCyD,EAAAA,EAAAA,MAAA,QAAMC,SAAU,CAAC,EAAG,EAAG,GAAGZ,SAAA,EACxBa,EAAAA,EAAAA,KAAA,eAAa3C,KAAM,CAAC,EAAG,EAAG,OAC1B2C,EAAAA,EAAAA,KAAA,wBAAsBC,MAAM,WAGlC,CAEA,SAASC,EAAmBC,GAMH,IANI,UAC3BC,EAAS,aACTC,EAAY,SACZN,EAAW,CAAC,GAAI,IAAK,GAAE,SACvBO,EAAW,CAAC,EAAG,EAAG,GAAE,MACpBC,EAAQ,CAAC,IAAK,IAAK,MACCJ,EACpBN,QAAQW,IAAI,kBAAmBJ,EAAW,kBAAmBC,GAE7D,MAAQI,MAAOC,IAAWC,EAAAA,EAAAA,GAAQP,IAC1BQ,WAAYC,IAAcF,EAAAA,EAAAA,GAAQN,IACpC,QAAES,IAAYC,EAAAA,EAAAA,GAAcF,EAAWH,GAc7C,OAZAM,EAAAA,EAAAA,YAAU,KAC8B,IAADC,EAAjCH,GAAWD,EAAUzD,OAAS,GAChCyC,QAAQW,IAAI,qBAAsBK,EAAU,GAAGK,MACrB,QAA1BD,EAAAH,EAAQD,EAAU,GAAGK,aAAK,IAAAD,GAA1BA,EAA4BE,QAAQC,OAAO,IAAKC,QAEhDxB,QAAQW,IAAI,4CAEd,MAAO,KACL3B,OAAOyC,OAAOR,GAASS,SAASC,GAAiB,OAANA,QAAM,IAANA,OAAM,EAANA,EAAQC,YAEpD,CAACX,EAASD,IAERH,GAOHV,EAAAA,EAAAA,KAAA,aAAW0B,OAAQhB,EAAQH,MAAOA,EAAOR,SAAUA,EAAUO,SAAUA,KANvET,QAAQxD,MAAM,qBAAsB+D,GAC7B,KAOX,CAEO,SAASuB,EAAelF,GAC7B,OACEuD,EAAAA,EAAAA,KAAC1D,EAAa,CAAC8C,eAAgBwC,IAAA,IAAC,MAAEvF,GAAOuF,EAAA,OAAK5B,EAAAA,EAAAA,KAACL,EAAc,CAACtD,MAAOA,KAAU8C,UAC7Ea,EAAAA,EAAAA,KAAC6B,EAAAA,SAAQ,CAACvC,UACRQ,EAAAA,EAAAA,MAAA,QAAMC,SAAUtD,EAAMsD,SAASZ,SAAA,EAC7Ba,EAAAA,EAAAA,KAAA,eAAa3C,KAAM,CAAC,EAAG,EAAG,OAC1B2C,EAAAA,EAAAA,KAAA,wBAAsBC,MAAM,iBAE/Bd,UACCa,EAAAA,EAAAA,KAACE,GAAmB4B,EAAAA,EAAAA,GAAA,GAAKrF,OAIjC,CAlEAkE,EAAAA,EAAQoB,QAAQ,qBAChBpB,EAAAA,EAAQoB,QAAQ,wBAChBpB,EAAAA,EAAQoB,QAAQ,qBAChBpB,EAAAA,EAAQoB,QAAQ,2BAChBpB,EAAAA,EAAQoB,QAAQ,uCAChBpB,EAAAA,EAAQoB,QAAQ,2C","sources":["../node_modules/react-error-boundary/dist/react-error-boundary.js","components/AnimatedAvatar.tsx"],"sourcesContent":["'use client';\nimport { createContext, Component, createElement, useContext, useState, useMemo, forwardRef } from 'react';\n\nconst ErrorBoundaryContext = createContext(null);\n\nconst initialState = {\n  didCatch: false,\n  error: null\n};\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n    this.state = initialState;\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      didCatch: true,\n      error\n    };\n  }\n  resetErrorBoundary() {\n    const {\n      error\n    } = this.state;\n    if (error !== null) {\n      var _this$props$onReset, _this$props;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {\n        args,\n        reason: \"imperative-api\"\n      });\n      this.setState(initialState);\n    }\n  }\n  componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      didCatch\n    } = this.state;\n    const {\n      resetKeys\n    } = this.props;\n\n    // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onReset2, _this$props3;\n      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\"\n      });\n      this.setState(initialState);\n    }\n  }\n  render() {\n    const {\n      children,\n      fallbackRender,\n      FallbackComponent,\n      fallback\n    } = this.props;\n    const {\n      didCatch,\n      error\n    } = this.state;\n    let childToRender = children;\n    if (didCatch) {\n      const props = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n      if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else if (fallback !== undefined) {\n        childToRender = fallback;\n      } else {\n        throw error;\n      }\n    }\n    return createElement(ErrorBoundaryContext.Provider, {\n      value: {\n        didCatch,\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      }\n    }, childToRender);\n  }\n}\nfunction hasArrayChanged() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));\n}\n\nfunction assertErrorBoundaryContext(value) {\n  if (value == null || typeof value.didCatch !== \"boolean\" || typeof value.resetErrorBoundary !== \"function\") {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n}\n\nfunction useErrorBoundary() {\n  const context = useContext(ErrorBoundaryContext);\n  assertErrorBoundaryContext(context);\n  const [state, setState] = useState({\n    error: null,\n    hasError: false\n  });\n  const memoized = useMemo(() => ({\n    resetBoundary: () => {\n      context.resetErrorBoundary();\n      setState({\n        error: null,\n        hasError: false\n      });\n    },\n    showBoundary: error => setState({\n      error,\n      hasError: true\n    })\n  }), [context.resetErrorBoundary]);\n  if (state.hasError) {\n    throw state.error;\n  }\n  return memoized;\n}\n\nfunction withErrorBoundary(component, errorBoundaryProps) {\n  const Wrapped = forwardRef((props, ref) => createElement(ErrorBoundary, errorBoundaryProps, createElement(component, {\n    ...props,\n    ref\n  })));\n\n  // Format for display in DevTools\n  const name = component.displayName || component.name || \"Unknown\";\n  Wrapped.displayName = \"withErrorBoundary(\".concat(name, \")\");\n  return Wrapped;\n}\n\nexport { ErrorBoundary, ErrorBoundaryContext, useErrorBoundary, withErrorBoundary };\n","import React, { useEffect, Suspense } from 'react';\nimport { useGLTF, useAnimations } from '@react-three/drei';\nimport '@react-three/fiber';\nimport { ErrorBoundary } from 'react-error-boundary';\n\ninterface AnimatedAvatarProps {\n  avatarUrl: string; // e.g. '/bro.glb'\n  animationUrl: string; // e.g. '/animations/M_Standing_Idle_001.glb' or '/animations/M_Talking_Variations_001.glb'\n  position?: [number, number, number];\n  rotation?: [number, number, number];\n  scale?: [number, number, number];\n}\n\n// Preload common avatars and animations\nuseGLTF.preload('/avatars/fool.glb');\nuseGLTF.preload('/avatars/chickie.glb');\nuseGLTF.preload('/avatars/babe.glb');\nuseGLTF.preload('/avatars/AngelChick.glb');\nuseGLTF.preload('/animations/M_Standing_Idle_001.glb');\nuseGLTF.preload('/animations/M_Talking_Variations_001.glb');\n\nfunction AvatarFallback({ error }: { error: Error }) {\n  console.error('Avatar loading error:', error);\n  return (\n    <mesh position={[0, 0, 0]}>\n      <boxGeometry args={[1, 2, 0.5]} />\n      <meshStandardMaterial color=\"gray\" />\n    </mesh>\n  );\n}\n\nfunction AnimatedAvatarInner({\n  avatarUrl,\n  animationUrl,\n  position = [0, -1.1, 0],\n  rotation = [0, 0, 0],\n  scale = [1.4, 1.4, 1.4],\n}: AnimatedAvatarProps) {\n  console.log('Loading avatar:', avatarUrl, 'with animation:', animationUrl);\n  \n  const { scene: avatar } = useGLTF(avatarUrl);\n  const { animations: animClips } = useGLTF(animationUrl);\n  const { actions } = useAnimations(animClips, avatar);\n\n  useEffect(() => {\n    if (actions && animClips.length > 0) {\n      console.log('Playing animation:', animClips[0].name);\n      actions[animClips[0].name]?.reset().fadeIn(0.2).play();\n    } else {\n      console.log('No animations found or actions not ready');\n    }\n    return () => {\n      Object.values(actions).forEach((action) => action?.stop());\n    };\n  }, [actions, animClips]);\n\n  if (!avatar) {\n    console.error('Avatar not loaded:', avatarUrl);\n    return null;\n  }\n  \n  return (\n    // @ts-ignore\n    <primitive object={avatar} scale={scale} position={position} rotation={rotation} />\n  );\n}\n\nexport function AnimatedAvatar(props: AnimatedAvatarProps) {\n  return (\n    <ErrorBoundary fallbackRender={({ error }) => <AvatarFallback error={error} />}>\n      <Suspense fallback={\n        <mesh position={props.position}>\n          <boxGeometry args={[1, 2, 0.5]} />\n          <meshStandardMaterial color=\"lightgray\" />\n        </mesh>\n      }>\n        <AnimatedAvatarInner {...props} />\n      </Suspense>\n    </ErrorBoundary>\n  );\n}\n"],"names":["ErrorBoundaryContext","createContext","initialState","didCatch","error","ErrorBoundary","Component","constructor","props","super","this","resetErrorBoundary","bind","state","getDerivedStateFromError","_this$props$onReset","_this$props","_len","arguments","length","args","Array","_key","onReset","call","reason","setState","componentDidCatch","info","_this$props$onError","_this$props2","onError","componentDidUpdate","prevProps","prevState","resetKeys","_this$props$onReset2","_this$props3","a","undefined","b","some","item","index","Object","is","hasArrayChanged","next","prev","render","children","fallbackRender","FallbackComponent","fallback","childToRender","createElement","Provider","value","AvatarFallback","_ref","console","_jsxs","position","_jsx","color","AnimatedAvatarInner","_ref2","avatarUrl","animationUrl","rotation","scale","log","scene","avatar","useGLTF","animations","animClips","actions","useAnimations","useEffect","_actions$animClips$0$","name","reset","fadeIn","play","values","forEach","action","stop","object","AnimatedAvatar","_ref3","Suspense","_objectSpread","preload"],"sourceRoot":""}