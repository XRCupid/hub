{"version":3,"file":"static/js/8228.132cba74.chunk.js","mappings":"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","sources":["components/IdlePoseFullBodyAvatar.tsx"],"sourcesContent":["import React, { useRef, useEffect, useMemo, useState } from 'react';\nimport * as THREE from 'three';\nimport { useFrame, useGraph } from '@react-three/fiber';\nimport { useGLTF } from '@react-three/drei';\nimport { SkeletonUtils } from 'three-stdlib';\nimport type { TrackingData } from '../types/tracking';\n\n// Define PostureData type inline\ninterface PostureKeypoint {\n  x: number;\n  y: number;\n  confidence: number;\n}\n\ninterface PostureData {\n  keypoints: {\n    [key: string]: PostureKeypoint;\n  };\n  confidence: number;\n}\n\ninterface IdlePoseFullBodyAvatarProps {\n  avatarUrl: string;\n  trackingData?: TrackingData;\n  postureData?: PostureData;\n  position?: [number, number, number];\n  scale?: number;\n  debugMode?: boolean;\n}\n\nexport const IdlePoseFullBodyAvatar: React.FC<IdlePoseFullBodyAvatarProps> = ({\n  avatarUrl,\n  trackingData,\n  postureData,\n  position = [0, 0, 0],\n  scale = 1,\n  debugMode = true\n}) => {\n  const groupRef = useRef<THREE.Group>(null);\n  const { scene } = useGLTF(avatarUrl);\n  \n  // Clone the scene\n  const clonedScene = useMemo(() => {\n    const cloned = SkeletonUtils.clone(scene);\n    return cloned;\n  }, [scene]);\n  \n  // Bone references\n  const headBone = useRef<THREE.Bone | null>(null);\n  const neckBone = useRef<THREE.Bone | null>(null);\n  const leftShoulderBone = useRef<THREE.Bone | null>(null);\n  const rightShoulderBone = useRef<THREE.Bone | null>(null);\n  const leftArmBone = useRef<THREE.Bone | null>(null);\n  const rightArmBone = useRef<THREE.Bone | null>(null);\n  const leftForeArmBone = useRef<THREE.Bone | null>(null);\n  const rightForeArmBone = useRef<THREE.Bone | null>(null);\n  const meshWithMorphTargets = useRef<THREE.Mesh | null>(null);\n  \n  // Store idle pose rotations (after manual setup)\n  const idleRotations = useRef<Record<string, THREE.Quaternion>>({});\n  const idleEulers = useRef<Record<string, THREE.Euler>>({});\n  \n  // Debug spheres\n  const debugSpheres = useRef<Record<string, THREE.Mesh>>({});\n  const frameCount = useRef(0);\n  \n  // Find bones and setup\n  useEffect(() => {\n    if (!clonedScene) return;\n    \n    console.log('[IdlePoseFullBodyAvatar] Starting bone search...');\n    \n    // Find bones\n    clonedScene.traverse((child) => {\n      if (child instanceof THREE.Bone) {\n        const name = child.name.toLowerCase();\n        console.log('[IdlePoseFullBodyAvatar] Found bone:', child.name);\n        \n        // Head\n        if (name.includes('head') && !name.includes('headtop')) {\n          headBone.current = child;\n        }\n        \n        // Shoulders\n        if (name.includes('leftshoulder') || name.includes('shoulder_l')) {\n          leftShoulderBone.current = child;\n        }\n        if (name.includes('rightshoulder') || name.includes('shoulder_r')) {\n          rightShoulderBone.current = child;\n        }\n        \n        // Arms (upper arm)\n        if ((name.includes('leftarm') || name.includes('arm_l') || name.includes('leftupperarm') || name.includes('upperarm_l')) && !name.includes('fore')) {\n          leftArmBone.current = child;\n        }\n        if ((name.includes('rightarm') || name.includes('arm_r') || name.includes('rightupperarm') || name.includes('upperarm_r')) && !name.includes('fore')) {\n          rightArmBone.current = child;\n        }\n        \n        // Forearms\n        if (name.includes('leftforearm') || name.includes('forearm_l') || name.includes('leftlowerarm') || name.includes('lowerarm_l')) {\n          leftForeArmBone.current = child;\n        }\n        if (name.includes('rightforearm') || name.includes('forearm_r') || name.includes('rightlowerarm') || name.includes('lowerarm_r')) {\n          rightForeArmBone.current = child;\n        }\n        \n        // Neck\n        if (name.includes('neck')) {\n          neckBone.current = child;\n        }\n      } else if (child instanceof THREE.SkinnedMesh && child.morphTargetDictionary) {\n        meshWithMorphTargets.current = child as THREE.Mesh;\n      }\n    });\n    \n    console.log('[IdlePoseFullBodyAvatar] Bone search complete:', {\n      head: !!headBone.current,\n      neck: !!neckBone.current,\n      leftShoulder: !!leftShoulderBone.current,\n      rightShoulder: !!rightShoulderBone.current,\n      leftArm: !!leftArmBone.current,\n      rightArm: !!rightArmBone.current,\n      leftForeArm: !!leftForeArmBone.current,\n      rightForeArm: !!rightForeArmBone.current\n    });\n    \n    // Set manual idle pose\n    if (leftArmBone.current) {\n      // Rotate arm down and slightly forward\n      leftArmBone.current.rotation.z = Math.PI / 3; // 60 degrees down\n      leftArmBone.current.rotation.y = -Math.PI / 8; // Slightly forward\n    }\n    if (rightArmBone.current) {\n      // Rotate arm down and slightly forward\n      rightArmBone.current.rotation.z = -Math.PI / 3; // 60 degrees down\n      rightArmBone.current.rotation.y = Math.PI / 8; // Slightly forward\n    }\n    if (leftForeArmBone.current) {\n      leftForeArmBone.current.rotation.y = Math.PI / 6; // Slight bend\n    }\n    if (rightForeArmBone.current) {\n      rightForeArmBone.current.rotation.y = -Math.PI / 6; // Slight bend\n    }\n    \n    // Store idle rotations after setting them\n    setTimeout(() => {\n      if (leftArmBone.current) {\n        idleRotations.current['leftArm'] = leftArmBone.current.quaternion.clone();\n        idleEulers.current['leftArm'] = leftArmBone.current.rotation.clone();\n      }\n      if (rightArmBone.current) {\n        idleRotations.current['rightArm'] = rightArmBone.current.quaternion.clone();\n        idleEulers.current['rightArm'] = rightArmBone.current.rotation.clone();\n      }\n      if (leftForeArmBone.current) {\n        idleRotations.current['leftForeArm'] = leftForeArmBone.current.quaternion.clone();\n        idleEulers.current['leftForeArm'] = leftForeArmBone.current.rotation.clone();\n      }\n      if (rightForeArmBone.current) {\n        idleRotations.current['rightForeArm'] = rightForeArmBone.current.quaternion.clone();\n        idleEulers.current['rightForeArm'] = rightForeArmBone.current.rotation.clone();\n      }\n      \n      console.log('[IdlePoseFullBodyAvatar] Stored idle pose rotations');\n    }, 100);\n    \n    // Create debug spheres\n    if (debugMode && groupRef.current) {\n      const colors = {\n        shoulder: 0xff0000, // Red\n        elbow: 0x00ff00,    // Green\n        wrist: 0x0000ff     // Blue\n      };\n      \n      ['leftShoulder', 'rightShoulder', 'leftElbow', 'rightElbow', 'leftWrist', 'rightWrist'].forEach(name => {\n        const geometry = new THREE.SphereGeometry(0.05);\n        const color = name.includes('Shoulder') ? colors.shoulder : \n                     name.includes('Elbow') ? colors.elbow : colors.wrist;\n        const material = new THREE.MeshBasicMaterial({ color });\n        const sphere = new THREE.Mesh(geometry, material);\n        sphere.visible = false;\n        groupRef.current!.add(sphere);\n        debugSpheres.current[name] = sphere;\n      });\n    }\n  }, [clonedScene, debugMode]);\n  \n  // Apply tracking data\n  useFrame(() => {\n    frameCount.current++;\n    \n    // Apply posture tracking to arms\n    if (postureData && postureData.keypoints) {\n      const keypoints = postureData.keypoints;\n      \n      // Left arm tracking\n      const leftShoulder = keypoints.leftShoulder;\n      const leftElbow = keypoints.leftElbow;\n      const leftWrist = keypoints.leftWrist;\n      \n      if (leftShoulder && leftShoulder.confidence > 0.05 && leftArmBone.current) {\n        // Update debug sphere\n        if (debugSpheres.current.leftShoulder) {\n          debugSpheres.current.leftShoulder.position.set(\n            (leftShoulder.x / 640 - 0.5) * 2,\n            -(leftShoulder.y / 480 - 0.5) * 2,\n            0\n          );\n          debugSpheres.current.leftShoulder.visible = true;\n        }\n        \n        if (leftWrist && leftWrist.confidence > 0.05) {\n          // Update wrist debug sphere\n          if (debugSpheres.current.leftWrist) {\n            debugSpheres.current.leftWrist.position.set(\n              (leftWrist.x / 640 - 0.5) * 2,\n              -(leftWrist.y / 480 - 0.5) * 2,\n              0\n            );\n            debugSpheres.current.leftWrist.visible = true;\n          }\n          \n          // Calculate arm direction\n          const shoulderPos = new THREE.Vector3(\n            leftShoulder.x / 640 - 0.5,\n            -(leftShoulder.y / 480 - 0.5),\n            0\n          ).normalize();\n          \n          const wristPos = new THREE.Vector3(\n            leftWrist.x / 640 - 0.5,\n            -(leftWrist.y / 480 - 0.5),\n            -0.2\n          ).normalize();\n          \n          const armDir = wristPos.sub(shoulderPos).normalize();\n          \n          // Get idle rotation\n          const idleRotation = idleRotations.current['leftArm'] || new THREE.Quaternion();\n          \n          // Calculate rotation from idle direction to target direction\n          const idleDir = new THREE.Vector3(-0.7, -0.7, 0).normalize(); // Approximate idle arm direction\n          const trackingRotation = new THREE.Quaternion().setFromUnitVectors(idleDir, armDir);\n          \n          // Apply as offset to idle rotation\n          const finalRotation = idleRotation.clone().multiply(trackingRotation);\n          leftArmBone.current.quaternion.slerp(finalRotation, 0.3);\n          \n          // Handle elbow if detected\n          if (leftElbow && leftElbow.confidence > 0.05 && leftForeArmBone.current) {\n            if (debugSpheres.current.leftElbow) {\n              debugSpheres.current.leftElbow.position.set(\n                (leftElbow.x / 640 - 0.5) * 2,\n                -(leftElbow.y / 480 - 0.5) * 2,\n                0\n              );\n              debugSpheres.current.leftElbow.visible = true;\n            }\n            \n            // Calculate elbow bend\n            const elbowPos = new THREE.Vector3(\n              leftElbow.x / 640 - 0.5,\n              -(leftElbow.y / 480 - 0.5),\n              -0.1\n            );\n            \n            const upperArmVec = elbowPos.clone().sub(shoulderPos).normalize();\n            const forearmVec = wristPos.clone().sub(elbowPos).normalize();\n            const bendAngle = Math.acos(Math.max(-1, Math.min(1, upperArmVec.dot(forearmVec))));\n            \n            // Apply elbow bend relative to idle pose\n            const idleForearmRotation = idleRotations.current['leftForeArm'] || new THREE.Quaternion();\n            const bendRotation = new THREE.Quaternion().setFromAxisAngle(\n              new THREE.Vector3(0, 0, -1),\n              Math.min(bendAngle * 0.8, Math.PI * 0.8)\n            );\n            const finalForearmRotation = idleForearmRotation.clone().multiply(bendRotation);\n            leftForeArmBone.current.quaternion.slerp(finalForearmRotation, 0.3);\n          }\n        } else {\n          // Return to idle pose smoothly\n          if (idleRotations.current['leftArm']) {\n            leftArmBone.current.quaternion.slerp(idleRotations.current['leftArm'], 0.1);\n          }\n          if (leftForeArmBone.current && idleRotations.current['leftForeArm']) {\n            leftForeArmBone.current.quaternion.slerp(idleRotations.current['leftForeArm'], 0.1);\n          }\n          \n          // Hide debug spheres\n          if (debugSpheres.current.leftWrist) debugSpheres.current.leftWrist.visible = false;\n          if (debugSpheres.current.leftElbow) debugSpheres.current.leftElbow.visible = false;\n        }\n      }\n      \n      // Right arm tracking (mirror of left)\n      const rightShoulder = keypoints.rightShoulder;\n      const rightElbow = keypoints.rightElbow;\n      const rightWrist = keypoints.rightWrist;\n      \n      if (rightShoulder && rightShoulder.confidence > 0.05 && rightArmBone.current) {\n        // Update debug sphere\n        if (debugSpheres.current.rightShoulder) {\n          debugSpheres.current.rightShoulder.position.set(\n            (rightShoulder.x / 640 - 0.5) * 2,\n            -(rightShoulder.y / 480 - 0.5) * 2,\n            0\n          );\n          debugSpheres.current.rightShoulder.visible = true;\n        }\n        \n        if (rightWrist && rightWrist.confidence > 0.05) {\n          // Update wrist debug sphere\n          if (debugSpheres.current.rightWrist) {\n            debugSpheres.current.rightWrist.position.set(\n              (rightWrist.x / 640 - 0.5) * 2,\n              -(rightWrist.y / 480 - 0.5) * 2,\n              0\n            );\n            debugSpheres.current.rightWrist.visible = true;\n          }\n          \n          // Calculate arm direction\n          const shoulderPos = new THREE.Vector3(\n            rightShoulder.x / 640 - 0.5,\n            -(rightShoulder.y / 480 - 0.5),\n            0\n          ).normalize();\n          \n          const wristPos = new THREE.Vector3(\n            rightWrist.x / 640 - 0.5,\n            -(rightWrist.y / 480 - 0.5),\n            -0.2\n          ).normalize();\n          \n          const armDir = wristPos.sub(shoulderPos).normalize();\n          \n          // Get idle rotation\n          const idleRotation = idleRotations.current['rightArm'] || new THREE.Quaternion();\n          \n          // Calculate rotation from idle direction to target direction\n          const idleDir = new THREE.Vector3(0.7, -0.7, 0).normalize(); // Approximate idle arm direction\n          const trackingRotation = new THREE.Quaternion().setFromUnitVectors(idleDir, armDir);\n          \n          // Apply as offset to idle rotation\n          const finalRotation = idleRotation.clone().multiply(trackingRotation);\n          rightArmBone.current.quaternion.slerp(finalRotation, 0.3);\n          \n          // Handle elbow if detected\n          if (rightElbow && rightElbow.confidence > 0.05 && rightForeArmBone.current) {\n            if (debugSpheres.current.rightElbow) {\n              debugSpheres.current.rightElbow.position.set(\n                (rightElbow.x / 640 - 0.5) * 2,\n                -(rightElbow.y / 480 - 0.5) * 2,\n                0\n              );\n              debugSpheres.current.rightElbow.visible = true;\n            }\n            \n            // Calculate elbow bend\n            const elbowPos = new THREE.Vector3(\n              rightElbow.x / 640 - 0.5,\n              -(rightElbow.y / 480 - 0.5),\n              -0.1\n            );\n            \n            const upperArmVec = elbowPos.clone().sub(shoulderPos).normalize();\n            const forearmVec = wristPos.clone().sub(elbowPos).normalize();\n            const bendAngle = Math.acos(Math.max(-1, Math.min(1, upperArmVec.dot(forearmVec))));\n            \n            // Apply elbow bend relative to idle pose\n            const idleForearmRotation = idleRotations.current['rightForeArm'] || new THREE.Quaternion();\n            const bendRotation = new THREE.Quaternion().setFromAxisAngle(\n              new THREE.Vector3(0, 0, 1),\n              Math.min(bendAngle * 0.8, Math.PI * 0.8)\n            );\n            const finalForearmRotation = idleForearmRotation.clone().multiply(bendRotation);\n            rightForeArmBone.current.quaternion.slerp(finalForearmRotation, 0.3);\n          }\n        } else {\n          // Return to idle pose smoothly\n          if (idleRotations.current['rightArm']) {\n            rightArmBone.current.quaternion.slerp(idleRotations.current['rightArm'], 0.1);\n          }\n          if (rightForeArmBone.current && idleRotations.current['rightForeArm']) {\n            rightForeArmBone.current.quaternion.slerp(idleRotations.current['rightForeArm'], 0.1);\n          }\n          \n          // Hide debug spheres\n          if (debugSpheres.current.rightWrist) debugSpheres.current.rightWrist.visible = false;\n          if (debugSpheres.current.rightElbow) debugSpheres.current.rightElbow.visible = false;\n        }\n      }\n    }\n    \n    // Apply head tracking from TrackingData\n    if (trackingData && trackingData.headRotation && headBone.current) {\n      const { pitch, yaw, roll } = trackingData.headRotation;\n      \n      // Apply rotation with damping\n      const targetRotation = new THREE.Euler(\n        pitch * 0.5,\n        yaw * 0.7,\n        roll * 0.3,\n        'XYZ'\n      );\n      \n      headBone.current.rotation.x = THREE.MathUtils.lerp(headBone.current.rotation.x, targetRotation.x, 0.1);\n      headBone.current.rotation.y = THREE.MathUtils.lerp(headBone.current.rotation.y, targetRotation.y, 0.1);\n      headBone.current.rotation.z = THREE.MathUtils.lerp(headBone.current.rotation.z, targetRotation.z, 0.1);\n    }\n    \n    // Apply facial expressions\n    if (trackingData && trackingData.expressions && meshWithMorphTargets.current) {\n      const mesh = meshWithMorphTargets.current;\n      if (mesh.morphTargetDictionary && mesh.morphTargetInfluences) {\n        Object.entries(trackingData.expressions).forEach(([expression, value]) => {\n          const morphIndex = mesh.morphTargetDictionary![expression];\n          if (morphIndex !== undefined) {\n            mesh.morphTargetInfluences![morphIndex] = value;\n          }\n        });\n      }\n    }\n  });\n  \n  return (\n    <group ref={groupRef} position={position} scale={scale}>\n      {clonedScene && <primitive object={clonedScene} />}\n    </group>\n  );\n};\n"],"names":["IdlePoseFullBodyAvatar","_ref","avatarUrl","trackingData","postureData","position","scale","debugMode","groupRef","useRef","scene","useGLTF","clonedScene","useMemo","SkeletonUtils","clone","headBone","neckBone","leftShoulderBone","rightShoulderBone","leftArmBone","rightArmBone","leftForeArmBone","rightForeArmBone","meshWithMorphTargets","idleRotations","idleEulers","debugSpheres","frameCount","useEffect","console","log","traverse","child","THREE","name","toLowerCase","includes","current","morphTargetDictionary","head","neck","leftShoulder","rightShoulder","leftArm","rightArm","leftForeArm","rightForeArm","rotation","z","Math","PI","y","setTimeout","quaternion","colors","shoulder","elbow","wrist","forEach","geometry","color","material","sphere","visible","add","useFrame","keypoints","leftElbow","leftWrist","confidence","set","x","shoulderPos","normalize","wristPos","armDir","sub","idleRotation","idleDir","trackingRotation","setFromUnitVectors","finalRotation","multiply","slerp","elbowPos","upperArmVec","forearmVec","bendAngle","acos","max","min","dot","idleForearmRotation","bendRotation","setFromAxisAngle","finalForearmRotation","rightElbow","rightWrist","headRotation","pitch","yaw","roll","targetRotation","lerp","expressions","mesh","morphTargetInfluences","Object","entries","_ref2","expression","value","morphIndex","undefined","_jsx","ref","children","object"],"sourceRoot":""}