{"version":3,"file":"static/js/102.08b3b579.chunk.js","mappings":"oNAwBA,MAAMA,EAAsBC,EAAAA,YAC1B,CAAAC,EAA2HC,KAAS,IAAnI,SAAEC,EAAQ,YAAEC,EAAW,SAAEC,EAAQ,MAAEC,EAAK,cAAEC,EAAa,qBAAEC,EAAoB,WAAEC,EAAU,WAAEC,EAAU,gBAAEC,GAAiBV,EACvH,MAAMW,GAAWC,EAAAA,EAAAA,QAAoB,OAE/B,MAAEC,EAAK,WAAEC,IAAeC,EAAAA,EAAAA,GAAQb,IAChC,QAAEc,EAAO,MAAEC,IAAUC,EAAAA,EAAAA,GAAcJ,EAAYH,GA0DrD,OAvDAQ,EAAAA,EAAAA,qBAAoBlB,GAAK,IAAMU,EAASS,WAGxCC,EAAAA,EAAAA,YAAU,KACJR,GAASF,EAASS,SAAWd,GAC/BA,EAAcK,EAASS,QAASN,KAEjC,CAACD,EAAOC,EAAYR,KAGvBe,EAAAA,EAAAA,YAAU,KACJV,EAASS,SAAWjB,GACtBQ,EAASS,QAAQE,UAAUC,IACrBA,aAAkBC,EAAAA,aAAqBD,EAAOE,uBAChDC,OAAOC,KAAKxB,GAAayB,SAASC,IAChC,MAAMC,EAAQ3B,EAAY0B,GACpBE,EAAQR,EAAOE,sBAAuBI,QAC9BG,IAAVD,QAAiCC,IAAVF,IACzBP,EAAOU,sBAAuBF,GAASP,EAAAA,UAAgBU,MAAMJ,EAAO,EAAG,YAMhF,CAAC3B,KAGJkB,EAAAA,EAAAA,YAAU,KACR,GAAIL,GAAWT,EAAsB,CACnC,MAAM4B,EAAgBnB,EAAQT,GAQ+B,IAAD6B,EAP5D,GAAID,EAEFlB,EAAMoB,gBACNF,EAAcG,QAAQC,OAAO,IAAKC,YAIlC,GAFAC,QAAQC,KAAK,oCAADC,OAAqCpC,EAAoB,iBAEjEO,EAAW8B,OAAS,GAAK5B,EAAQF,EAAW,GAAG+B,MACtB,QAA3BT,EAAApB,EAAQF,EAAW,GAAG+B,aAAK,IAAAT,GAA3BA,EAA6BE,QAAQC,OAAO,IAAKC,MAGvD,MAAO,GAAIxB,GAAWF,EAAW8B,OAAS,GAAK5B,EAAQF,EAAW,GAAG+B,MAAO,CAAC,IAADC,EAE/C,QAA3BA,EAAA9B,EAAQF,EAAW,GAAG+B,aAAK,IAAAC,GAA3BA,EAA6BR,QAAQC,OAAO,IAAKC,MACnD,CAEA,MAAO,KAEiC,IAADO,EAAjC/B,GAAWT,IACgB,QAA7BwC,EAAA/B,EAAQT,UAAqB,IAAAwC,GAA7BA,EAA+BC,QAAQ,QAG1C,CAAChC,EAASF,EAAYG,EAAOV,KAI9B0C,EAAAA,EAAAA,KAAA,aACE1B,OAAQV,EACRZ,IAAKU,EACLP,SAAUA,EACVC,MAAOA,EACP6C,QAAS,UAMjBpD,EAAoBqD,YAAc,sBAClC,UAGaC,EAA+BC,IAExCC,EAAAA,EAAAA,MAAA,QAAMlD,SAAUiD,EAAMjD,SAAUC,MAAOgD,EAAMhD,MAAMkD,SAAA,EACjDN,EAAAA,EAAAA,KAAA,eAAaO,KAAM,CAAC,GAAK,GAAK,OAC9BP,EAAAA,EAAAA,KAAA,wBAAsBQ,MAAM,a","sources":["components/ReadyPlayerMeAvatar.tsx"],"sourcesContent":["import React, { useRef, useEffect, useImperativeHandle } from 'react';\nimport { useGLTF, useAnimations } from '@react-three/drei';\nimport * as THREE from 'three';\nimport { GLTF } from 'three-stdlib';\n\nexport interface ReadyPlayerMeAvatarProps {\n  modelUrl: string;\n  blendShapes?: Record<string, number>;\n  enableHeadMovement?: boolean; // Placeholder for now\n  position?: [number, number, number];\n  scale?: [number, number, number] | number;\n  onModelLoaded?: (model: THREE.Group, animations: THREE.AnimationClip[]) => void;\n  currentAnimationName?: string; // To control which animation plays\n  isSpeaking?: boolean; // Added for speaking state\n  visemeData?: Record<string, number>; // Added for viseme data\n  additionalClips?: THREE.AnimationClip[]; // Added for additional animation clips\n}\n\n// Extend GLTF type to include nodes and materials if specific access is needed\ninterface ExtendedGLTF extends GLTF {\n  nodes: { [name: string]: THREE.SkinnedMesh | THREE.Mesh | THREE.Object3D };\n  materials: { [name: string]: THREE.Material };\n}\n\nconst ReadyPlayerMeAvatar = React.forwardRef<THREE.Group, ReadyPlayerMeAvatarProps>(\n  ({ modelUrl, blendShapes, position, scale, onModelLoaded, currentAnimationName, isSpeaking, visemeData, additionalClips }, ref) => {\n    const groupRef = useRef<THREE.Group>(null!); // Initialized by primitive\n    // Explicitly cast the result of useGLTF\n    const { scene, animations } = useGLTF(modelUrl) as ExtendedGLTF; \n    const { actions, mixer } = useAnimations(animations, groupRef);\n\n    // Expose the group ref to the parent component (e.g., SimulationAvatar3D)\n    useImperativeHandle(ref, () => groupRef.current);\n\n    // Notify parent when model is loaded\n    useEffect(() => {\n      if (scene && groupRef.current && onModelLoaded) {\n        onModelLoaded(groupRef.current, animations);\n      }\n    }, [scene, animations, onModelLoaded]);\n\n    // Apply blendshapes\n    useEffect(() => {\n      if (groupRef.current && blendShapes) {\n        groupRef.current.traverse((object) => {\n          if (object instanceof THREE.SkinnedMesh && object.morphTargetDictionary) {\n            Object.keys(blendShapes).forEach((key) => {\n              const value = blendShapes[key];\n              const index = object.morphTargetDictionary![key];\n              if (index !== undefined && value !== undefined) {\n                object.morphTargetInfluences![index] = THREE.MathUtils.clamp(value, 0, 1);\n              }\n            });\n          }\n        });\n      }\n    }, [blendShapes]); // Dependency: scene is implicit via groupRef.current\n\n    // Animation control\n    useEffect(() => {\n      if (actions && currentAnimationName) {\n        const currentAction = actions[currentAnimationName];\n        if (currentAction) {\n          // Fade in the new animation and fade out others\n          mixer.stopAllAction(); // Stop all other animations\n          currentAction.reset().fadeIn(0.3).play();\n        } else {\n          console.warn(`[ReadyPlayerMeAvatar] Animation \"${currentAnimationName}\" not found.`);\n          // Optionally play a default animation or do nothing\n          if (animations.length > 0 && actions[animations[0].name]) {\n            actions[animations[0].name]?.reset().fadeIn(0.3).play(); // Play first animation as fallback\n          }\n        }\n      } else if (actions && animations.length > 0 && actions[animations[0].name]) {\n        // If no currentAnimationName is provided, play the first animation by default\n        actions[animations[0].name]?.reset().fadeIn(0.3).play();\n      }\n\n      return () => {\n        // Fade out the current animation when component unmounts or animation changes\n        if (actions && currentAnimationName) {\n          actions[currentAnimationName]?.fadeOut(0.3);\n        }\n      };\n    }, [actions, animations, mixer, currentAnimationName]);\n\n    // Note: useGLTF is suspenseful, so <React.Suspense> must be used by the parent.\n    return (\n      <primitive\n        object={scene}\n        ref={groupRef}\n        position={position}\n        scale={scale}\n        dispose={null} // Important: Drei's useGLTF handles disposal by default\n      />\n    );\n  }\n);\n\nReadyPlayerMeAvatar.displayName = 'ReadyPlayerMeAvatar';\nexport default ReadyPlayerMeAvatar;\n\n// Export the ultra-minimal version too, in case it's needed for other tests, but rename it.\nexport const ReadyPlayerMeAvatarDebugBox = (props: Omit<ReadyPlayerMeAvatarProps, 'modelUrl'>) => {\n  return (\n    <mesh position={props.position} scale={props.scale}>\n      <boxGeometry args={[0.5, 0.5, 0.5]} />\n      <meshStandardMaterial color=\"purple\" />\n    </mesh>\n  );\n};\n\n\n"],"names":["ReadyPlayerMeAvatar","React","_ref","ref","modelUrl","blendShapes","position","scale","onModelLoaded","currentAnimationName","isSpeaking","visemeData","additionalClips","groupRef","useRef","scene","animations","useGLTF","actions","mixer","useAnimations","useImperativeHandle","current","useEffect","traverse","object","THREE","morphTargetDictionary","Object","keys","forEach","key","value","index","undefined","morphTargetInfluences","clamp","currentAction","_actions$animations$","stopAllAction","reset","fadeIn","play","console","warn","concat","length","name","_actions$animations$2","_actions$currentAnima","fadeOut","_jsx","dispose","displayName","ReadyPlayerMeAvatarDebugBox","props","_jsxs","children","args","color"],"sourceRoot":""}