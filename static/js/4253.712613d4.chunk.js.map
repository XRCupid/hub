{"version":3,"file":"static/js/4253.712613d4.chunk.js","mappings":"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","sources":["components/PresenceAvatarWithGender.tsx","components/PresenceAvatarWithCanvas.tsx"],"sourcesContent":["import React, { useMemo, useRef, useEffect } from 'react';\nimport * as THREE from 'three';\nimport { useFrame, useGraph } from '@react-three/fiber';\nimport { useGLTF, useAnimations } from '@react-three/drei';\nimport { SkeletonUtils } from 'three-stdlib';\nimport { MathUtils } from 'three';\nimport type { TrackingData, FacialExpressions } from '../types/tracking';\n\nconst DEFAULT_AVATAR_URL = '/avatars/coach_grace.glb';\n\ninterface PresenceAvatarWithGenderProps {\n  avatarUrl?: string;\n  position?: [number, number, number] | THREE.Vector3;\n  scale?: number;\n  trackingData?: TrackingData;\n  animationName?: string;\n  emotionalBlendshapes?: Record<string, number>;\n  audioData?: Uint8Array;\n  participantId?: string;\n  gender?: 'male' | 'female'; // Allow explicit gender override\n}\n\n// Hume to RPM blendshape mapping with amplification factors\nconst HUME_TO_RPM_MAPPING: Record<string, { target: string; amplify?: number }> = {\n  'browInnerUp': { target: 'browInnerUp', amplify: 1.5 },\n  'browDownLeft': { target: 'browDownLeft', amplify: 1.8 },\n  'browDownRight': { target: 'browDownRight', amplify: 1.8 },\n  'browOuterUpLeft': { target: 'browOuterUpLeft', amplify: 1.5 },\n  'browOuterUpRight': { target: 'browOuterUpRight', amplify: 1.5 },\n  'mouthSmileLeft': { target: 'mouthSmileLeft', amplify: 2.5 },\n  'mouthSmileRight': { target: 'mouthSmileRight', amplify: 2.5 },\n  'mouthFrownLeft': { target: 'mouthFrownLeft', amplify: 2.2 },\n  'mouthFrownRight': { target: 'mouthFrownRight', amplify: 2.2 },\n  'mouthOpen': { target: 'mouthOpen', amplify: 1.0 },\n  'mouthPucker': { target: 'mouthPucker', amplify: 1.8 },\n  'mouthLeft': { target: 'mouthLeft', amplify: 1.5 },\n  'mouthRight': { target: 'mouthRight', amplify: 1.5 },\n  'eyeSquintLeft': { target: 'eyeSquintLeft', amplify: 1.4 },\n  'eyeSquintRight': { target: 'eyeSquintRight', amplify: 1.4 },\n  'eyeWideLeft': { target: 'eyeWideLeft', amplify: 1.2 },\n  'eyeWideRight': { target: 'eyeWideRight', amplify: 1.2 },\n  'cheekPuff': { target: 'cheekPuff', amplify: 1.5 },\n  'cheekSquintLeft': { target: 'cheekSquintLeft', amplify: 1.3 },\n  'cheekSquintRight': { target: 'cheekSquintRight', amplify: 1.3 },\n  'noseSneerLeft': { target: 'noseSneerLeft', amplify: 1.5 },\n  'noseSneerRight': { target: 'noseSneerRight', amplify: 1.5 },\n  'jawOpen': { target: 'jawOpen', amplify: 1.0 },\n  'jawLeft': { target: 'jawLeft', amplify: 1.2 },\n  'jawRight': { target: 'jawRight', amplify: 1.2 }\n};\n\n// Emotion to blendshape mapping\nconst EMOTION_TO_BLENDSHAPE: Record<string, string[]> = {\n  joy: ['mouthSmileLeft', 'mouthSmileRight', 'cheekSquintLeft', 'cheekSquintRight'],\n  sadness: ['mouthFrownLeft', 'mouthFrownRight', 'browDownLeft', 'browDownRight'],\n  anger: ['browDownLeft', 'browDownRight', 'noseSneerLeft', 'noseSneerRight'],\n  fear: ['eyeWideLeft', 'eyeWideRight', 'browInnerUp', 'mouthOpen'],\n  surprise: ['eyeWideLeft', 'eyeWideRight', 'browOuterUpLeft', 'browOuterUpRight', 'mouthOpen'],\n  disgust: ['noseSneerLeft', 'noseSneerRight', 'mouthFrownLeft', 'mouthFrownRight'],\n  contempt: ['mouthLeft', 'mouthRight', 'eyeSquintLeft', 'eyeSquintRight']\n};\n\n// Head rotation limits\nconst HEAD_ROTATION_LIMITS = {\n  pitch: { min: -0.5, max: 0.5 },\n  yaw: { min: -0.7, max: 0.7 },\n  roll: { min: -0.3, max: 0.3 }\n};\n\n// Neck rotation distribution\nconst NECK_ROTATION_FACTOR = {\n  pitch: {\n    neck: 0.3,\n    head: 0.7\n  },\n  yaw: {\n    neck: 0.4,\n    head: 0.6\n  },\n  roll: {\n    neck: 0.2,\n    head: 0.8\n  }\n};\n\nfunction clampRotation(value: number, limits: { min: number; max: number }): number {\n  return Math.max(limits.min, Math.min(limits.max, value));\n}\n\nfunction lerp(current: number, target: number, factor: number): number {\n  return current + (target - current) * factor;\n}\n\nconst tempEuler = new THREE.Euler();\nconst tempQuat = new THREE.Quaternion();\nconst tempMatrix = new THREE.Matrix4();\nconst deltaMatrix = new THREE.Matrix4();\nconst targetWorldMatrix = new THREE.Matrix4();\nconst parentInverseWorldMatrix = new THREE.Matrix4();\nconst targetLocalMatrix = new THREE.Matrix4();\n\nexport const PresenceAvatarWithGender: React.FC<PresenceAvatarWithGenderProps> = React.memo(({\n  avatarUrl,\n  trackingData,\n  position = [0, 0, 0],\n  scale = 1,\n  participantId,\n  animationName = 'idle',\n  emotionalBlendshapes,\n  audioData,\n  gender\n}) => {\n  // Determine gender from avatar URL or explicit prop\n  const detectedGender = useMemo(() => {\n    if (gender) return gender;\n    \n    // Check avatar URL for gender hints\n    const url = avatarUrl?.toLowerCase() || '';\n    if (url.includes('dougie') || url.includes('male') || url.includes('_m_')) {\n      return 'male';\n    }\n    if (url.includes('grace') || url.includes('female') || url.includes('_f_')) {\n      return 'female';\n    }\n    \n    // Default to female for backward compatibility\n    return 'female';\n  }, [avatarUrl, gender]);\n\n  const isCoachAvatar = trackingData === undefined;\n  const avatarType = isCoachAvatar ? 'coach' : 'user';\n  \n  const instanceIdRef = useRef(Math.random().toString(36).substr(2, 9));\n  \n  useEffect(() => {\n    console.log(`[PresenceAvatarWithGender-${instanceIdRef.current}] Mounted:`, {\n      avatarType,\n      participantId,\n      hasTrackingData: !!trackingData,\n      avatarUrl,\n      detectedGender,\n      timestamp: Date.now()\n    });\n    return () => {\n      console.log(`[PresenceAvatarWithGender-${instanceIdRef.current}] Unmounted`);\n    };\n  }, []);\n\n  const { scene } = useGLTF(avatarUrl || DEFAULT_AVATAR_URL);\n  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);\n  const { nodes } = useGraph(clone);\n\n  // Load gender-appropriate animations\n  const genderPrefix = detectedGender === 'male' ? 'M' : 'F';\n  const idleAnimationUrl = `/animations/${genderPrefix}_Standing_Idle_001.glb`;\n  const { animations: idleAnimations } = useGLTF(idleAnimationUrl);\n\n  // Load talking animations based on gender\n  const talkingAnimationUrls = [\n    `/animations/${genderPrefix}_Talking_Variations_001.glb`,\n    `/animations/${genderPrefix}_Talking_Variations_002.glb`,\n    `/animations/${genderPrefix}_Talking_Variations_003.glb`,\n    `/animations/${genderPrefix}_Talking_Variations_004.glb`,\n    `/animations/${genderPrefix}_Talking_Variations_005.glb`,\n    `/animations/${genderPrefix}_Talking_Variations_006.glb`\n  ];\n\n  // Load all talking animations separately\n  const { animations: talking1 } = useGLTF(talkingAnimationUrls[0]);\n  const { animations: talking2 } = useGLTF(talkingAnimationUrls[1]);\n  const { animations: talking3 } = useGLTF(talkingAnimationUrls[2]);\n  const { animations: talking4 } = useGLTF(talkingAnimationUrls[3]);\n  const { animations: talking5 } = useGLTF(talkingAnimationUrls[4]);\n  const { animations: talking6 } = useGLTF(talkingAnimationUrls[5]);\n\n  // Combine all talking animations\n  const talkingAnimations = [...talking1, ...talking2, ...talking3, ...talking4, ...talking5, ...talking6];\n\n  // Preload all animations\n  talkingAnimationUrls.forEach(url => useGLTF.preload(url));\n\n  // Combine all animations\n  const allAnimations = useMemo(() => {\n    const combined = [...idleAnimations, ...talkingAnimations];\n    console.log(`[PresenceAvatarWithGender] Loaded ${combined.length} animations for ${detectedGender} avatar`);\n    return combined;\n  }, [idleAnimations, talkingAnimations, detectedGender]);\n\n  const { actions, mixer } = useAnimations(allAnimations, clone);\n\n  // Track the last talking animation to avoid repeating\n  const lastTalkingAnimationRef = useRef<string | null>(null);\n  const lastAnimationNameRef = useRef<string>('idle');\n  const animationChangeTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  \n  useEffect(() => {\n    if (!actions || Object.keys(actions).length === 0) return;\n    \n    // Debounce animation changes to prevent flickering\n    if (animationChangeTimeoutRef.current) {\n      clearTimeout(animationChangeTimeoutRef.current);\n    }\n    \n    // Only change animation if it's actually different\n    if (lastAnimationNameRef.current === animationName) {\n      return;\n    }\n    \n    animationChangeTimeoutRef.current = setTimeout(() => {\n      lastAnimationNameRef.current = animationName;\n      \n      // Stop all animations with fade out\n      Object.values(actions).forEach(action => {\n        if (action) action.fadeOut(0.3); // Smooth fade out over 0.3 seconds\n      });\n      \n      if (animationName === 'talking') {\n        // Find all talking animations\n        const talkingAnimations = Object.entries(actions).filter(([name]) => \n          name.toLowerCase().includes('talking') || name.toLowerCase().includes('talk')\n        );\n        \n        if (talkingAnimations.length > 0) {\n          console.log('[PresenceAvatarWithGender] Available talking animations:', talkingAnimations);\n          \n          // If we have multiple talking animations, pick one randomly (but not the same as last time)\n          let selectedAnimation;\n          if (talkingAnimations.length > 1) {\n            let availableAnimations = talkingAnimations.filter(([name]) => name !== lastTalkingAnimationRef.current);\n            if (availableAnimations.length === 0) availableAnimations = talkingAnimations;\n            \n            const randomIndex = Math.floor(Math.random() * availableAnimations.length);\n            selectedAnimation = availableAnimations[randomIndex];\n          } else {\n            selectedAnimation = talkingAnimations[0];\n          }\n          \n          const [animName, action] = selectedAnimation;\n          console.log('[PresenceAvatarWithGender] Playing talking animation:', animName);\n          lastTalkingAnimationRef.current = animName;\n          \n          if (action) {\n            action.reset();\n            action.setLoop(THREE.LoopRepeat, Infinity);\n            action.fadeIn(0.3); // Smooth fade in over 0.3 seconds\n            action.timeScale = 0.7; // Slow down animation to 70% speed\n            action.play();\n          }\n        }\n      } else {\n        // Play idle animation\n        const idleAnimation = Object.entries(actions).find(([name]) => \n          name.toLowerCase().includes('idle')\n        );\n        \n        if (idleAnimation) {\n          const [animName, action] = idleAnimation;\n          console.log('[PresenceAvatarWithGender] Playing idle animation:', animName);\n          if (action) {\n            action.reset();\n            action.setLoop(THREE.LoopRepeat, Infinity);\n            action.fadeIn(0.3); // Smooth fade in over 0.3 seconds\n            action.timeScale = 0.8; // Slow down idle animation to 80% speed\n            action.play();\n          }\n        }\n      }\n    }, 100);\n  }, [animationName, actions]);\n\n  // Find mesh with morph targets\n  const meshesWithMorphTargets = useRef<THREE.SkinnedMesh[]>([]);\n  const headBone = useRef<THREE.Bone | null>(null);\n  const neckBone = useRef<THREE.Bone | null>(null);\n\n  useEffect(() => {\n    meshesWithMorphTargets.current = [];\n    clone.traverse((child) => {\n      if (child instanceof THREE.SkinnedMesh && child.morphTargetDictionary) {\n        meshesWithMorphTargets.current.push(child);\n        console.log('[PresenceAvatarWithGender] Found mesh with morph targets:', child.name, Object.keys(child.morphTargetDictionary));\n      }\n      if (child instanceof THREE.Bone) {\n        if (child.name.toLowerCase().includes('head')) {\n          headBone.current = child;\n          console.log('[PresenceAvatarWithGender] Found head bone:', child.name);\n        } else if (child.name.toLowerCase().includes('neck')) {\n          neckBone.current = child;\n          console.log('[PresenceAvatarWithGender] Found neck bone:', child.name);\n        }\n      }\n    });\n  }, [clone]);\n\n  // Smooth rotation values\n  const smoothedRotation = useRef({ pitch: 0, yaw: 0, roll: 0 });\n  const ROTATION_SMOOTHING = 0.1;\n\n  // Audio analysis for lip sync\n  const audioAnalyser = useRef<{ volume: number; frequency: number }>({ volume: 0, frequency: 0 });\n  const morphTargetsDebuggedRef = useRef(false);\n  const frameCount = useRef(0);\n  \n  useFrame(() => {\n    if (meshesWithMorphTargets.current.length === 0) return;\n\n    // Analyze audio data in the render loop for real-time lip sync\n    if (audioData && audioData.length > 0) {\n      // Simple audio analysis\n      let sum = 0;\n      let max = 0;\n      for (let i = 0; i < audioData.length; i++) {\n        sum += audioData[i];\n        max = Math.max(max, audioData[i]);\n      }\n      audioAnalyser.current.volume = sum / audioData.length / 255;\n      audioAnalyser.current.frequency = max / 255;\n      \n      // Log every 60 frames (about once per second)\n      if (frameCount.current % 60 === 0) {\n        console.log('[PresenceAvatarWithGender] Audio data:', {\n          hasAudioData: true,\n          dataLength: audioData.length,\n          volume: audioAnalyser.current.volume,\n          frequency: audioAnalyser.current.frequency,\n          max: max,\n          sum: sum,\n          participantId,\n          isCoachAvatar\n        });\n      }\n    } else {\n      audioAnalyser.current.volume = 0;\n      audioAnalyser.current.frequency = 0;\n    }\n\n    frameCount.current++;\n\n    // Debug log morph targets once\n    if (!morphTargetsDebuggedRef.current) {\n      console.log('[PresenceAvatarWithGender] Morph targets found:', \n        meshesWithMorphTargets.current.map(mesh => ({\n          name: mesh.name,\n          morphTargets: Object.keys(mesh.morphTargetDictionary || {})\n        }))\n      );\n      morphTargetsDebuggedRef.current = true;\n    }\n\n    // Apply emotional blendshapes from Hume EVI\n    if (emotionalBlendshapes) {\n      meshesWithMorphTargets.current.forEach(mesh => {\n        if (!mesh.morphTargetDictionary || !mesh.morphTargetInfluences) return;\n\n        Object.entries(emotionalBlendshapes).forEach(([emotion, value]) => {\n          const blendshapes = EMOTION_TO_BLENDSHAPE[emotion];\n          if (blendshapes) {\n            blendshapes.forEach(blendshape => {\n              const mapping = HUME_TO_RPM_MAPPING[blendshape];\n              if (mapping && mesh.morphTargetDictionary) {\n                const morphIndex = mesh.morphTargetDictionary[mapping.target];\n                if (morphIndex !== undefined && mesh.morphTargetInfluences) {\n                  const amplifiedValue = value * (mapping.amplify || 1.0);\n                  mesh.morphTargetInfluences[morphIndex] = MathUtils.clamp(amplifiedValue, 0, 1);\n                }\n              }\n            });\n          }\n        });\n      });\n    }\n\n    // Apply lip sync from audio data\n    if (audioData && audioData.length > 0) {\n      // Log audio analysis values periodically\n      if (Math.random() < 0.01) { // Log ~1% of frames\n        console.log('[PresenceAvatarWithGender] Audio analysis:', {\n          volume: audioAnalyser.current.volume,\n          frequency: audioAnalyser.current.frequency,\n          audioDataLength: audioData.length,\n          isCoachAvatar,\n          gender: detectedGender\n        });\n      }\n\n      meshesWithMorphTargets.current.forEach(mesh => {\n        if (!mesh.morphTargetDictionary || !mesh.morphTargetInfluences) return;\n\n        // Try multiple possible jaw/mouth morph targets including RPM numbered targets\n        const possibleJawTargets = ['mouthOpen', 'jawOpen', 'viseme_aa', 'viseme_O', '0', '1'];\n        let jawTargetFound = false;\n        \n        for (const target of possibleJawTargets) {\n          if (mesh.morphTargetDictionary[target] !== undefined) {\n            const targetValue = audioAnalyser.current.volume * 0.8;\n            const morphIndex = mesh.morphTargetDictionary[target];\n            const currentValue = mesh.morphTargetInfluences[morphIndex];\n            mesh.morphTargetInfluences[morphIndex] = lerp(currentValue, targetValue, 0.3);\n            \n            // Log when we apply lip sync\n            if (Math.random() < 0.01 && targetValue > 0.01) { // Log when there's actual movement\n              console.log(`[PresenceAvatarWithGender] Applied lip sync to ${target}:`, {\n                targetValue,\n                currentValue,\n                morphIndex,\n                meshName: mesh.name\n              });\n            }\n            \n            // For RPM avatars with numbered targets, apply to secondary target\n            if (target === '0' && mesh.morphTargetDictionary['1'] !== undefined) {\n              const secondaryIndex = mesh.morphTargetDictionary['1'];\n              const secondaryValue = audioAnalyser.current.volume * 0.4;\n              mesh.morphTargetInfluences[secondaryIndex] = lerp(\n                mesh.morphTargetInfluences[secondaryIndex],\n                secondaryValue,\n                0.3\n              );\n            }\n            \n            jawTargetFound = true;\n            break;\n          }\n        }\n        \n        // Log warning if no jaw target found (only once)\n        if (!jawTargetFound && !morphTargetsDebuggedRef.current) {\n          console.warn('[PresenceAvatarWithGender] No jaw/mouth morph target found! Available targets:', Object.keys(mesh.morphTargetDictionary));\n          morphTargetsDebuggedRef.current = true;\n        }\n\n        // Map frequency to mouth shape (for non-RPM avatars)\n        const mouthSmileLeftIndex = mesh.morphTargetDictionary['mouthSmileLeft'];\n        const mouthSmileRightIndex = mesh.morphTargetDictionary['mouthSmileRight'];\n        if (mouthSmileLeftIndex !== undefined && mouthSmileRightIndex !== undefined) {\n          const smileValue = audioAnalyser.current.frequency * 0.3;\n          mesh.morphTargetInfluences[mouthSmileLeftIndex] = lerp(\n            mesh.morphTargetInfluences[mouthSmileLeftIndex],\n            smileValue,\n            0.2\n          );\n          mesh.morphTargetInfluences[mouthSmileRightIndex] = lerp(\n            mesh.morphTargetInfluences[mouthSmileRightIndex],\n            smileValue,\n            0.2\n          );\n        }\n      });\n    }\n\n    // Apply face tracking data (for user avatars)\n    if (trackingData && trackingData.rotation) {\n      const { pitch, yaw, roll } = trackingData.rotation;\n\n      // Smooth the rotation values\n      smoothedRotation.current.pitch = lerp(\n        smoothedRotation.current.pitch,\n        clampRotation(pitch, HEAD_ROTATION_LIMITS.pitch),\n        ROTATION_SMOOTHING\n      );\n      smoothedRotation.current.yaw = lerp(\n        smoothedRotation.current.yaw,\n        clampRotation(yaw, HEAD_ROTATION_LIMITS.yaw),\n        ROTATION_SMOOTHING\n      );\n      smoothedRotation.current.roll = lerp(\n        smoothedRotation.current.roll,\n        clampRotation(roll, HEAD_ROTATION_LIMITS.roll),\n        ROTATION_SMOOTHING\n      );\n\n      // Apply rotation to neck and head bones\n      if (neckBone.current) {\n        tempEuler.set(\n          smoothedRotation.current.pitch * NECK_ROTATION_FACTOR.pitch.neck,\n          smoothedRotation.current.yaw * NECK_ROTATION_FACTOR.yaw.neck,\n          smoothedRotation.current.roll * NECK_ROTATION_FACTOR.roll.neck,\n          'XYZ'\n        );\n        neckBone.current.quaternion.setFromEuler(tempEuler);\n      }\n\n      if (headBone.current) {\n        tempEuler.set(\n          smoothedRotation.current.pitch * NECK_ROTATION_FACTOR.pitch.head,\n          smoothedRotation.current.yaw * NECK_ROTATION_FACTOR.yaw.head,\n          smoothedRotation.current.roll * NECK_ROTATION_FACTOR.roll.head,\n          'XYZ'\n        );\n        headBone.current.quaternion.setFromEuler(tempEuler);\n      }\n\n      // Apply facial expressions from tracking data\n      if (trackingData.expressions) {\n        meshesWithMorphTargets.current.forEach(mesh => {\n          if (!mesh.morphTargetDictionary || !mesh.morphTargetInfluences) return;\n\n          Object.entries(trackingData.expressions!).forEach(([expression, value]) => {\n            const morphIndex = mesh.morphTargetDictionary![expression];\n            if (morphIndex !== undefined) {\n              mesh.morphTargetInfluences![morphIndex] = value;\n            }\n          });\n        });\n      }\n    }\n  });\n\n  // Convert position prop to proper Vector3 format\n  const positionVector = Array.isArray(position) && position.length === 3 \n    ? position as [number, number, number]\n    : [0, 0, 0] as [number, number, number];\n\n  return (\n    <group position={positionVector} scale={scale}>\n      <primitive object={clone} />\n    </group>\n  );\n});\n\nPresenceAvatarWithGender.displayName = 'PresenceAvatarWithGender';\n\n// Preload common avatar URLs\n[\n  '/avatars/coach_grace.glb',\n  '/avatars/Dougie.glb',\n  '/animations/M_Standing_Idle_001.glb',\n  '/animations/F_Standing_Idle_001.glb'\n].forEach(url => {\n  useGLTF.preload(url);\n});\n","import React, { Suspense } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { OrbitControls } from '@react-three/drei';\nimport { PresenceAvatarWithGender } from './PresenceAvatarWithGender';\nimport type { TrackingData } from '../types/tracking';\n\ninterface PresenceAvatarWithCanvasProps {\n  avatarUrl?: string;\n  animationName?: string;\n  emotionalBlendshapes?: Record<string, number>;\n  audioData?: Uint8Array;\n  position?: [number, number, number];\n  scale?: number;\n  trackingData?: TrackingData;\n  participantId?: string;\n  gender?: 'male' | 'female';\n}\n\nconst PresenceAvatarWithCanvas: React.FC<PresenceAvatarWithCanvasProps> = (props) => {\n  return (\n    <Canvas\n      camera={{\n        position: [0, 1.6, 3],\n        fov: 50,\n        near: 0.1,\n        far: 100\n      }}\n      style={{ width: '100%', height: '100%' }}\n    >\n      <ambientLight intensity={0.5} />\n      <directionalLight position={[10, 10, 5]} intensity={1} />\n      <directionalLight position={[-10, 10, -5]} intensity={0.5} />\n      \n      <Suspense fallback={null}>\n        <PresenceAvatarWithGender {...props} />\n      </Suspense>\n      \n      <OrbitControls\n        enablePan={false}\n        enableZoom={false}\n        minPolarAngle={Math.PI / 3}\n        maxPolarAngle={Math.PI / 2}\n        target={[0, 0, 0]}\n      />\n    </Canvas>\n  );\n};\n\nexport default PresenceAvatarWithCanvas;\n"],"names":["HUME_TO_RPM_MAPPING","target","amplify","EMOTION_TO_BLENDSHAPE","joy","sadness","anger","fear","surprise","disgust","contempt","HEAD_ROTATION_LIMITS","min","max","NECK_ROTATION_FACTOR","neck","head","clampRotation","value","limits","Math","lerp","current","factor","tempEuler","THREE","PresenceAvatarWithGender","React","_ref","avatarUrl","trackingData","position","scale","participantId","animationName","emotionalBlendshapes","audioData","gender","detectedGender","useMemo","url","toLowerCase","includes","isCoachAvatar","undefined","avatarType","instanceIdRef","useRef","random","toString","substr","useEffect","console","log","concat","hasTrackingData","timestamp","Date","now","scene","useGLTF","clone","SkeletonUtils","nodes","useGraph","genderPrefix","idleAnimationUrl","animations","idleAnimations","talkingAnimationUrls","talking1","talking2","talking3","talking4","talking5","talking6","talkingAnimations","forEach","preload","allAnimations","combined","length","actions","mixer","useAnimations","lastTalkingAnimationRef","lastAnimationNameRef","animationChangeTimeoutRef","Object","keys","clearTimeout","setTimeout","values","action","fadeOut","entries","filter","_ref2","name","selectedAnimation","availableAnimations","_ref3","floor","animName","reset","setLoop","Infinity","fadeIn","timeScale","play","idleAnimation","find","_ref4","meshesWithMorphTargets","headBone","neckBone","traverse","child","morphTargetDictionary","push","smoothedRotation","pitch","yaw","roll","audioAnalyser","volume","frequency","morphTargetsDebuggedRef","frameCount","useFrame","sum","i","hasAudioData","dataLength","map","mesh","morphTargets","morphTargetInfluences","_ref5","emotion","blendshapes","blendshape","mapping","morphIndex","amplifiedValue","MathUtils","clamp","audioDataLength","possibleJawTargets","jawTargetFound","targetValue","currentValue","meshName","secondaryIndex","secondaryValue","warn","mouthSmileLeftIndex","mouthSmileRightIndex","smileValue","rotation","set","quaternion","setFromEuler","expressions","_ref6","expression","positionVector","Array","isArray","_jsx","children","object","displayName","props","_jsxs","Canvas","camera","fov","near","far","style","width","height","intensity","Suspense","fallback","_objectSpread","OrbitControls","enablePan","enableZoom","minPolarAngle","PI","maxPolarAngle"],"sourceRoot":""}