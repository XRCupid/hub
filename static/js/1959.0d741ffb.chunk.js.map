{"version":3,"file":"static/js/1959.0d741ffb.chunk.js","mappings":"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","sources":["components/__tests__/SimulationView.test.tsx"],"sourcesContent":["import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals'; // Added Jest imports\nimport { SimulationView } from '../SimulationView';\n\n// Mock WebSocket\nconst mockWebSocketSend = jest.fn();\nconst mockWebSocketClose = jest.fn();\n\nclass MockWebSocket {\n  static instances: MockWebSocket[] = []; // To access instances\n  onopen = jest.fn();\n  onmessage = jest.fn();\n  onerror = jest.fn();\n  onclose = jest.fn();\n  send = mockWebSocketSend;\n  close = mockWebSocketClose;\n\n  constructor(url: string) {\n    MockWebSocket.instances.push(this);\n  }\n}\n\n// Clear instances before each test\nbeforeEach(() => {\n  MockWebSocket.instances = [];\n});\n\n// Mock the Web Speech API\nObject.defineProperty(window, 'SpeechRecognition', {\n  value: class MockSpeechRecognition {\n    start = jest.fn();\n    stop = jest.fn();\n    onresult = jest.fn();\n    onerror = jest.fn();\n  }\n});\n\n// Mock the speech synthesis\nObject.defineProperty(window, 'speechSynthesis', {\n  value: {\n    speak: jest.fn(),\n    cancel: jest.fn(),\n  }\n});\n\n// Mock the Avatar component (temporarily commented out as @readyplayerme/visage is removed)\n// jest.mock('@readyplayerme/visage', () => ({\n//   Avatar: ({ modelSrc, style, blendShapes }: any) => (\n//     <div data-testid=\"mock-avatar\" style={style} data-blendshapes={JSON.stringify(blendShapes || {})}>\n//       Avatar: {modelSrc}\n//     </div>\n//   )\n// }));\n\n// Mock the useAuth hook\njest.mock('@/contexts/AuthContext', () => ({\n  useAuth: () => ({\n    user: { id: 'test-user' },\n    login: jest.fn(),\n    logout: jest.fn(),\n  }),\n}));\n\ndescribe('SimulationView', () => {\n  const originalEnv = process.env;\n\n  beforeEach(() => {\n    // Reset mocks\n    jest.clearAllMocks();\n    \n    // Mock WebSocket\n    global.WebSocket = MockWebSocket as any;\n    \n    // Mock environment variables\n    process.env = {\n      ...originalEnv,\n      REACT_APP_HUME_API_KEY: 'test-api-key',\n    };\n  });\n\n  afterEach(() => {\n    // Restore original environment\n    process.env = originalEnv;\n  });\n\n  it('renders the simulation view', () => {\n    render(<SimulationView avatarModelUrl=\"test-avatar.glb\" />);\n    expect(screen.getByText('Avatar Simulation')).toBeInTheDocument();\n  });\n\n  it('sends messages through WebSocket', async () => {\n    render(<SimulationView avatarModelUrl=\"test-avatar.glb\" />);\n    \n    // Find the input and send button\n    const input = screen.getByPlaceholderText('Type a message...');\n    const sendButton = screen.getByText('Send');\n    \n    // Type a message and send it\n    fireEvent.change(input, { target: { value: 'Hello, world!' } });\n    fireEvent.click(sendButton);\n    \n    // Check if WebSocket send was called\n    await waitFor(() => {\n      // Assuming the message sent to Hume Voice is a stringified JSON\n      // The actual structure might differ based on useVoice implementation\n      expect(mockWebSocketSend).toHaveBeenCalledWith(expect.stringContaining('Hello, world!'));\n    });\n  });\n\n  it('updates avatar blendshapes on emotion change', async () => {\n    render(<SimulationView avatarModelUrl=\"test-avatar.glb\" />);\n    \n    // Simulate WebSocket connection and message\n    expect(MockWebSocket.instances.length).toBeGreaterThan(0);\n    const wsInstance = MockWebSocket.instances[0];\n    if (wsInstance.onopen) {\n      wsInstance.onopen({} as Event); // Simulate open event\n    }\n\n    // Simulate receiving an emotion message from Hume EVI (adjust structure as needed)\n    const mockEmotionEvent = {\n      data: JSON.stringify({\n        type: 'face_emotion',\n        predictions: [\n          { name: 'Joy', score: 0.9, timestamp: Date.now() }\n        ]\n      })\n    };\n    if (wsInstance.onmessage) {\n      wsInstance.onmessage(mockEmotionEvent as MessageEvent);\n    }\n    \n    // Simulate receiving emotion data\n    const mockEmotionData = {\n      type: 'emotion_data',\n      data: {\n        emotions: [\n          { name: 'happiness', score: 0.8 },\n          { name: 'neutral', score: 0.2 }\n        ]\n      }\n    };\n    \n    // Trigger WebSocket message\n    wsInstance.onmessage({ data: JSON.stringify(mockEmotionData) });\n    \n    // Check if the avatar's blendshapes were updated\n    // This part of the test depends on how EmotionDrivenAvatar passes props to SimulationAvatar3D\n    // and then to ReadyPlayerMeAvatar. We are assuming that detectedEmotions prop on EmotionDrivenAvatar\n    // will eventually lead to blendshape changes. The mock-avatar is not directly rendered by SimulationView.\n    // We need to check if the onEmotions prop of EmotionDrivenAvatar would be called.\n    // For now, let's assume the internal state leading to blendshapes is updated.\n    // This test might need more specific mocking of EmotionDrivenAvatar or its children\n    // to directly verify blendshape application if the current setup doesn't allow easy inspection.\n\n    // Placeholder: Check if a status message reflecting emotion might appear (if implemented)\n    // await waitFor(() => {\n    //   expect(screen.getByText(/Status:.*Joy/i)).toBeInTheDocument();\n    // });\n    // For now, we'll just ensure the onmessage was called.\n    expect(wsInstance.onmessage).toHaveBeenCalled();\n    // Further assertions would require deeper component mocking or integration test setup.\n    // The critical part is that the Hume EVI message is processed.\n    // We can also check if the `onEmotions` prop of `EmotionDrivenAvatar` was called if we mock it.\n    // Since `EmotionDrivenAvatar` is a child, we'd need to mock it at this level.\n    // This test needs refinement based on how we can observe the effects of emotion processing.\n  });\n});\n"],"names":["mockWebSocketSend","jest","fn","mockWebSocketClose","MockWebSocket","constructor","url","onopen","onmessage","onerror","onclose","send","close","instances","push","this","beforeEach","Object","defineProperty","window","value","start","stop","onresult","speak","cancel","mock","useAuth","user","id","login","logout","describe","originalEnv","process","clearAllMocks","global","WebSocket","_objectSpread","REACT_APP_HUME_API_KEY","afterEach","it","render","_jsx","SimulationView","avatarModelUrl","expect","screen","getByText","toBeInTheDocument","async","input","getByPlaceholderText","sendButton","fireEvent","change","target","click","waitFor","toHaveBeenCalledWith","stringContaining","length","toBeGreaterThan","wsInstance","mockEmotionEvent","data","JSON","stringify","type","predictions","name","score","timestamp","Date","now","emotions","toHaveBeenCalled"],"sourceRoot":""}