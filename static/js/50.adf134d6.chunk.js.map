{"version":3,"file":"static/js/50.adf134d6.chunk.js","mappings":"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","sources":["components/MasculinePresenceAvatar.tsx"],"sourcesContent":["import React, { useMemo, useRef, useEffect } from 'react';\nimport * as THREE from 'three';\nimport { useFrame, useGraph } from '@react-three/fiber';\nimport { useGLTF, useAnimations } from '@react-three/drei';\nimport { SkeletonUtils } from 'three-stdlib';\nimport { MathUtils } from 'three';\nimport type { TrackingData, FacialExpressions } from '../types/tracking';\n\nconst DEFAULT_AVATAR_URL = '/avatars/dougie.glb';\n\ninterface MasculinePresenceAvatarProps {\n  avatarUrl?: string;\n  position?: [number, number, number] | THREE.Vector3;\n  scale?: number; \n  trackingData?: TrackingData;\n  animationName?: string;\n  emotionalBlendshapes?: Record<string, number>;\n  audioData?: Uint8Array;\n  participantId?: string;\n}\n\n// Copy the same mapping from PresenceAvatar\nconst HUME_TO_RPM_MAPPING: Record<string, { target: string; amplify?: number }> = {\n  'browInnerUp': { target: 'browInnerUp', amplify: 1.5 },\n  'browDownLeft': { target: 'browDownLeft', amplify: 1.8 },\n  'browDownRight': { target: 'browDownRight', amplify: 1.8 },\n  'browOuterUpLeft': { target: 'browOuterUpLeft', amplify: 1.5 },\n  'browOuterUpRight': { target: 'browOuterUpRight', amplify: 1.5 },\n  'mouthSmileLeft': { target: 'mouthSmileLeft', amplify: 2.5 },\n  'mouthSmileRight': { target: 'mouthSmileRight', amplify: 2.5 },\n  'mouthFrownLeft': { target: 'mouthFrownLeft', amplify: 2.2 },\n  'mouthFrownRight': { target: 'mouthFrownRight', amplify: 2.2 },\n  'mouthOpen': { target: 'mouthOpen', amplify: 1.0 },\n  'mouthPucker': { target: 'mouthPucker', amplify: 1.8 },\n  'mouthLeft': { target: 'mouthLeft', amplify: 1.5 },\n  'mouthRight': { target: 'mouthRight', amplify: 1.5 },\n  'eyeSquintLeft': { target: 'eyeSquintLeft', amplify: 1.4 },\n  'eyeSquintRight': { target: 'eyeSquintRight', amplify: 1.4 },\n  'eyeWideLeft': { target: 'eyeWideLeft', amplify: 1.2 },\n  'eyeWideRight': { target: 'eyeWideRight', amplify: 1.2 },\n  'cheekPuff': { target: 'cheekPuff', amplify: 1.5 },\n  'cheekSquintLeft': { target: 'cheekSquintLeft', amplify: 1.3 },\n  'cheekSquintRight': { target: 'cheekSquintRight', amplify: 1.3 },\n  'noseSneerLeft': { target: 'noseSneerLeft', amplify: 1.5 },\n  'noseSneerRight': { target: 'noseSneerRight', amplify: 1.5 },\n  'jawOpen': { target: 'jawOpen', amplify: 1.0 },\n  'jawLeft': { target: 'jawLeft', amplify: 1.2 },\n  'jawRight': { target: 'jawRight', amplify: 1.2 }\n};\n\n// Emotion to blendshape mapping (same as coaches)\nconst EMOTION_TO_BLENDSHAPE: Record<string, string[]> = {\n  joy: ['mouthSmileLeft', 'mouthSmileRight', 'cheekSquintLeft', 'cheekSquintRight'],\n  sadness: ['mouthFrownLeft', 'mouthFrownRight', 'browDownLeft', 'browDownRight'],\n  anger: ['browDownLeft', 'browDownRight', 'noseSneerLeft', 'noseSneerRight'],\n  fear: ['eyeWideLeft', 'eyeWideRight', 'browInnerUp', 'mouthOpen'],\n  surprise: ['eyeWideLeft', 'eyeWideRight', 'browOuterUpLeft', 'browOuterUpRight', 'mouthOpen'],\n  disgust: ['noseSneerLeft', 'noseSneerRight', 'mouthFrownLeft', 'mouthFrownRight'],\n  contempt: ['mouthLeft', 'mouthRight', 'eyeSquintLeft', 'eyeSquintRight']\n};\n\n// Helper functions\nfunction clampRotation(value: number, limits: { min: number; max: number }): number {\n  return Math.max(limits.min, Math.min(limits.max, value));\n}\n\nfunction lerp(current: number, target: number, factor: number): number {\n  return current + (target - current) * factor;\n}\n\nconst tempEuler = new THREE.Euler();\nconst tempQuat = new THREE.Quaternion();\nconst tempMatrix = new THREE.Matrix4();\nconst deltaMatrix = new THREE.Matrix4();\n\nconst ANIMATION_PATHS = {\n  idle: [\n    '/animations/M_Standing_Idle_001.glb',\n    '/animations/M_Standing_Idle_002.glb',\n    '/animations/M_Standing_Idle_Variations_001.glb',\n    '/animations/M_Standing_Idle_Variations_002.glb',\n    '/animations/M_Standing_Idle_Variations_003.glb',\n    '/animations/M_Standing_Idle_Variations_004.glb',\n    '/animations/M_Standing_Idle_Variations_005.glb',\n    '/animations/M_Standing_Idle_Variations_006.glb',\n    '/animations/M_Standing_Idle_Variations_007.glb',\n    '/animations/M_Standing_Idle_Variations_008.glb',\n    '/animations/M_Standing_Idle_Variations_009.glb',\n    '/animations/M_Standing_Idle_Variations_010.glb'\n  ],\n  talking: [\n    '/animations/M_Talking_Variations_001.glb',\n    '/animations/M_Talking_Variations_002.glb',\n    '/animations/M_Talking_Variations_003.glb',\n    '/animations/M_Talking_Variations_004.glb',\n    '/animations/M_Talking_Variations_005.glb',\n    '/animations/M_Talking_Variations_006.glb',\n    '/animations/M_Talking_Variations_007.glb',\n    '/animations/M_Talking_Variations_008.glb',\n    '/animations/M_Talking_Variations_009.glb',\n    '/animations/M_Talking_Variations_010.glb'\n  ]\n};\n\nexport const MasculinePresenceAvatar: React.FC<MasculinePresenceAvatarProps> = ({\n  avatarUrl,\n  position = [0, 0, 0],\n  scale = 1,\n  trackingData,\n  animationName = 'idle',\n  emotionalBlendshapes,\n  audioData,\n  participantId = 'unnamed'\n}) => {\n  const isCoachAvatar = trackingData === undefined;\n  const avatarType = isCoachAvatar ? 'coach' : 'user';\n  \n  const hasEmotionalBlendshapes = emotionalBlendshapes && Object.keys(emotionalBlendshapes).length > 0;\n  \n  const groupRef = useRef<THREE.Group>(null!);\n  const modelRootRef = useRef<THREE.Object3D | null>(null);\n  const meshWithMorphTargets = useRef<THREE.Mesh | null>(null);\n  const headBone = useRef<THREE.Bone | null>(null);\n  const neckBone = useRef<THREE.Bone | null>(null);\n  const jawBone = useRef<THREE.Bone | null>(null);\n  const initialHeadLocalQuaternionRef = useRef<THREE.Quaternion | null>(null);\n  const initialNeckLocalQuaternionRef = useRef<THREE.Quaternion | null>(null);\n  const trackingDataRef = useRef<TrackingData | null>(null);\n  const frameCountRef = useRef(0);\n  const lastDebugLogRef = useRef<number>(0);\n  const morphTargetMapping = useRef<{ logged?: boolean }>({});\n  const currentInfluences = useRef<Record<string, number>>({});\n  const morphTargetsLoggedRef = useRef(false);\n  \n  const { scene } = useGLTF(avatarUrl || DEFAULT_AVATAR_URL);\n  \n  const clonedScene = useMemo(() => {\n    if (!scene) return null;\n    const cloned = SkeletonUtils.clone(scene);\n    return cloned;\n  }, [scene]);\n\n  // Load masculine idle animation\n  const { animations: idleAnimations = [] } = useGLTF(ANIMATION_PATHS.idle[0]);\n  \n  // Load talking animations individually (React hooks must be called at top level)\n  const { animations: talk1 = [] } = useGLTF(ANIMATION_PATHS.talking[0]);\n  const { animations: talk2 = [] } = useGLTF(ANIMATION_PATHS.talking[1]);\n  const { animations: talk3 = [] } = useGLTF(ANIMATION_PATHS.talking[2]);\n  const { animations: talk4 = [] } = useGLTF(ANIMATION_PATHS.talking[3]);\n  const { animations: talk5 = [] } = useGLTF(ANIMATION_PATHS.talking[4]);\n  const { animations: talk6 = [] } = useGLTF(ANIMATION_PATHS.talking[5]);\n  const { animations: talk7 = [] } = useGLTF(ANIMATION_PATHS.talking[6]);\n  const { animations: talk8 = [] } = useGLTF(ANIMATION_PATHS.talking[7]);\n  const { animations: talk9 = [] } = useGLTF(ANIMATION_PATHS.talking[8]);\n  const { animations: talk10 = [] } = useGLTF(ANIMATION_PATHS.talking[9]);\n\n  // Combine all talking animations\n  const allTalkingAnimations = useMemo(() => {\n    return [...talk1, ...talk2, ...talk3, ...talk4, ...talk5, ...talk6, ...talk7, ...talk8, ...talk9, ...talk10];\n  }, [talk1, talk2, talk3, talk4, talk5, talk6, talk7, talk8, talk9, talk10]);\n  \n  // Combine all animations\n  const allAnimations = useMemo(() => {\n    return [...idleAnimations, ...allTalkingAnimations];\n  }, [idleAnimations, allTalkingAnimations]);\n  \n  // Preload all animations\n  useEffect(() => {\n    ANIMATION_PATHS.idle.forEach(url => useGLTF.preload(url));\n    ANIMATION_PATHS.talking.forEach(url => useGLTF.preload(url));\n  }, []);\n  \n  const { actions, mixer } = useAnimations(allAnimations, clonedScene || groupRef);\n  \n  const activeActionNameRef = useRef<string | null>(null);\n  const lastTalkingAnimationRef = useRef<string | null>(null);\n  \n  // Animation management\n  useEffect(() => {\n    if (!actions || Object.keys(actions).length === 0) {\n      console.log('[MasculinePresenceAvatar] No animation actions available to play.');\n      return;\n    }\n\n    const playAnimation = (name: string) => {\n      const oldActionName = activeActionNameRef.current;\n      \n      if (oldActionName === name && actions[name]?.isRunning()) {\n        return;\n      }\n\n      // Handle talking animations - pick a random one\n      let actualAnimationName = name;\n      if (name === 'talking') {\n        const talkingActions = Object.keys(actions).filter(key => \n          key.toLowerCase().includes('talk') || key.toLowerCase().includes('talking')\n        );\n        \n        if (talkingActions.length > 0) {\n          actualAnimationName = talkingActions[Math.floor(Math.random() * talkingActions.length)];\n          lastTalkingAnimationRef.current = actualAnimationName;\n        } else if (lastTalkingAnimationRef.current && actions[lastTalkingAnimationRef.current]) {\n          actualAnimationName = lastTalkingAnimationRef.current;\n        }\n      } else if (name === 'idle') {\n        const idleActions = Object.keys(actions).filter(key => \n          key.toLowerCase().includes('idle')\n        );\n        \n        if (idleActions.length > 0) {\n          actualAnimationName = idleActions[0];\n        }\n      }\n\n      const selectedAction = actions[actualAnimationName];\n      if (!selectedAction) {\n        console.warn(`[MasculinePresenceAvatar] Animation \"${actualAnimationName}\" not found`);\n        return;\n      }\n\n      // Fade out old animation\n      if (oldActionName && actions[oldActionName]) {\n        actions[oldActionName].fadeOut(0.3);\n        setTimeout(() => {\n          actions[oldActionName]?.stop();\n        }, 300);\n      }\n\n      // Play new animation\n      selectedAction.reset();\n      selectedAction.fadeIn(0.5);\n      selectedAction.timeScale = 0.5; // Slow down animation to 50% speed\n      selectedAction.play();\n      \n      console.log('[MasculinePresenceAvatar] Playing animation:', actualAnimationName, 'timeScale:', selectedAction.timeScale);\n      activeActionNameRef.current = actualAnimationName;\n    };\n\n    playAnimation(animationName);\n  }, [animationName, actions]);\n\n  // Setup model\n  useEffect(() => {\n    if (!clonedScene) return;\n\n    console.log('[MasculinePresenceAvatar] Setting up model...');\n    \n    let mesh: THREE.SkinnedMesh | null = null;\n    let meshCount = 0;\n    clonedScene?.traverse((child) => {\n      if (child instanceof THREE.SkinnedMesh) {\n        meshCount++;\n        console.log('[MasculinePresenceAvatar] Found SkinnedMesh:', {\n          name: child.name,\n          hasMorphTargetDictionary: !!child.morphTargetDictionary,\n          morphTargetCount: child.morphTargetDictionary ? Object.keys(child.morphTargetDictionary).length : 0,\n          morphTargets: child.morphTargetDictionary ? Object.keys(child.morphTargetDictionary).slice(0, 5) : []\n        });\n        \n        if (child.morphTargetDictionary) {\n          mesh = child;\n          meshWithMorphTargets.current = child;\n          // Force enable morph target influences\n          if (mesh.morphTargetInfluences) {\n            mesh.morphTargetInfluences = mesh.morphTargetInfluences.map(() => 0);\n          }\n          if (!morphTargetsLoggedRef.current) {\n            console.log('[MasculinePresenceAvatar] Available morph targets:', Object.keys(child.morphTargetDictionary));\n            morphTargetsLoggedRef.current = true;\n          }\n        }\n      } else if (child instanceof THREE.Bone) {\n        const boneName = child.name.toLowerCase();\n        if (boneName.includes('head') && !boneName.includes('headtop')) {\n          headBone.current = child;\n          initialHeadLocalQuaternionRef.current = child.quaternion.clone();\n        } else if (boneName.includes('neck')) {\n          neckBone.current = child;\n          initialNeckLocalQuaternionRef.current = child.quaternion.clone();\n        } else if (boneName.includes('jaw')) {\n          jawBone.current = child;\n        }\n      }\n    });\n    \n    modelRootRef.current = clonedScene;\n    \n    console.log('[MasculinePresenceAvatar] Model setup complete', {\n      hasMorphTargets: !!mesh,\n      hasHeadBone: !!headBone.current,\n      hasNeckBone: !!neckBone.current,\n      meshCount\n    });\n  }, [clonedScene]);\n\n  // Process tracking data\n  const processedTrackingData = useMemo(() => {\n    if (!trackingData || trackingData === undefined) {\n      return null;\n    }\n    \n    let expressions: Partial<FacialExpressions> = {};\n    let headRotation = null;\n    \n    if (trackingData.facialExpressions) {\n      expressions = trackingData.facialExpressions;\n    }\n    \n    if (trackingData.headRotation && \n        typeof trackingData.headRotation === 'object' &&\n        'pitch' in trackingData.headRotation) {\n      headRotation = trackingData.headRotation;\n    }\n    \n    return {\n      facialExpressions: expressions,\n      headRotation: headRotation\n    };\n  }, [trackingData]);\n\n  // Animation frame\n  useFrame((state, delta) => {\n    if (!modelRootRef.current) return;\n\n    const currentFrameCount = state.clock.elapsedTime * 60;\n    frameCountRef.current = Math.floor(currentFrameCount);\n    \n    const tracking = processedTrackingData;\n    const mesh = meshWithMorphTargets.current;\n    \n    // Lip sync from audio\n    if (animationName === 'talking' && audioData && audioData.length > 0) {\n      // Debug log mesh state\n      if (frameCountRef.current % 30 === 0) {\n        console.log('[MasculinePresenceAvatar] Lip sync check:', {\n          hasMesh: !!mesh,\n          hasMorphTargetDictionary: !!mesh?.morphTargetDictionary,\n          morphTargetCount: mesh?.morphTargetDictionary ? Object.keys(mesh.morphTargetDictionary).length : 0,\n          morphTargets: mesh?.morphTargetDictionary ? Object.keys(mesh.morphTargetDictionary).slice(0, 10) : [],\n          audioDataLength: audioData.length,\n          animationName\n        });\n      }\n      \n      if (mesh?.morphTargetDictionary) {\n        let totalEnergy = 0;\n        const relevantBins = Math.min(64, audioData.length);\n        let maxEnergy = 0;\n        \n        for (let i = 0; i < relevantBins; i++) {\n          // Weight speech frequencies more heavily (100-1000 Hz range typically bins 2-20)\n          let weight = 1.0;\n          if (i >= 2 && i <= 20) {\n            weight = 2.0; // Double weight for speech frequencies\n          }\n          const binEnergy = audioData[i] * weight;\n          totalEnergy += binEnergy;\n          maxEnergy = Math.max(maxEnergy, audioData[i]);\n        }\n        \n        // Use both average and peak energy for more responsive lip sync\n        const averageEnergy = relevantBins > 0 ? totalEnergy / relevantBins / 255 : 0;\n        const peakEnergy = maxEnergy / 255;\n        const combinedEnergy = Math.max(averageEnergy, peakEnergy * 0.7);\n        \n        // Log morph targets once\n        if (frameCountRef.current === 0) {\n          console.log('[MasculinePresenceAvatar] Available morph targets:', Object.keys(mesh.morphTargetDictionary));\n        }\n        \n        // Try multiple possible jaw/mouth morph targets (including numbered ones for Dougie)\n        const possibleJawTargets = ['jawOpen', 'mouthOpen', 'viseme_aa', 'viseme_O', '0', '1'];\n        let jawTargetFound = false;\n        \n        for (const target of possibleJawTargets) {\n          if (mesh.morphTargetDictionary[target] !== undefined) {\n            // Reduced multiplier for more natural mouth movement\n            const lipSyncValue = MathUtils.clamp(combinedEnergy * 2.0, 0, 0.4);\n            \n            // Force set the value directly to ensure it's not overridden\n            const morphIndex = mesh.morphTargetDictionary[target];\n            if (mesh.morphTargetInfluences && morphIndex !== undefined) {\n              mesh.morphTargetInfluences[morphIndex] = lipSyncValue;\n            }\n            \n            // For numbered targets, try to apply to both if they exist (one might be jaw, one might be tongue)\n            if (target === '0' && mesh.morphTargetDictionary['1'] !== undefined) {\n              const secondIndex = mesh.morphTargetDictionary['1'];\n              if (mesh.morphTargetInfluences && secondIndex !== undefined) {\n                mesh.morphTargetInfluences[secondIndex] = lipSyncValue * 0.5;\n              }\n            }\n            \n            // Debug lip sync every 30 frames\n            if (frameCountRef.current % 30 === 0 && combinedEnergy > 0) {\n              console.log('[MasculinePresenceAvatar] Lip sync applied:', {\n                target,\n                averageEnergy,\n                peakEnergy,\n                combinedEnergy,\n                lipSyncValue,\n                morphIndex,\n                totalEnergy,\n                maxEnergy,\n                audioDataLength: audioData.length,\n                audioDataSample: Array.from(audioData.slice(0, 10))\n              });\n            }\n            jawTargetFound = true;\n            break;\n          }\n        }\n        \n        if (!jawTargetFound && frameCountRef.current % 300 === 0) {\n          console.warn('[MasculinePresenceAvatar] No jaw/mouth morph target found! Available targets:', Object.keys(mesh.morphTargetDictionary));\n        }\n      }\n    } else if (animationName === 'idle' && mesh?.morphTargetInfluences && mesh?.morphTargetDictionary) {\n      // Reset all morph targets when idle\n      Object.keys(mesh.morphTargetDictionary).forEach((targetName) => {\n        const targetIndex = mesh.morphTargetDictionary![targetName];\n        if (targetIndex !== undefined && mesh.morphTargetInfluences) {\n          mesh.morphTargetInfluences[targetIndex] = 0;\n        }\n      });\n    }\n    \n    // Apply emotional blendshapes\n    if (hasEmotionalBlendshapes && mesh?.morphTargetDictionary) {\n      // Log mesh info every 60 frames\n      if (frameCountRef.current % 60 === 0) {\n        console.log('[MasculinePresenceAvatar] Mesh info:', {\n          hasMesh: !!mesh,\n          morphTargetDictionary: Object.keys(mesh.morphTargetDictionary || {}),\n          morphTargetInfluences: mesh.morphTargetInfluences?.length || 0\n        });\n      }\n      \n      Object.entries(emotionalBlendshapes!).forEach(([emotion, value]) => {\n        const blendshapes = EMOTION_TO_BLENDSHAPE[emotion];\n        if (blendshapes) {\n          blendshapes.forEach(blendshape => {\n            const mapping = HUME_TO_RPM_MAPPING[blendshape];\n            if (mapping && mesh.morphTargetDictionary![mapping.target] !== undefined) {\n              const targetIndex = mesh.morphTargetDictionary![mapping.target];\n              const amplifiedValue = value * (mapping.amplify || 1.0);\n              \n              if (mesh.morphTargetInfluences) {\n                mesh.morphTargetInfluences[targetIndex] = MathUtils.clamp(amplifiedValue, 0, 1);\n                \n                // Log when we set a significant morph target\n                if (amplifiedValue > 0.1 && frameCountRef.current % 60 === 0) {\n                  console.log('[MasculinePresenceAvatar] Setting morph:', {\n                    emotion,\n                    blendshape,\n                    targetName: mapping.target,\n                    targetIndex,\n                    value: amplifiedValue\n                  });\n                }\n              }\n            } else if (value > 0.1 && frameCountRef.current % 60 === 0) {\n              // Log missing morph targets\n              console.warn('[MasculinePresenceAvatar] Missing morph target:', {\n                emotion,\n                blendshape,\n                attemptedTarget: mapping?.target,\n                available: Object.keys(mesh.morphTargetDictionary || {}).slice(0, 10)\n              });\n            }\n          });\n        }\n      });\n    } else if (tracking?.facialExpressions && mesh?.morphTargetDictionary) {\n      // Apply ML5 tracking expressions\n      Object.entries(tracking.facialExpressions).forEach(([expression, value]) => {\n        if (mesh.morphTargetDictionary![expression] !== undefined) {\n          const targetIndex = mesh.morphTargetDictionary![expression];\n          if (mesh.morphTargetInfluences) {\n            mesh.morphTargetInfluences[targetIndex] = MathUtils.clamp(value, 0, 1);\n          }\n        }\n      });\n    }\n    \n    // Apply head rotation for user avatars\n    if (tracking?.headRotation && headBone.current && !isCoachAvatar) {\n      const headRotation = tracking.headRotation;\n      \n      if (headRotation && typeof headRotation === 'object') {\n        const rotationLerpFactor = 0.8;\n        \n        headBone.current.rotation.x = lerp(\n          headBone.current.rotation.x,\n          clampRotation(-headRotation.pitch * 0.5, { min: -0.5, max: 0.5 }),\n          rotationLerpFactor\n        );\n        \n        headBone.current.rotation.y = lerp(\n          headBone.current.rotation.y,\n          clampRotation(headRotation.yaw * 0.5, { min: -0.7, max: 0.7 }),\n          rotationLerpFactor\n        );\n        \n        headBone.current.rotation.z = lerp(\n          headBone.current.rotation.z,\n          clampRotation(-headRotation.roll * 0.3, { min: -0.3, max: 0.3 }),\n          rotationLerpFactor\n        );\n      }\n    }\n    \n    // Mix animations\n    if (mixer) {\n      mixer.update(delta);\n    }\n    \n    // Find the SkinnedMesh with morph targets if we don't have it yet\n    if (!meshWithMorphTargets.current && clonedScene) {\n      clonedScene.traverse((child) => {\n        if (child instanceof THREE.SkinnedMesh && child.morphTargetDictionary) {\n          meshWithMorphTargets.current = child;\n          console.log('[MasculinePresenceAvatar] Found mesh with morph targets in frame');\n        }\n      });\n    }\n    \n    // Rest of the code remains the same\n  });\n\n  if (!clonedScene || !modelRootRef.current) {\n    return null;\n  }\n\n  return (\n    <group ref={groupRef} position={position} scale={scale}>\n      <primitive object={modelRootRef.current} />\n    </group>\n  );\n};\n\nexport default MasculinePresenceAvatar;\n"],"names":["HUME_TO_RPM_MAPPING","target","amplify","EMOTION_TO_BLENDSHAPE","joy","sadness","anger","fear","surprise","disgust","contempt","clampRotation","value","limits","Math","max","min","lerp","current","factor","THREE","ANIMATION_PATHS","idle","talking","MasculinePresenceAvatar","_ref","avatarUrl","position","scale","trackingData","animationName","emotionalBlendshapes","audioData","participantId","isCoachAvatar","undefined","hasEmotionalBlendshapes","Object","keys","length","groupRef","useRef","modelRootRef","meshWithMorphTargets","headBone","neckBone","jawBone","initialHeadLocalQuaternionRef","initialNeckLocalQuaternionRef","frameCountRef","morphTargetsLoggedRef","scene","useGLTF","clonedScene","useMemo","SkeletonUtils","clone","animations","idleAnimations","talk1","talk2","talk3","talk4","talk5","talk6","talk7","talk8","talk9","talk10","allTalkingAnimations","allAnimations","useEffect","forEach","url","preload","actions","mixer","useAnimations","activeActionNameRef","lastTalkingAnimationRef","console","log","name","_actions$name","oldActionName","isRunning","actualAnimationName","talkingActions","filter","key","toLowerCase","includes","floor","random","idleActions","selectedAction","fadeOut","setTimeout","_actions$oldActionNam","stop","reset","fadeIn","timeScale","play","warn","concat","playAnimation","mesh","meshCount","traverse","child","hasMorphTargetDictionary","morphTargetDictionary","morphTargetCount","morphTargets","slice","morphTargetInfluences","map","boneName","quaternion","hasMorphTargets","hasHeadBone","hasNeckBone","processedTrackingData","expressions","headRotation","facialExpressions","useFrame","state","delta","currentFrameCount","clock","elapsedTime","tracking","hasMesh","audioDataLength","totalEnergy","relevantBins","maxEnergy","i","weight","averageEnergy","peakEnergy","combinedEnergy","possibleJawTargets","jawTargetFound","lipSyncValue","MathUtils","clamp","morphIndex","secondIndex","audioDataSample","Array","from","targetName","targetIndex","_mesh$morphTargetInfl","entries","_ref2","emotion","blendshapes","blendshape","mapping","amplifiedValue","attemptedTarget","available","_ref3","expression","rotationLerpFactor","rotation","x","pitch","y","yaw","z","roll","update","_jsx","ref","children","object"],"sourceRoot":""}