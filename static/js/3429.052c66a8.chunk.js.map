{"version":3,"file":"static/js/3429.052c66a8.chunk.js","mappings":"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","sources":["components/ML5FaceMeshTest.tsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\n\ndeclare const ml5: any;\n\nconst ML5FaceMeshTest: React.FC = () => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const [status, setStatus] = useState<string>('Initializing...');\n  const [predictions, setPredictions] = useState<any>(null);\n  const [error, setError] = useState<string | null>(null);\n  const facemeshRef = useRef<any>(null);\n\n  useEffect(() => {\n    const initializeFaceMesh = async () => {\n      try {\n        // Check ML5 availability\n        if (typeof ml5 === 'undefined') {\n          setError('ML5 is not loaded');\n          return;\n        }\n\n        setStatus(`ML5 version: ${ml5.version || 'unknown'}`);\n\n        // Get user media\n        const stream = await navigator.mediaDevices.getUserMedia({ \n          video: { width: 640, height: 480 } \n        });\n        \n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n          \n          // Wait for video to be ready\n          await new Promise<void>((resolve) => {\n            if (videoRef.current) {\n              videoRef.current.onloadedmetadata = () => {\n                videoRef.current?.play();\n                resolve();\n              };\n            }\n          });\n\n          setStatus('Video ready, initializing ML5 FaceMesh...');\n\n          // ML5 v0.12.2 uses the old API\n          if (typeof ml5.facemesh !== 'undefined') {\n            setStatus('Using ML5 v0.12.2 API');\n            facemeshRef.current = ml5.facemesh({\n              maxFaces: 1,\n              flipHorizontal: false\n            }, () => {\n              setStatus('FaceMesh model loaded successfully');\n              startDetection();\n            });\n          } else {\n            setError('ml5.facemesh is not available');\n          }\n        }\n      } catch (err) {\n        console.error('Initialization error:', err);\n        setError(err instanceof Error ? err.message : 'Unknown error');\n      }\n    };\n\n    const startDetection = () => {\n      if (!facemeshRef.current || !videoRef.current) return;\n\n      const detect = () => {\n        if (!facemeshRef.current || !videoRef.current) return;\n\n        try {\n          // Use callback pattern\n          if (typeof facemeshRef.current.predict === 'function') {\n            facemeshRef.current.predict(videoRef.current, (predictions: any) => {\n              if (predictions && predictions.length > 0) {\n                setPredictions(predictions[0]);\n                setStatus(`Detecting... ${predictions[0].landmarks?.length || 0} landmarks`);\n              }\n            });\n          } else if (typeof facemeshRef.current.detect === 'function') {\n            facemeshRef.current.detect(videoRef.current, (predictions: any) => {\n              if (predictions && predictions.length > 0) {\n                setPredictions(predictions[0]);\n                setStatus(`Detecting... ${predictions[0].landmarks?.length || 0} landmarks`);\n              }\n            });\n          }\n        } catch (err) {\n          console.error('Detection error:', err);\n          setError(err instanceof Error ? err.message : 'Detection error');\n        }\n\n        // Continue detection loop\n        requestAnimationFrame(detect);\n      };\n\n      detect();\n    };\n\n    initializeFaceMesh();\n\n    // Cleanup\n    return () => {\n      if (videoRef.current && videoRef.current.srcObject) {\n        const tracks = (videoRef.current.srcObject as MediaStream).getTracks();\n        tracks.forEach(track => track.stop());\n      }\n      if (facemeshRef.current && typeof facemeshRef.current.stop === 'function') {\n        facemeshRef.current.stop();\n      }\n    };\n  }, []);\n\n  return (\n    <div style={{ padding: '20px' }}>\n      <h2>ML5 FaceMesh Test</h2>\n      <div>Status: {status}</div>\n      {error && <div style={{ color: 'red' }}>Error: {error}</div>}\n      <div style={{ marginTop: '10px' }}>\n        <video\n          ref={videoRef}\n          width={640}\n          height={480}\n          style={{ border: '1px solid #ccc' }}\n          playsInline\n          muted\n        />\n      </div>\n      {predictions && (\n        <div style={{ marginTop: '10px' }}>\n          <h3>Predictions:</h3>\n          <pre>{JSON.stringify({\n            landmarks: predictions.landmarks?.length || 0,\n            boundingBox: predictions.boundingBox,\n            faceOval: predictions.faceOval?.length || 0\n          }, null, 2)}</pre>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default ML5FaceMeshTest;\n"],"names":["ML5FaceMeshTest","_predictions$landmark","_predictions$faceOval","videoRef","useRef","status","setStatus","useState","predictions","setPredictions","error","setError","facemeshRef","useEffect","startDetection","current","detect","predict","_predictions$0$landma","length","concat","landmarks","_predictions$0$landma2","err","console","Error","message","requestAnimationFrame","async","ml5","version","stream","navigator","mediaDevices","getUserMedia","video","width","height","srcObject","Promise","resolve","onloadedmetadata","_videoRef$current","play","facemesh","maxFaces","flipHorizontal","initializeFaceMesh","getTracks","forEach","track","stop","_jsxs","style","padding","children","_jsx","color","marginTop","ref","border","playsInline","muted","JSON","stringify","boundingBox","faceOval"],"sourceRoot":""}